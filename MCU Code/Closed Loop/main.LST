C51 COMPILER V9.03   MAIN                                                                  06/20/2011 21:06:48 PAGE 1   


C51 COMPILER V9.03, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c LARGE MODC2 MDU_R515 INCDIR(..\hal\nrf24l01p;..\hal;..\compiler\c51;
                    -..\hal\nrf24le1;..\compiler\common) DEFINE(MCU_NRF24LE1)

line level    source

   1          
   2          #include "hardware.h"
   3          
   4          #include <nordic_common.h>
   5          #include <intrins.h>
   6          #include <stdint.h>
   7          #include <stdbool.h>
   8          #include "hal_nrf.h"
   9          #include "hal_nrf_hw.h"
  10          #include "hal_adc.h"
  11          #include "timer.h"
  12          
  13          #define SIZEOFPROG 11
  14          
  15          #define MAXLENGTH 30
  16          #define MAXBLOCKS  4
  17          #define CALC_PAYLOAD_PTR(bl) payload+bl*MAXPAYLOAD
  18           
  19          // Global variables
  20          data bool radio_busy;
  21          void init_radio();
  22          void init_adc();
  23          
  24          void prog_led(uint8_t amp);
  25          
  26          data uint8_t g_Amplitude = 0;
  27          data uint8_t acq_block;  // current block thats acquiring data
  28          data uint8_t payload[2][MAXLENGTH+1];
  29          data uint8_t progPayload[32];
  30          
  31          data uint8_t *ptr_payload;
  32          data uint8_t cnt;
  33          data uint8_t dataNeedsTx;
  34          data bool procPayload = false;
  35          
  36          data progAll *pAll;
  37          data progStim pStim;
  38          data progAlgo pAlgo;
  39          
  40          uint16_t low_thresh = 500;
  41          uint16_t high_thresh = 900;
  42          uint8_t pktCount = 0;
  43          
  44          void main()
  45          {
  46   1        uint8_t is = 0;;
  47   1        acq_block = 0;
  48   1        P1DIR = ~((1<<6) | (1<<3));
  49   1        P0CON = 0x66;
  50   1      
  51   1        #ifdef MCU_NRF24LU1P
                   USBSLP = 0x01;  // disable usb
                  // P0DIR = (1<<3)|(1<<1)|(1<<0);
                      // P0ALT = 0x0F;
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 21:06:48 PAGE 2   

                      // P0EXP = 0x02; // Slave SPI for P0
                      // SSCONF = 0x01; //Enable slave SPI
                       
                       // Enable radio SPI
                       RFCTL = 0x10;
              //        I3FR = 1;             // rising edge SPI ready detect
                        P0_0 = 0;
              //        INTEXP = 0x01; //Slave SPI Interrupt
                #else
  64   1      //      P0DIR =  ~((1<<4)|(1<<0));
  65   1       //     SPISCON0 = 0x40;
  66   1      //      I3FR = 1;             // rising edge SPI ready detect
  67   1      //      P1_4 = 1;
  68   1        //    INTEXP = 0x01; //Slave SPI Interrupt
  69   1      
  70   1        #endif
  71   1      
  72   1       // SPI = 1; // Enable SPI Interrupt
  73   1      
  74   1      
  75   1       //  ET0 = 1; // enable timer interrupt
  76   1        // EX0 = 1; 
  77   1      
  78   1      
  79   1       //  hal_digi_init();
  80   1      //   hal_digi_write(0);
  81   1      
  82   1      
  83   1              for(is = 1; is <= 14; ++is)
  84   1              {
  85   2                      prog_led(is);
  86   2              }
  87   1      
  88   1              prog_led(0);
  89   1      
  90   1              init_radio();
  91   1              init_adc(); 
  92   1              initTimer();
  93   1              cnt = MAXLENGTH;
  94   1              dataNeedsTx = 0;
  95   1              hal_adc_start();
  96   1              procPayload = false;
  97   1      
  98   1              for(;;)
  99   1              {
 100   2                      if(dataNeedsTx)
 101   2                      {
 102   3                              P1_4 = 1;
 103   3                              ++pktCount;
 104   3                              payload[((acq_block^(0x01))&(0x01))][MAXLENGTH] = (isStimulating) + (pktCount&(0x7F)); 
 105   3                              hal_nrf_write_tx_payload(payload[((acq_block^(0x01))&(0x01))],MAXLENGTH+1);
 106   3                              P1_4 = 0;
 107   3                              radio_busy = true;
 108   3                                  // Toggle radio CE signal to start transmission 
 109   3                          CE_PULSE();
 110   3                      
 111   3                          
 112   3                      
 113   3                          // Wait for radio operation to finish
 114   3                          while(radio_busy);
 115   3                              
 116   3                              if(procPayload)
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 21:06:48 PAGE 3   

 117   3                              {
 118   4                                      procPayload = false;
 119   4                                      pAll = (progAll *)progPayload;
 120   4                              
 121   4                                      if(pAll->pType == PROGSTIM)
 122   4                                      {
 123   5                                              pStim = pAll->pStim;
 124   5                                              
 125   5                                              g_Amplitude = pStim.Amplitude;
 126   5      
 127   5                                              if(0 == pStim.Freq)
 128   5                                              {
 129   6                                                 ET2 = 0;       // disable timer2 interrupt
 130   6                                                prog_led(g_Amplitude);        
 131   6                                              }
 132   5                                              else
 133   5                                              {
 134   6                                                      ET2 = 1;
 135   6                                                      progTimer(&pStim);
 136   6                                              }
 137   5                                      }       
 138   4                              }
 139   3                              dataNeedsTx = 0;
 140   3                      }
 141   2              }
 142   1      }
 143          
 144          uint8_t lowThreshPassed = 0;
 145          uint8_t highThreshPassed = 0;
 146          
 147          void adc_irq() interrupt INTERRUPT_MISCIRQ      // should only be called for ADC, RNG is disabled
 148          {       
 149   1              uint16_t tempVal;
 150   1                      
 151   1                      *ptr_payload = ADCDATH;
 152   1                      ++ptr_payload;
 153   1                      *ptr_payload = ADCDATL;    // big-endian storage
 154   1                      ++ptr_payload;
 155   1      
 156   1                      tempVal = (ADCDATH << 8) + ADCDATL;
 157   1      
 158   1                      if( tempVal > low_thresh)
 159   1                      {
 160   2                              lowThreshPassed = 1;
 161   2                      } else {
 162   2                              lowThreshPassed = 0;
 163   2                              highThreshPassed = 0;
 164   2                      }
 165   1      
 166   1                      if(lowThreshPassed && !highThreshPassed && tempVal > high_thresh)
 167   1                      {
 168   2                                      // P1_6 ^= 1;
 169   2                                              peakDetect();
 170   2                                      lowThreshPassed = 0;
 171   2                                      highThreshPassed = 1;
 172   2                      }
 173   1                      cnt -= 2; 
 174   1              
 175   1                      if(cnt==0)
 176   1                      {
 177   2                              cnt = MAXLENGTH;
 178   2                              acq_block &= 1;
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 21:06:48 PAGE 4   

 179   2                              acq_block ^= 1; // toggle current acquisition block
 180   2                              ptr_payload = payload[acq_block];  // reset data pointer
 181   2                              dataNeedsTx = 1; 
 182   2                      }       
 183   1      }
 184          
 185          void init_adc()
 186          {
 187   1         hal_adc_set_input_channel(HAL_ADC_INP_AIN0);                     
 188   1         hal_adc_set_reference(HAL_ADC_REF_VDD);                        
 189   1         hal_adc_set_acq_window(HAL_ADC_AQW_12US);
 190   1         hal_adc_set_input_mode(HAL_ADC_SINGLE);                             
 191   1         hal_adc_set_conversion_mode(HAL_ADC_CONTINOUS);               
 192   1         hal_adc_set_resolution(HAL_ADC_RES_12BIT);                          
 193   1         hal_adc_set_data_just(HAL_ADC_JUST_RIGHT);
 194   1         hal_adc_set_sampling_rate(HAL_ADC_4KSPS);
 195   1         
 196   1         MISC = 1; // Enable ADC interrupt through MISC interrupt 
 197   1      }
 198          
 199          void init_radio()
 200          {
 201   1        // Enable the radio clock
 202   1        RFCKEN = 1;
 203   1        // Enable RF interrupt
 204   1        RF = 1;
 205   1          // Power up radio
 206   1        hal_nrf_set_power_mode(HAL_NRF_PWR_UP);
 207   1      
 208   1              hal_nrf_enable_ack_payload(1);
 209   1              hal_nrf_enable_dynamic_payload(1);
 210   1              hal_nrf_setup_dynamic_payload(1); // Set up PIPE 0 to handle dynamic lengths
 211   1              hal_nrf_set_rf_channel(125); // 2525 MHz
 212   1         //hal_nrf_set_auto_retr(3, 200); // Retry 5x
 213   1          // Configure radio as primary receiver (PTX) 
 214   1        hal_nrf_set_operation_mode(HAL_NRF_PTX);
 215   1       
 216   1            // Set payload width to 32 bytes
 217   1      //  hal_nrf_set_rx_payload_width(HAL_NRF_PIPE0, MAXLENGTH);
 218   1         // Enable global interrupt
 219   1        EA = 1;
 220   1      }
 221          
 222          // Radio interrupt
 223          void rf_irq() interrupt INTERRUPT_RFIRQ
 224          {
 225   1        uint8_t irq_flags;
 226   1      
 227   1        // Read and clear IRQ flags from radio
 228   1        irq_flags = hal_nrf_get_clear_irq_flags(); 
 229   1      
 230   1        switch(irq_flags)
 231   1        {
 232   2          // Transmission success
 233   2              case ( (1 << HAL_NRF_RX_DR) | (1 << HAL_NRF_TX_DS) ):     // We rx payload packet
 234   2                      procPayload = true;
 235   2                      // Read payload
 236   2                      while(!hal_nrf_rx_fifo_empty())
 237   2                      {
 238   3                      hal_nrf_read_rx_payload(progPayload);
 239   3                      }
 240   2                      radio_busy = false;
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 21:06:48 PAGE 5   

 241   2          case (1 << HAL_NRF_TX_DS):
 242   2            radio_busy = false;
 243   2            // Data has been sent
 244   2            break;
 245   2          // Transmission failed (maximum re-transmits)
 246   2          case (1 << HAL_NRF_MAX_RT):
 247   2            // When a MAX_RT interrupt occurs the TX payload will not be removed from the TX FIFO. 
 248   2            // If the packet is to be discarded this must be done manually by flushing the TX FIFO.
 249   2            // Alternatively, CE_PULSE() can be called re-starting transmission of the payload.
 250   2            // (Will only be possible after the radio irq flags are cleared) 
 251   2            hal_nrf_flush_tx();
 252   2            radio_busy = false;
 253   2            break;
 254   2        }
 255   1      }
 256          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    653    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      7       2
   PDATA SIZE       =   ----    ----
   DATA SIZE        =    116    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
