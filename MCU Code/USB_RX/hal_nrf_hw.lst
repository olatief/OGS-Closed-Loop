C51 COMPILER V9.03   HAL_NRF_HW                                                            06/20/2011 20:16:56 PAGE 1   


C51 COMPILER V9.03, COMPILATION OF MODULE HAL_NRF_HW
OBJECT MODULE PLACED IN .\hal_nrf_hw.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\hal\nrf24lu1p\hal_nrf_hw.c LARGE BROWSE INCDIR(.;..\compiler\c51;..\hal\
                    -nrf24lu1p;..\hal\nrf24l01p;..\hal;..\compiler\common) DEFINE(MCU_NRF24LU1P) DEBUG OBJECTEXTEND CODE LISTINCLUDE SYMBOLS 
                    -PRINT(.\hal_nrf_hw.lst) PREPRINT(.\hal_nrf_hw.i) OBJECT(.\hal_nrf_hw.obj)

line level    source

   1          /* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
   2           *
   3           * The information contained herein is confidential property of Nordic 
   4           * Semiconductor ASA.Terms and conditions of usage are described in detail 
   5           * in NORDIC SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6           *
   7           * Licensees are granted free, non-transferable use of the information. NO
   8           * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9           * the file.
  10           *              
  11           * $LastChangedRevision: 133 $
  12           */
  13          
  14          /** @file
  15           * @brief Implementation of #hal_nrf_rw for nRF24LU1+
  16           *
  17           * #hal_nrf_rw is an SPI function which is hardware dependent. This file
  18           * contains an implementation for nRF24LU1.
  19           */
  20          
  21          #include <stdint.h>
   1      =1  /* Copyright (c) 2007 Nordic Semiconductor. All Rights Reserved.
   2      =1   *
   3      =1   * The information contained herein is property of Nordic Semiconductor ASA.
   4      =1   * Terms and conditions of usage are described in detail in NORDIC
   5      =1   * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =1   *
   7      =1   * Licensees are granted free, non-transferable use of the information. NO
   8      =1   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =1   * the file.
  10      =1   *
  11      =1   * $LastChangedRevision: 186 $
  12      =1   */
  13      =1  
  14      =1  /** @file
  15      =1   * Type definitions for firmware projects developed at Nordic Semiconductor.
  16      =1   *
  17      =1   * Standard storage classes in C, such as @c char, @c int, and @c long, are not always
  18      =1   * interpreted in the same way by the compiler. The types here are defined by their
  19      =1   * bit length and signed/unsigned property, as their names indicate. The correlation
  20      =1   * between the name and properties of the storage class should be true, regardless of
  21      =1   * the compiler being used.
  22      =1   */
  23      =1  
  24      =1  #ifndef __STDINT_H__
  25      =1  #define __STDINT_H__
  26      =1  
  27      =1  #ifdef __C51__
  28      =1  
  29      =1  typedef unsigned char uint8_t;        ///< 8 bit unsigned int
  30      =1  
  31      =1  typedef signed char int8_t;          ///< 8 bit signed int
  32      =1  
C51 COMPILER V9.03   HAL_NRF_HW                                                            06/20/2011 20:16:56 PAGE 2   

  33      =1  typedef unsigned int uint16_t;        ///< 16 bit unsigned int
  34      =1  
  35      =1  typedef signed int int16_t;          ///< 16 bit signed int
  36      =1  
  37      =1  typedef unsigned long uint32_t;       ///< 32 bit unsigned int
  38      =1  
  39      =1  typedef signed long int32_t;         ///< 32 bit signed int
  40      =1  
  41      =1  #endif // __C51__
  42      =1  
  43      =1  #ifndef NULL
  44      =1  #define NULL (void*)0
  45      =1  #endif
  46      =1  
  47      =1  #endif // __STDINT_H__
  22          #include "hal_nrf.h"
   1      =1  /* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
   2      =1   *
   3      =1   * The information contained herein is confidential property of Nordic 
   4      =1   * Semiconductor ASA.Terms and conditions of usage are described in detail 
   5      =1   * in NORDIC SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =1   *
   7      =1   * Licensees are granted free, non-transferable use of the information. NO
   8      =1   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =1   * the file.
  10      =1   *              
  11      =1   * $LastChangedRevision: 133 $
  12      =1   */
  13      =1  
  14      =1  /** @file
  15      =1   * @brief Interface functions for the on-chip radio transceiver. 
  16      =1   */
  17      =1   
  18      =1  /** @defgroup hal_nrf24l01p_hal_nrf RF tranceiver (hal_nrf)
  19      =1   * @{
  20      =1   * @ingroup hal_nrf24l01p
  21      =1   * 
  22      =1   * This is the nRF24L01+ transceiver used in several Nordic Semiconductor devices.
  23      =1   * The transceiver is set up and controlled via an internal SPI interface on the chip. 
  24      =1   * The HAL for the radio transceiver hides this SPI interface from the programmer.
  25      =1   *
  26      =1   * The nRF24LE1 uses the same 2.4GHz GFSK RF transceiver with embedded protocol engine 
  27      =1   * (Enhanced ShockBurst&tm;) that is found in the nRF24L01+ single chip RF Transceiver.
  28      =1   *
  29      =1   * The RF Transceiver module is configured and operated through the RF transceiver map. 
  30      =1   * This register map is accessed by the MCU through a dedicated on-chip Serial 
  31      =1   * Peripheral interface (SPI) and is available in all power modes of the RF Transceiver 
  32      =1   * module. The register map contains all configuration registers in the RF Transceiver 
  33      =1   * and is accessible in all operation modes of the transceiver. The radio transceiver 
  34      =1   * HAL hides this register map and the usage of the internal SPI.
  35      =1   * 
  36      =1   * This HAL module contains setup functions for configurating the radio; operation functions 
  37      =1   * for controlling the radio when active and for sending and receiving data; and test 
  38      =1   * functions for setting the radio in test modes.
  39      =1   */
  40      =1  
  41      =1  #ifndef HAL_NRF_H__
  42      =1  #define HAL_NRF_H__
  43      =1  
  44      =1  #include <stdint.h>
   1      =2  /* Copyright (c) 2007 Nordic Semiconductor. All Rights Reserved.
   2      =2   *
C51 COMPILER V9.03   HAL_NRF_HW                                                            06/20/2011 20:16:56 PAGE 3   

   3      =2   * The information contained herein is property of Nordic Semiconductor ASA.
   4      =2   * Terms and conditions of usage are described in detail in NORDIC
   5      =2   * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =2   *
   7      =2   * Licensees are granted free, non-transferable use of the information. NO
   8      =2   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =2   * the file.
  10      =2   *
  11      =2   * $LastChangedRevision: 186 $
  12      =2   */
  13      =2  
  14      =2  /** @file
  15      =2   * Type definitions for firmware projects developed at Nordic Semiconductor.
  16      =2   *
  17      =2   * Standard storage classes in C, such as @c char, @c int, and @c long, are not always
  18      =2   * interpreted in the same way by the compiler. The types here are defined by their
  19      =2   * bit length and signed/unsigned property, as their names indicate. The correlation
  20      =2   * between the name and properties of the storage class should be true, regardless of
  21      =2   * the compiler being used.
  22      =2   */
  23      =2  
  24      =2  #ifndef __STDINT_H__
           =2 #define __STDINT_H__
           =2 
           =2 #ifdef __C51__
           =2 
           =2 typedef unsigned char uint8_t;        ///< 8 bit unsigned int
           =2 
           =2 typedef signed char int8_t;          ///< 8 bit signed int
           =2 
           =2 typedef unsigned int uint16_t;        ///< 16 bit unsigned int
           =2 
           =2 typedef signed int int16_t;          ///< 16 bit signed int
           =2 
           =2 typedef unsigned long uint32_t;       ///< 32 bit unsigned int
           =2 
           =2 typedef signed long int32_t;         ///< 32 bit signed int
           =2 
           =2 #endif // __C51__
           =2 
           =2 #ifndef NULL
           =2 #define NULL (void*)0
           =2 #endif
           =2 
           =2 #endif // __STDINT_H__
  45      =1  #include <stdbool.h>
   1      =2  /* Copyright (c) 2007 Nordic Semiconductor. All Rights Reserved.
   2      =2   *
   3      =2   * The information contained herein is property of Nordic Semiconductor ASA.
   4      =2   * Terms and conditions of usage are described in detail in NORDIC
   5      =2   * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
   6      =2   *
   7      =2   * Licensees are granted free, non-transferable use of the information. NO
   8      =2   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =2   * the file.
  10      =2   *
  11      =2   * $LastChangedRevision: 230 $
  12      =2   */
  13      =2  
  14      =2  /** @file
  15      =2   * Type definitions for firmware projects developed at Nordic Semiconductor.
  16      =2   *
C51 COMPILER V9.03   HAL_NRF_HW                                                            06/20/2011 20:16:56 PAGE 4   

  17      =2   * Standard storage classes in C, such as @c char, @c int, and @c long, are not always
  18      =2   * interpreted in the same way by the compiler. The types here are defined by their
  19      =2   * bit length and signed/unsigned property, as their names indicate. The correlation
  20      =2   * between the name and properties of the storage class should be true, regardless of
  21      =2   * the compiler being used.
  22      =2   */
  23      =2  
  24      =2  #ifndef __STDBOOL_H__
  25      =2  #define __STDBOOL_H__
  26      =2  
  27      =2  //lint -strong(b,_Bool)
  28      =2  typedef unsigned char _Bool; ///< Boolean type
  29      =2  
  30      =2  #define bool _Bool
  31      =2  #define true ((bool)1)
  32      =2  #define false ((bool)0)
  33      =2  #define __bool_true_false_are_defined 1
  34      =2  
  35      =2  #endif // __STDBOOL_H__
  46      =1  
  47      =1  #include "hal_nrf_reg.h"
   1      =2  /* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
   2      =2   *
   3      =2   * The information contained herein is confidential property of Nordic 
   4      =2   * Semiconductor ASA.Terms and conditions of usage are described in detail 
   5      =2   * in NORDIC SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =2   *
   7      =2   * Licensees are granted free, non-transferable use of the information. NO
   8      =2   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =2   * the file.
  10      =2   *              
  11      =2   * $LastChangedRevision: 173 $
  12      =2   */
  13      =2  
  14      =2  /** @file
  15      =2  @brief Register definitions for nRF24L01+
  16      =2  
  17      =2  @details Header file defining register mapping with bit definitions. 
  18      =2  This file is radio-chip dependent, and are included with the hal_nrf.h
  19      =2  
  20      =2  @ingroup hal_nrf24l01p_hal_nrf
  21      =2   */
  22      =2  
  23      =2  #ifndef HAL_NRF_REG_H__
  24      =2  #define HAL_NRF_REG_H__
  25      =2  
  26      =2  /** @name - Instruction Set - */
  27      =2  //@{
  28      =2  /* nRF24L01 Instruction Definitions */
  29      =2  #define W_REGISTER         0x20  /**< Register write command */
  30      =2  #define R_RX_PAYLOAD       0x61  /**< Read RX payload command */
  31      =2  #define W_TX_PAYLOAD       0xA0  /**< Write TX payload command */
  32      =2  #define FLUSH_TX           0xE1  /**< Flush TX register command */
  33      =2  #define FLUSH_RX           0xE2  /**< Flush RX register command */
  34      =2  #define REUSE_TX_PL        0xE3  /**< Reuse TX payload command */
  35      =2  #define ACTIVATE           0x50  /**< Activate features */
  36      =2  #define R_RX_PL_WID        0x60  /**< Read RX payload command */
  37      =2  #define W_ACK_PAYLOAD      0xA8  /**< Write ACK payload command */
  38      =2  #define W_TX_PAYLOAD_NOACK 0xB0  /**< Write ACK payload command */
  39      =2  #define NOP                0xFF  /**< No Operation command, used for reading status register */
  40      =2  //@}
  41      =2  
C51 COMPILER V9.03   HAL_NRF_HW                                                            06/20/2011 20:16:56 PAGE 5   

  42      =2  /** @name  - Register Memory Map - */
  43      =2  //@{
  44      =2  /* nRF24L01 * Register Definitions * */
  45      =2  #define CONFIG        0x00  /**< nRF24L01 config register */
  46      =2  #define EN_AA         0x01  /**< nRF24L01 enable Auto-Acknowledge register */
  47      =2  #define EN_RXADDR     0x02  /**< nRF24L01 enable RX addresses register */
  48      =2  #define SETUP_AW      0x03  /**< nRF24L01 setup of address width register */
  49      =2  #define SETUP_RETR    0x04  /**< nRF24L01 setup of automatic retransmission register */
  50      =2  #define RF_CH         0x05  /**< nRF24L01 RF channel register */
  51      =2  #define RF_SETUP      0x06  /**< nRF24L01 RF setup register */
  52      =2  #define STATUS        0x07  /**< nRF24L01 status register */
  53      =2  #define OBSERVE_TX    0x08  /**< nRF24L01 transmit observe register */
  54      =2  #define CD            0x09  /**< nRF24L01 carrier detect register */
  55      =2  #define RX_ADDR_P0    0x0A  /**< nRF24L01 receive address data pipe0 */
  56      =2  #define RX_ADDR_P1    0x0B  /**< nRF24L01 receive address data pipe1 */
  57      =2  #define RX_ADDR_P2    0x0C  /**< nRF24L01 receive address data pipe2 */
  58      =2  #define RX_ADDR_P3    0x0D  /**< nRF24L01 receive address data pipe3 */
  59      =2  #define RX_ADDR_P4    0x0E  /**< nRF24L01 receive address data pipe4 */
  60      =2  #define RX_ADDR_P5    0x0F  /**< nRF24L01 receive address data pipe5 */
  61      =2  #define TX_ADDR       0x10  /**< nRF24L01 transmit address */
  62      =2  #define RX_PW_P0      0x11  /**< nRF24L01 \# of bytes in rx payload for pipe0 */
  63      =2  #define RX_PW_P1      0x12  /**< nRF24L01 \# of bytes in rx payload for pipe1 */
  64      =2  #define RX_PW_P2      0x13  /**< nRF24L01 \# of bytes in rx payload for pipe2 */
  65      =2  #define RX_PW_P3      0x14  /**< nRF24L01 \# of bytes in rx payload for pipe3 */
  66      =2  #define RX_PW_P4      0x15  /**< nRF24L01 \# of bytes in rx payload for pipe4 */
  67      =2  #define RX_PW_P5      0x16  /**< nRF24L01 \# of bytes in rx payload for pipe5 */
  68      =2  #define FIFO_STATUS   0x17  /**< nRF24L01 FIFO status register */
  69      =2  #define DYNPD         0x1C  /**< nRF24L01 Dynamic payload setup */
  70      =2  #define FEATURE       0x1D  /**< nRF24L01 Exclusive feature setup */
  71      =2  
  72      =2  //@}
  73      =2  
  74      =2  /* nRF24L01 related definitions */
  75      =2  /* Interrupt definitions */
  76      =2  /* Operation mode definitions */
  77      =2  
  78      =2  /** An enum describing the radio's irq sources.
  79      =2   *
  80      =2   */
  81      =2  typedef enum {
  82      =2      HAL_NRF_MAX_RT = 4,     /**< Max retries interrupt */
  83      =2      HAL_NRF_TX_DS,          /**< TX data sent interrupt */
  84      =2      HAL_NRF_RX_DR           /**< RX data received interrupt */
  85      =2  } hal_nrf_irq_source_t;
  86      =2  
  87      =2  /* Operation mode definitions */
  88      =2  /** An enum describing the radio's power mode.
  89      =2   *
  90      =2   */
  91      =2  typedef enum {
  92      =2      HAL_NRF_PTX,            /**< Primary TX operation */
  93      =2      HAL_NRF_PRX             /**< Primary RX operation */
  94      =2  } hal_nrf_operation_mode_t;
  95      =2  
  96      =2  /** An enum describing the radio's power mode.
  97      =2   *
  98      =2   */
  99      =2  typedef enum {
 100      =2      HAL_NRF_PWR_DOWN,       /**< Device power-down */
 101      =2      HAL_NRF_PWR_UP          /**< Device power-up */
 102      =2  } hal_nrf_pwr_mode_t;
 103      =2  
C51 COMPILER V9.03   HAL_NRF_HW                                                            06/20/2011 20:16:56 PAGE 6   

 104      =2  /** An enum describing the radio's output power mode's.
 105      =2   *
 106      =2   */
 107      =2  typedef enum {
 108      =2      HAL_NRF_18DBM,          /**< Output power set to -18dBm */
 109      =2      HAL_NRF_12DBM,          /**< Output power set to -12dBm */
 110      =2      HAL_NRF_6DBM,           /**< Output power set to -6dBm  */
 111      =2      HAL_NRF_0DBM            /**< Output power set to 0dBm   */
 112      =2  } hal_nrf_output_power_t;
 113      =2  
 114      =2  /** An enum describing the radio's on-air datarate.
 115      =2   *
 116      =2   */
 117      =2  typedef enum {
 118      =2      HAL_NRF_1MBPS,          /**< Datarate set to 1 Mbps  */
 119      =2      HAL_NRF_2MBPS,          /**< Datarate set to 2 Mbps  */
 120      =2      HAL_NRF_250KBPS         /**< Datarate set to 250 kbps*/
 121      =2  } hal_nrf_datarate_t;
 122      =2  
 123      =2  /** An enum describing the radio's CRC mode.
 124      =2   *
 125      =2   */
 126      =2  typedef enum {
 127      =2      HAL_NRF_CRC_OFF,    /**< CRC check disabled */
 128      =2      HAL_NRF_CRC_8BIT,   /**< CRC check set to 8-bit */
 129      =2      HAL_NRF_CRC_16BIT   /**< CRC check set to 16-bit */
 130      =2  } hal_nrf_crc_mode_t;
 131      =2  
 132      =2  /** An enum describing the read/write payload command.
 133      =2   *
 134      =2   */
 135      =2  typedef enum {
 136      =2      HAL_NRF_TX_PLOAD = 7,   /**< TX payload definition */
 137      =2      HAL_NRF_RX_PLOAD,        /**< RX payload definition */
 138      =2      HAL_NRF_ACK_PLOAD
 139      =2  } hal_nrf_pload_command_t;
 140      =2  
 141      =2  /** Structure containing the radio's address map.
 142      =2   * Pipe0 contains 5 unique address bytes,
 143      =2   * while pipe[1..5] share the 4 MSB bytes, set in pipe1.
 144      =2   * <p><b> - Remember that the LSB byte for all pipes have to be unique! -</b>
 145      =2   */
 146      =2  // nRF24L01 Address struct
 147      =2  
 148      =2  
 149      =2  //typedef struct {
 150      =2  //   uint8_t p0[5];            /**< Pipe0 address, 5 bytes */
 151      =2  //    uint8_t p1[5];            /**< Pipe1 address, 5 bytes, 4 MSB bytes shared for pipe1 to pipe5 */
 152      =2  //    uint8_t p2[1];            /**< Pipe2 address, 1 byte */
 153      =2  //    uint8_t p3[1];            /**< Pipe3 address, 1 byte */
 154      =2  //   uint8_t p4[1];            /**< Pipe3 address, 1 byte */
 155      =2  //   uint8_t p5[1];            /**< Pipe3 address, 1 byte */
 156      =2  //   uint8_t tx[5];            /**< TX address, 5 byte */
 157      =2  //} hal_nrf_l01_addr_map;
 158      =2  
 159      =2  
 160      =2  /** An enum describing the nRF24L01 pipe addresses and TX address.
 161      =2   *
 162      =2   */
 163      =2  typedef enum {
 164      =2      HAL_NRF_PIPE0 = 0,          /**< Select pipe0 */
 165      =2      HAL_NRF_PIPE1,              /**< Select pipe1 */
C51 COMPILER V9.03   HAL_NRF_HW                                                            06/20/2011 20:16:56 PAGE 7   

 166      =2      HAL_NRF_PIPE2,              /**< Select pipe2 */
 167      =2      HAL_NRF_PIPE3,              /**< Select pipe3 */
 168      =2      HAL_NRF_PIPE4,              /**< Select pipe4 */
 169      =2      HAL_NRF_PIPE5,              /**< Select pipe5 */
 170      =2      HAL_NRF_TX,                 /**< Refer to TX address*/
 171      =2      HAL_NRF_ALL = 0xFF          /**< Close or open all pipes*/
 172      =2                                  /**< @see hal_nrf_set_address @see hal_nrf_get_address
 173      =2                                   @see hal_nrf_open_pipe  @see hal_nrf_close_pipe */
 174      =2  } hal_nrf_address_t;
 175      =2  
 176      =2  /** An enum describing the radio's address width.
 177      =2   *
 178      =2   */
 179      =2  typedef enum {
 180      =2      HAL_NRF_AW_3BYTES = 3,      /**< Set address width to 3 bytes */
 181      =2      HAL_NRF_AW_4BYTES,          /**< Set address width to 4 bytes */
 182      =2      HAL_NRF_AW_5BYTES           /**< Set address width to 5 bytes */
 183      =2  } hal_nrf_address_width_t;
 184      =2  
 185      =2  
 186      =2  /** @name CONFIG register bit definitions */
 187      =2  //@{
 188      =2  
 189      =2  #define MASK_RX_DR    6     /**< CONFIG register bit 6 */
 190      =2  #define MASK_TX_DS    5     /**< CONFIG register bit 5 */
 191      =2  #define MASK_MAX_RT   4     /**< CONFIG register bit 4 */
 192      =2  #define EN_CRC        3     /**< CONFIG register bit 3 */
 193      =2  #define CRCO          2     /**< CONFIG register bit 2 */
 194      =2  #define PWR_UP        1     /**< CONFIG register bit 1 */
 195      =2  #define PRIM_RX       0     /**< CONFIG register bit 0 */
 196      =2  //@}
 197      =2  
 198      =2  /** @name RF_SETUP register bit definitions */
 199      =2  //@{
 200      =2  #define PLL_LOCK      4     /**< RF_SETUP register bit 4 */
 201      =2  #define RF_DR         3     /**< RF_SETUP register bit 3 */
 202      =2  #define RF_PWR1       2     /**< RF_SETUP register bit 2 */
 203      =2  #define RF_PWR0       1     /**< RF_SETUP register bit 1 */
 204      =2  #define LNA_HCURR     0     /**< RF_SETUP register bit 0 */
 205      =2  //@}
 206      =2  
 207      =2  /* STATUS 0x07 */
 208      =2  /** @name STATUS register bit definitions */
 209      =2  //@{
 210      =2  #define RX_DR         6     /**< STATUS register bit 6 */
 211      =2  #define TX_DS         5     /**< STATUS register bit 5 */
 212      =2  #define MAX_RT        4     /**< STATUS register bit 4 */
 213      =2  #define TX_FULL       0     /**< STATUS register bit 0 */
 214      =2  //@}
 215      =2  
 216      =2  /* FIFO_STATUS 0x17 */
 217      =2  /** @name FIFO_STATUS register bit definitions */
 218      =2  //@{
 219      =2  #define TX_REUSE      6     /**< FIFO_STATUS register bit 6 */
 220      =2  #define TX_FIFO_FULL  5     /**< FIFO_STATUS register bit 5 */
 221      =2  #define TX_EMPTY      4     /**< FIFO_STATUS register bit 4 */
 222      =2  #define RX_FULL       1     /**< FIFO_STATUS register bit 1 */
 223      =2  #define RX_EMPTY      0     /**< FIFO_STATUS register bit 0 */
 224      =2  //@}
 225      =2  
 226      =2  #endif // HAL_NRF_REG_H__
 227      =2  /** @} */
C51 COMPILER V9.03   HAL_NRF_HW                                                            06/20/2011 20:16:56 PAGE 8   

  48      =1  #include "hal_nrf_hw.h"
   1      =2  /* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
   2      =2   *
   3      =2   * The information contained herein is confidential property of Nordic 
   4      =2   * Semiconductor ASA.Terms and conditions of usage are described in detail 
   5      =2   * in NORDIC SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =2   *
   7      =2   * Licensees are granted free, non-transferable use of the information. NO
   8      =2   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =2   * the file.
  10      =2   *              
  11      =2   * $LastChangedRevision: 133 $
  12      =2   */
  13      =2  
  14      =2  /** @file
  15      =2  * @brief hal_nrf macros for nRF24LU1+
  16      =2   *
  17      =2   * @defgroup hal_nrf24lu1p_hal_nrf_hw hal_nrf_hw
  18      =2   * @{
  19      =2   * @ingroup hal_nrf24lu1p
  20      =2   *
  21      =2   */
  22      =2  
  23      =2  #ifndef HAL_NRF_LU1_H__
  24      =2  #define HAL_NRF_LU1_H__
  25      =2  #include "nrf24lu1p.h"
   1      =3  #ifndef NRF24LU1P_H
   2      =3  #define NRF24LU1P_H
   3      =3  
   4      =3  #ifdef __ICC8051__
           =3 #include <ionRF24LU1p.h>
           =3 #include <bit24lu1.h>
           =3 #endif /*__ICC8051__*/
   8      =3  
   9      =3  #ifdef __C51__
  10      =3  #include <Nordic\reg24lu1.h>
   1      =4  /*--------------------------------------------------------------------------
   2      =4   * reg24lu1.h
   3      =4   *
   4      =4   * Keil C51 header file for the Nordic Semiconductor nRF24LU1 2.4GHz RF
   5      =4   * transceiver with embedded 8051 compatible microcontroller and USB.
   6      =4   *
   7      =4   *
   8      =4   *------------------------------------------------------------------------*/
   9      =4  #ifndef __REG24LU1_H__
  10      =4  #define __REG24LU1_H__
  11      =4  
  12      =4  //-----------------------------------------------------------------------------
  13      =4  // Byte Registers
  14      =4  //-----------------------------------------------------------------------------
  15      =4  
  16      =4  sfr   P0           = 0x80;
  17      =4  sfr   SP           = 0x81;
  18      =4  sfr   DPL          = 0x82;
  19      =4  sfr   DPH          = 0x83;
  20      =4  sfr   DPL1         = 0x84;
  21      =4  sfr   DPH1         = 0x85;
  22      =4  sfr   PCON         = 0x87;
  23      =4  sfr   TCON         = 0x88;
  24      =4  sfr   TMOD         = 0x89;
  25      =4  sfr   TL0          = 0x8A;
  26      =4  sfr   TL1          = 0x8B;
C51 COMPILER V9.03   HAL_NRF_HW                                                            06/20/2011 20:16:56 PAGE 9   

  27      =4  sfr   TH0          = 0x8C;
  28      =4  sfr   TH1          = 0x8D;
  29      =4  sfr   CKCON        = 0x8E;
  30      =4  sfr   RFCON        = 0x90;
  31      =4  sfr   DPS          = 0x92;
  32      =4  sfr   P0DIR        = 0x94;
  33      =4  sfr   P0ALT        = 0x95;
  34      =4  sfr   S0CON        = 0x98;
  35      =4  sfr   S0BUF        = 0x99;
  36      =4  sfr   IEN2         = 0x9A;
  37      =4  sfr   USBCON       = 0xA0;
  38      =4  sfr   CLKCTL       = 0xA3;
  39      =4  sfr   PWRDWN       = 0xA4;
  40      =4  sfr   WUCONF       = 0xA5;
  41      =4  sfr   INTEXP       = 0xA6;
  42      =4  sfr   IEN0         = 0xA8;
  43      =4  sfr   IP0          = 0xA9;
  44      =4  sfr   S0RELL       = 0xAA;
  45      =4  sfr   REGXH        = 0xAB;
  46      =4  sfr   REGXL        = 0xAC;
  47      =4  sfr   REGXC        = 0xAD;
  48      =4  sfr   RSTRES       = 0xB1;
  49      =4  sfr   SMDAT        = 0xB2;
  50      =4  sfr   SMCTL        = 0xB3;
  51      =4  sfr   TICKDV       = 0xB5;
  52      =4  sfr   IEN1         = 0xB8;
  53      =4  sfr   IP1          = 0xB9;
  54      =4  sfr   S0RELH       = 0xBA;
  55      =4  sfr   SSCONF       = 0xBC;
  56      =4  sfr   SSDATA       = 0xBD;
  57      =4  sfr   SSSTAT       = 0xBE;
  58      =4  sfr   IRCON        = 0xC0;
  59      =4  sfr   CCEN         = 0xC1;
  60      =4  sfr   CCL1         = 0xC2;
  61      =4  sfr   CCH1         = 0xC3;
  62      =4  sfr   CCL2         = 0xC4;
  63      =4  sfr   CCH2         = 0xC5;
  64      =4  sfr   CCL3         = 0xC6;
  65      =4  sfr   CCH3         = 0xC7;
  66      =4  sfr   T2CON        = 0xC8;
  67      =4  sfr   P0EXP        = 0xC9;
  68      =4  sfr   CRCL         = 0xCA;
  69      =4  sfr   CRCH         = 0xCB;
  70      =4  sfr   TL2          = 0xCC;
  71      =4  sfr   TH2          = 0xCD;
  72      =4  sfr   PSW          = 0xD0;
  73      =4  sfr   WDCON        = 0xD8;
  74      =4  sfr   USBSLP       = 0xD9;
  75      =4  sfr   ACC          = 0xE0;
  76      =4  sfr   RFDAT        = 0xE5;
  77      =4  sfr   RFCTL        = 0xE6;
  78      =4  sfr   AESCS        = 0xE8;
  79      =4  sfr   MD0          = 0xE9;
  80      =4  sfr   MD1          = 0xEA;
  81      =4  sfr   MD2          = 0xEB;
  82      =4  sfr   MD3          = 0xEC;
  83      =4  sfr   MD4          = 0xED;
  84      =4  sfr   MD5          = 0xEE;
  85      =4  sfr   ARCON        = 0xEF;
  86      =4  sfr   B            = 0xF0;
  87      =4  sfr   AESKIN       = 0xF1;
  88      =4  sfr   AESIV        = 0xF2;
C51 COMPILER V9.03   HAL_NRF_HW                                                            06/20/2011 20:16:56 PAGE 10  

  89      =4  sfr   AESD         = 0xF3;
  90      =4  sfr   AESIA1       = 0xF5;
  91      =4  sfr   AESIA2       = 0xF6;
  92      =4  sfr   FSR          = 0xF8;
  93      =4  sfr   FPCR         = 0xF9;
  94      =4  sfr   FCR          = 0xFA;
  95      =4  
  96      =4  //-----------------------------------------------------------------------------
  97      =4  // Word Registers
  98      =4  //-----------------------------------------------------------------------------
  99      =4  
 100      =4  sfr16 CC1          = 0xC2;
 101      =4  sfr16 CC2          = 0xC4;
 102      =4  sfr16 CC3          = 0xC6;
 103      =4  sfr16 CRC          = 0xCA;
 104      =4  sfr16 T2           = 0xCC;
 105      =4  
 106      =4  //-----------------------------------------------------------------------------
 107      =4  /* Lint uses a trick (see co-kc51.lnt) where sbit gets treated like (expanded to) a bool.
 108      =4     This causes errors due to the strong type checking of _Bool (and thereby bool) that
 109      =4     is turned on in our implementation of stdbool.h.
 110      =4     Therefore, we suppress Lint warning 18 ("Redeclaration") for the sbit-s declared in this file.
 111      =4  */
 112      =4  
 113      =4  /*lint -e18 */
 114      =4  //-----------------------------------------------------------------------------
 115      =4  
 116      =4  //-----------------------------------------------------------------------------
 117      =4  // Bit Definitions
 118      =4  //-----------------------------------------------------------------------------
 119      =4  
 120      =4  /*  FSR  */
 121      =4  sbit  MCDIS        = FSR^7;
 122      =4  sbit  STP          = FSR^6;
 123      =4  sbit  WEN          = FSR^5;
 124      =4  sbit  RDYN         = FSR^4;
 125      =4  sbit  INFEN        = FSR^3;
 126      =4  sbit  RDIS         = FSR^2;
 127      =4  sbit  RDEND        = FSR^1;
 128      =4  sbit  WPEN         = FSR^0;
 129      =4  
 130      =4  /*  PSW   */
 131      =4  sbit  CY           = PSW^7;
 132      =4  sbit  AC           = PSW^6;
 133      =4  sbit  F0           = PSW^5;
 134      =4  sbit  RS1          = PSW^4;
 135      =4  sbit  RS0          = PSW^3;
 136      =4  sbit  OV           = PSW^2;
 137      =4  sbit  F1           = PSW^1;
 138      =4  sbit  P            = PSW^0;
 139      =4  
 140      =4  /*  TCON  */
 141      =4  sbit  TF1          = TCON^7;
 142      =4  sbit  TR1          = TCON^6;
 143      =4  sbit  TF0          = TCON^5;
 144      =4  sbit  TR0          = TCON^4;
 145      =4  sbit  IE1          = TCON^3;
 146      =4  sbit  IT1          = TCON^2;
 147      =4  sbit  IE0          = TCON^1;
 148      =4  sbit  IT0          = TCON^0;
 149      =4  
 150      =4  /*  S0CON  */
C51 COMPILER V9.03   HAL_NRF_HW                                                            06/20/2011 20:16:56 PAGE 11  

 151      =4  sbit  SM0          = S0CON^7;
 152      =4  sbit  SM1          = S0CON^6;
 153      =4  sbit  SM20         = S0CON^5;
 154      =4  sbit  REN0         = S0CON^4;
 155      =4  sbit  TB80         = S0CON^3;
 156      =4  sbit  RB80         = S0CON^2;
 157      =4  sbit  TI0          = S0CON^1;
 158      =4  sbit  RI0          = S0CON^0;
 159      =4  
 160      =4  /*  T2CON  */
 161      =4  sbit  T2PS         = T2CON^7;
 162      =4  sbit  I3FR         = T2CON^6;
 163      =4  sbit  I2FR         = T2CON^5;
 164      =4  sbit  T2R1         = T2CON^4;
 165      =4  sbit  T2R0         = T2CON^3;
 166      =4  sbit  T2CM         = T2CON^2;
 167      =4  sbit  T2I1         = T2CON^1;
 168      =4  sbit  T2I0         = T2CON^0;
 169      =4  
 170      =4  /*  IEN0  */
 171      =4  sbit  EA           = IEN0^7;
 172      =4  
 173      =4  sbit  ET2          = IEN0^5;
 174      =4  sbit  ES0          = IEN0^4;
 175      =4  sbit  ET1          = IEN0^3;
 176      =4  sbit  EX1          = IEN0^2;
 177      =4  sbit  ET0          = IEN0^1;
 178      =4  sbit  EX0          = IEN0^0;
 179      =4  
 180      =4  /* IEN1  */
 181      =4  sbit  EXEN2        = IEN1^7;
 182      =4  
 183      =4  sbit  WUIRQ        = IEN1^5;
 184      =4  sbit  USB          = IEN1^4;
 185      =4  sbit  USBWU        = IEN1^3;
 186      =4  sbit  SPI          = IEN1^2;
 187      =4  sbit  RF           = IEN1^1;
 188      =4  sbit  RFSPI        = IEN1^0;
 189      =4  
 190      =4  /* IRCON */
 191      =4  sbit  EXF2         = IRCON^7;
 192      =4  sbit  TF2          = IRCON^6;
 193      =4  sbit  WUF          = IRCON^5;
 194      =4  sbit  USBF         = IRCON^4;
 195      =4  sbit  USBWUF       = IRCON^3;
 196      =4  sbit  SPIF         = IRCON^2;
 197      =4  sbit  RFF          = IRCON^1;
 198      =4  sbit  RFSPIF       = IRCON^0;
 199      =4  
 200      =4  /* USBCON */
 201      =4  sbit  SWRST        = USBCON^7;
 202      =4  sbit  WU           = USBCON^6;
 203      =4  sbit  SUSPEND      = USBCON^5;
 204      =4  sbit  IV4          = USBCON^4;
 205      =4  sbit  IV3          = USBCON^3;
 206      =4  sbit  IV2          = USBCON^2;
 207      =4  sbit  IV1          = USBCON^1;
 208      =4  sbit  IV0          = USBCON^0;
 209      =4  
 210      =4  /* PORT0 */
 211      =4  sbit  P00          = P0^0;
 212      =4  sbit  P01          = P0^1;
C51 COMPILER V9.03   HAL_NRF_HW                                                            06/20/2011 20:16:56 PAGE 12  

 213      =4  sbit  P02          = P0^2;
 214      =4  sbit  P03          = P0^3;
 215      =4  sbit  MCSN         = P0^3;
 216      =4  sbit  SCSN         = P0^3;
 217      =4  sbit  P04          = P0^4;
 218      =4  sbit  P05          = P0^5;
 219      =4  
 220      =4  /* RFCON */
 221      =4  sbit  RFCE         = RFCON^0;
 222      =4  sbit  RFCSN        = RFCON^1;
 223      =4  sbit  RFCKEN       = RFCON^2;
 224      =4  
 225      =4  /* WDCON */
 226      =4  sbit  BD           = WDCON^7;
 227      =4  
 228      =4  /* AESCS */
 229      =4  sbit  GO           = AESCS^0;
 230      =4  sbit  DECR         = AESCS^1;
 231      =4  
 232      =4  /*lint +e18 */  /* Re-enable Lint warning 18 */
 233      =4  
 234      =4  
 235      =4  /* REGX commands */
 236      =4  #define RWD         0x00
 237      =4  #define WWD         0x08
 238      =4  #define RGTIMER     0x01
 239      =4  #define WGTIMER     0x09
 240      =4  #define RRTCLAT     0x02
 241      =4  #define WRTCLAT     0x0A
 242      =4  #define RRTC        0x03
 243      =4  #define WRTCDIS     0x0B
 244      =4  #define RWSTA0      0x04
 245      =4  #define WWCON0      0x0C
 246      =4  #define RWSTA1      0x05
 247      =4  #define WWCON1      0x0D
 248      =4  
 249      =4  //-----------------------------------------------------------------------------
 250      =4  // Interrupt Vector Definitions
 251      =4  //-----------------------------------------------------------------------------
 252      =4  
 253      =4  #define INTERRUPT_EXT_INT0     0   // External Interrupt0 (P0.3)
 254      =4  #define INTERRUPT_T0           1   // Timer0 Overflow
 255      =4  #define INTERRUPT_AES_RDY      2   // AES ready interrupt
 256      =4  #define INTERRUPT_T1           3   // Timer1 Overflow
 257      =4  #define INTERRUPT_UART0        4   // UART0, Receive & Transmitt interrupt
 258      =4  #define INTERRUPT_T2           5   // Timer2 Overflow
 259      =4  #define INTERRUPT_RF_RDY       8   // RF SPI ready interrupt
 260      =4  #define INTERRUPT_RFIRQ        9   // RF interrupt
 261      =4  #define INTERRUPT_SPI          10  // SPI interrupt
 262      =4  #define INTERRUPT_USB_WU       11  // USB wakeup interrupt
 263      =4  #define INTERRUPT_USB_INT      12  // USB interrupt
 264      =4  #define INTERRUPT_WU           13  // Internal wakeup interrupt
 265      =4  
 266      =4  //-----------------------------------------------------------------------------
 267      =4  // Header File Preprocessor Directive
 268      =4  //-----------------------------------------------------------------------------
 269      =4  
 270      =4  #endif
  11      =3  #endif /*__C51__*/
  12      =3  
  13      =3  #include "isrdef24lu1p.h"
   1      =4  #ifdef __ICC8051__
C51 COMPILER V9.03   HAL_NRF_HW                                                            06/20/2011 20:16:56 PAGE 13  

           =4 
           =4 #define EXT_INT0_ISR() \
           =4 _Pragma("vector=0x0003") \
           =4 __interrupt void ext_int0_isr(void)
           =4 
           =4 #define T0_ISR() \
           =4 _Pragma("vector=0x000b") \
           =4 __interrupt void t0_isr(void)
           =4 
           =4 #define AES_RDY_ISR() \
           =4 _Pragma("vector=0x0013") \
           =4 __interrupt void aes_rdy_isr(void)
           =4 
           =4 #define T1_ISR() \
           =4 _Pragma("vector=0x001b") \
           =4 __interrupt void t1_isr(void)
           =4 
           =4 #define UART0_ISR() \
           =4 _Pragma("vector=0x0023") \
           =4 __interrupt void uart0_isr(void)
           =4 
           =4 #define T2_ISR() \
           =4 _Pragma("vector=0x002b") \
           =4 __interrupt void t2_isr(void)
           =4 
           =4 #define RF_RDY_ISR() \
           =4 _Pragma("vector=0x0043") \
           =4 __interrupt void rf_rdy_isr(void)
           =4 
           =4 #define NRF_ISR() \
           =4 _Pragma("vector=0x004b") \
           =4 __interrupt void nrf_isr(void)
           =4 
           =4 #define SPI_ISR() \
           =4 _Pragma("vector=0x0053") \
           =4 __interrupt void spi_isr(void)
           =4 
           =4 #define USB_WU_ISR() \
           =4 _Pragma("vector=0x005b") \
           =4 __interrupt void usb_wu_isr(void)
           =4 
           =4 #define USB_ISR() \
           =4 _Pragma("vector=0x0063") \
           =4 __interrupt void usb_isr(void)
           =4 
           =4 #define WU_ISR() \
           =4 _Pragma("vector=0x006b") \
           =4 __interrupt void wu_isr(void)
           =4 
           =4 #endif /*__ICC8051__*/
  52      =4  
  53      =4  #ifdef __C51__
  54      =4  
  55      =4  #define EXT_INT0_ISR()  void ext_int0_isr(void) interrupt INTERRUPT_EXT_INT0// External Interrupt0 (P0.3) 
             -(0x03)
  56      =4  #define T0_ISR()        void t0_isr(void)       interrupt INTERRUPT_T0      // Timer0 Overflow (0x0b)
  57      =4  #define AES_RDY_ISR()   void aes_rdy_isr(void)  interrupt INTERRUPT_AES_RDY // AES ready interrupt (0x13)
  58      =4  #define T1_ISR()        void t1_isr(void)       interrupt INTERRUPT_T1      // Timer1 Overflow (0x1b)
  59      =4  #define UART0_ISR()     void uart0_isr(void)    interrupt INTERRUPT_UART0   // UART0, Receive & Transmitt 
             -interrupt (0x0023)
  60      =4  #define T2_ISR()        void t2_isr(void)       interrupt INTERRUPT_T2      // Timer2 Overflow (0x2b)
  61      =4  #define RF_RDY_ISR()    void rf_rdy_isr(void)   interrupt INTERRUPT_RF_RDY  // RF SPI ready interrupt (0x4
C51 COMPILER V9.03   HAL_NRF_HW                                                            06/20/2011 20:16:56 PAGE 14  

             -3)
  62      =4  #define NRF_ISR()       void nrf_isr(void)      interrupt INTERRUPT_RFIRQ   // RF interrupt (0x4b)
  63      =4  #define SPI_ISR()       void spi_isr(void)      interrupt INTERRUPT_SPI     // SPI interrupt (0x53)
  64      =4  #define USB_WU_ISR()    void usb_wu_isr(void)   interrupt INTERRUPT_USB_WU  // USB wakeup interrupt (0x5b)
  65      =4  #define USB_ISR()       void usb_isr(void)      interrupt INTERRUPT_USB_INT // USB interrupt (0x63)
  66      =4  #define WU_ISR()        void wu_isr(void)       interrupt INTERRUPT_WU      // Internal wakeup interrupt (
             -0x6b)
  67      =4  
  68      =4  #endif /*__C51__*/
  69      =4  
  70      =4  
  71      =4  
  72      =4  
  14      =3  #include "memdefs.h"
   1      =4  #ifndef MEMDEFS_H_
   2      =4  #define MEMDEFS_H_
   3      =4  
   4      =4  #ifdef __C51__
   5      =4  #define __no_init 
   6      =4  #endif /*__C51__*/
   7      =4  
   8      =4  #ifdef __ICC8051__
           =4 
           =4 #define idata __idata
           =4 #define xdata __xdata
           =4 #define code __code
           =4 #define data __data
           =4 #define pdata __pdata
           =4 #define _at_ @
           =4 #define _nop_() __no_operation()
           =4 #define bit __bit
           =4 __sfr __no_init volatile unsigned int CRC @ 0xCA;
           =4 __sfr __no_init volatile unsigned int T2  @ 0xCC;
           =4 
           =4 #define reentrant 
           =4 #if __DATA_MODEL__ == __DATA_MODEL_LARGE__
           =4   #warning "if not using large data model: reentrant procedures must be declared using IAR syntax"
           =4 #endif /*__DATA_MODEL__ == __DATA_MODEL_LARGE__*/
           =4 
           =4 #define CLKCTRL CLKFCTL
           =4 
           =4 #ifndef NULL
           =4 #define NULL _NULL
           =4 #endif /*NULL*/
           =4 
           =4 #endif /*__ICC8051__*/
  33      =4  
  34      =4  #endif /*MEMDEFS_H_*/
  15      =3  
  16      =3  #endif
  26      =2  
  27      =2  /** Macro that set radio's CSN line LOW.
  28      =2   *
  29      =2   */
  30      =2  #define CSN_LOW() do { RFCSN = 0; } while(false)
  31      =2  
  32      =2  /** Macro that set radio's CSN line HIGH.
  33      =2   *
  34      =2   */
  35      =2  #define CSN_HIGH() do { RFCSN = 1; } while(false)
  36      =2  
  37      =2  /** Macro that set radio's CE line LOW.
C51 COMPILER V9.03   HAL_NRF_HW                                                            06/20/2011 20:16:56 PAGE 15  

  38      =2   *
  39      =2   */
  40      =2  #define CE_LOW() do { RFCE = 0; } while(false)
  41      =2  
  42      =2  /** Macro that set radio's CE line HIGH.
  43      =2   *
  44      =2   */
  45      =2  #define CE_HIGH() do { RFCE = 1; } while(false)
  46      =2  
  47      =2  /** Macro for writing the radio SPI data register.
  48      =2   *
  49      =2   */
  50      =2  #define HAL_NRF_HW_SPI_WRITE(d) do{RFDAT = d; RFSPIF = 0;} while(false)
  51      =2  
  52      =2  /** Macro for reading the radio SPI data register.
  53      =2   *
  54      =2   */
  55      =2  #define HAL_NRF_HW_SPI_READ() RFDAT
  56      =2    
  57      =2  /** Macro specifyng the radio SPI busy flag.
  58      =2   *
  59      =2   */
  60      =2  #define HAL_NRF_HW_SPI_BUSY (!RFSPIF)
  61      =2  
  62      =2  /**
  63      =2   * Pulses the CE to nRF24L01 for at least 10 us
  64      =2   */
  65      =2  #define CE_PULSE() do { \
  66      =2    uint8_t count; \
  67      =2    count = 20; \
  68      =2    CE_HIGH();  \
  69      =2    while(count--){} \
  70      =2    CE_LOW();  \
  71      =2    } while(false)
  72      =2  
  73      =2  #endif // HAL_NRF_LU1_H__
  74      =2  
  75      =2  /** @} */
  49      =1  
  50      =1  /** @name Setup */
  51      =1  //@{
  52      =1  /* Setup function prototypes */
  53      =1  
  54      =1  /** Enable or disable interrupt for radio.
  55      =1   * Use this function to enable or disable
  56      =1   * one of the interrupt sources for the radio.
  57      =1   * This function only changes state for selected
  58      =1   * int_type, the rest of the interrupt sources
  59      =1   * are left unchanged.
  60      =1   *
  61      =1   * @param int_source Radio interrupt Source.
  62      =1   * @param irq_state Enable or Disable.
  63      =1  */
  64      =1  void hal_nrf_set_irq_mode(hal_nrf_irq_source_t int_source, bool irq_state);
  65      =1  
  66      =1  /* For the obsolete nRF24L01 it is necessary to issue an activate command before the
  67      =1   * features enabled by the FEATURE register can be used. For nRF24L01+ these features
  68      =1   * are by default enabled.
  69      =1  */
  70      =1  void hal_nrf_activate_features(void);
  71      =1  
  72      =1  /** Enables the dynamic packet length
C51 COMPILER V9.03   HAL_NRF_HW                                                            06/20/2011 20:16:56 PAGE 16  

  73      =1   * @param enable Whether enable or disable dynamic packet length
  74      =1   */
  75      =1  void hal_nrf_enable_dynamic_payload(bool enable);
  76      =1  
  77      =1  /** Enables the ACK payload feature
  78      =1   * @param enable Whether to enable or disable ACK payload
  79      =1   */
  80      =1  void hal_nrf_enable_ack_payload(bool enable);
  81      =1  
  82      =1  /** Enables the dynamic ack feature
  83      =1   * @param enable Whether to enable or disable Dynamic ACK
  84      =1   */
  85      =1  void hal_nrf_enable_dynamic_ack(bool enable);
  86      =1  
  87      =1  /** Function for enabling dynmic payload size.
  88      =1   * The input parameter contains is a byte where the bit values tells weather the
  89      =1   * pipe should use dynamic payload size. For example if bit 0 is set then 
  90      =1   * pipe 0 will accept dynamic payload size.
  91      =1   * @param setup Byte value telling for which pips(s) to enable dynamic payload size
  92      =1   */
  93      =1  void hal_nrf_setup_dynamic_payload(uint8_t setup);
  94      =1  
  95      =1  /** Reads the payload width of the received ack payload
  96      =1   * @return Payload width of the received ack payload
  97      =1   */
  98      =1  uint8_t hal_nrf_read_rx_payload_width(void);
  99      =1  
 100      =1  /** Write ack payload
 101      =1   * Writes the payload that will be transmitted with the ack on the given pipe.
 102      =1   * @param pipe Pipe that transmits the payload
 103      =1   * @param tx_pload Pointer to the payload data
 104      =1   * @param length Size of the data to transmit
 105      =1   */
 106      =1  void hal_nrf_write_ack_payload(uint8_t pipe, const uint8_t *tx_pload, uint8_t length);
 107      =1  
 108      =1  /** Read then clears all interrupt flags.
 109      =1   * Use this function to get the interrupt flags and clear them in the same operation.
 110      =1   * Reduced radio interface activity and speed optimized.
 111      =1   *
 112      =1   * @return  Interrupt_flags
 113      =1   * @retval 0x10 Max Retransmit interrupt
 114      =1   * @retval 0x20 TX Data sent interrupt
 115      =1   * @retval 0x40 RX Data received interrupt
 116      =1  */
 117      =1  uint8_t hal_nrf_get_clear_irq_flags(void);
 118      =1  
 119      =1  uint8_t hal_nrf_clear_irq_flags_get_status(void);
 120      =1  
 121      =1  /** Clear one selected interrupt flag.
 122      =1   * Use this function to clear one @a spesific interrupt flag.
 123      =1   * Other interrupt flags are left unchanged.
 124      =1   *
 125      =1   * @param int_source Interrupt source of which flag to clear
 126      =1  */
 127      =1  void hal_nrf_clear_irq_flag(hal_nrf_irq_source_t int_source);
 128      =1  
 129      =1  /** Set the CRC mode used by the radio.
 130      =1   * Use this function to set the CRC mode; CRC disabled, 1 or 2 bytes.
 131      =1   *
 132      =1   * @param crc_mode CRC mode to use
 133      =1  */
 134      =1  void hal_nrf_set_crc_mode(hal_nrf_crc_mode_t crc_mode);
C51 COMPILER V9.03   HAL_NRF_HW                                                            06/20/2011 20:16:56 PAGE 17  

 135      =1  
 136      =1  /** Open radio pipe(s) and enable/ disable auto acknowledge.
 137      =1   * Use this function to open one or all pipes,
 138      =1   * with or without auto acknowledge.
 139      =1   *
 140      =1   * @param pipe_num Radio pipe to open
 141      =1   * @param auto_ack Auto_Ack ON/OFF
 142      =1   * @see hal_nrf_address
 143      =1  */
 144      =1  void hal_nrf_open_pipe(hal_nrf_address_t pipe_num, bool auto_ack);
 145      =1  
 146      =1  /** Close radio pipe(s).
 147      =1   * Use this function to close one pipe or all pipes.
 148      =1   *
 149      =1   * @param pipe_num Pipe# number to close
 150      =1  */
 151      =1  void hal_nrf_close_pipe(hal_nrf_address_t pipe_num);
 152      =1  
 153      =1  /** Set radio's RX address and TX address.
 154      =1   * Use this function to set a RX address, or to set the TX address.
 155      =1   * Beware of the difference for single and multibyte address registers.
 156      =1   *
 157      =1   * @param address Which address to set
 158      =1   * @param *addr Buffer from which the address is stored in
 159      =1  */
 160      =1  void hal_nrf_set_address(const hal_nrf_address_t address, const uint8_t *addr);
 161      =1  
 162      =1  /** Get address for selected pipe.
 163      =1   * Use this function to get address for selected pipe.
 164      =1   *
 165      =1   *
 166      =1   * @param address Which address to get, Pipe- or TX-address
 167      =1   * @param *addr buffer in which address bytes are written.
 168      =1   * <BR><BR>For pipes containing only LSB byte of address, this byte is returned
 169      =1   * in the<BR> *addr buffer.
 170      =1   *
 171      =1   * @return Numbers of bytes copied to addr
 172      =1  */
 173      =1  uint8_t hal_nrf_get_address (uint8_t address, uint8_t *addr);
 174      =1  
 175      =1  /** Set auto acknowledge parameters.
 176      =1   * Use this function to set retransmit and retransmit delay
 177      =1   * parameters.
 178      =1   *
 179      =1   * @param retr Number of retransmit, 0 equ retransmit OFF
 180      =1   * @param delay Retransmit delay in s. Must be a 
 181      =1  */
 182      =1  void hal_nrf_set_auto_retr(uint8_t retr, uint16_t delay);
 183      =1  
 184      =1  /** Set radio's address width.
 185      =1   * Use this function to define the radio's address width,
 186      =1   * referes to both RX and TX.
 187      =1   *
 188      =1   * @param address_width Address with in bytes
 189      =1  */
 190      =1  void hal_nrf_set_address_width(hal_nrf_address_width_t address_width);
 191      =1  
 192      =1  /** Gets the radio's address width.
 193      =1   *
 194      =1   * @return Address width
 195      =1   */
 196      =1  uint8_t hal_nrf_get_address_width (void);
C51 COMPILER V9.03   HAL_NRF_HW                                                            06/20/2011 20:16:56 PAGE 18  

 197      =1  
 198      =1  /** Set payload width for selected pipe.
 199      =1   * Use this function to set the number of bytes expected
 200      =1   * on a selected pipe.
 201      =1   *
 202      =1   * @param pipe_num Pipe number to set payload width for
 203      =1   * @param pload_width number of bytes expected
 204      =1  */
 205      =1  void hal_nrf_set_rx_payload_width(uint8_t pipe_num, uint8_t pload_width);
 206      =1  
 207      =1  /** Read current interrupt mode for selected interrupt source.
 208      =1   * Use this function to get the interrupt source's mode,
 209      =1   * either enabled or disabled.
 210      =1   *
 211      =1   * @param int_source Interrupt source to get mode from
 212      =1   *
 213      =1   * @return Interrupt Mode
 214      =1   * @retval FALSE Interrupt disabled
 215      =1   * @retval TRUE Interrupt enabled
 216      =1  */
 217      =1  bool hal_nrf_get_irq_mode(uint8_t int_source);
 218      =1  
 219      =1  /** Read all interrupt flags.
 220      =1   * Use this function to get the interrupt flags. This function is similar
 221      =1   * to hal_nrf_get_clear_irq_flags with the exception that it does <I><B>NOT</B></I> clear
 222      =1   * the irq_flags.
 223      =1   *
 224      =1   * @return Interrupt_flags
 225      =1   * @retval 0x10 Max Retransmit interrupt
 226      =1   * @retval 0x20 TX Data sent interrupt
 227      =1   * @retval 0x40 RX Data received interrupt
 228      =1  */
 229      =1  uint8_t hal_nrf_get_irq_flags(void);
 230      =1  
 231      =1  /** Get pipe status.
 232      =1   * Use this function to check status for a selected pipe.
 233      =1   *
 234      =1   * @param  pipe_num Pipe number to check status for
 235      =1   *
 236      =1   * @return Pipe_Status
 237      =1   * @retval 0x00 Pipe is closed, autoack disabled
 238      =1   * @retval 0x01 Pipe is open, autoack disabled
 239      =1   * @retval 0x03 Pipe is open, autoack enabled
 240      =1  */
 241      =1  uint8_t hal_nrf_get_pipe_status(uint8_t pipe_num);
 242      =1  
 243      =1  /** Get auto retransmit parameters.
 244      =1   * Use this function to get the auto retransmit parameters,
 245      =1   * retrans count and retrans delay.
 246      =1   *
 247      =1   * @return AutoRetrans Parameters
 248      =1   *
 249      =1   * @retval UpperNibble Retransmit Delay
 250      =1   * @retval LowerNibble Retransmit Count
 251      =1  */
 252      =1  uint8_t hal_nrf_get_auto_retr_status(void);
 253      =1  
 254      =1  /** Get packet lost counter
 255      =1   * Use this function to get the packet(s) counter.
 256      =1   *
 257      =1   * @return packet lost counter
 258      =1  */
C51 COMPILER V9.03   HAL_NRF_HW                                                            06/20/2011 20:16:56 PAGE 19  

 259      =1  uint8_t hal_nrf_get_packet_lost_ctr(void);
 260      =1  
 261      =1  /** Get RX payload width for selected pipe.
 262      =1   * Use this function to get the expected payload
 263      =1   * width for selected ppe number.
 264      =1   *
 265      =1   * @param pipe_num Pipe number to get payload width for
 266      =1   *
 267      =1   * @return Payload_Width in bytes
 268      =1  */
 269      =1  uint8_t hal_nrf_get_rx_payload_width(uint8_t pipe_num);
 270      =1  //@}
 271      =1  
 272      =1  /** @name Operation */
 273      =1  //@{
 274      =1  /* Operation function prototypes */
 275      =1  
 276      =1  /** Set radio's operation mode.
 277      =1   * Use this function to enter PTX (primary TX)
 278      =1   * or PRX (primary RX).
 279      =1   *
 280      =1   * @param op_mode Operation mode
 281      =1  */
 282      =1  void hal_nrf_set_operation_mode(hal_nrf_operation_mode_t op_mode);
 283      =1  
 284      =1  /** Set radio's power mode.
 285      =1   * Use this function to power_up or power_down radio.
 286      =1   *
 287      =1   * @param pwr_mode POWER_UP or POWER_DOWN
 288      =1  */
 289      =1  void hal_nrf_set_power_mode(hal_nrf_pwr_mode_t pwr_mode);
 290      =1  
 291      =1  /** Set radio's RF channel.
 292      =1   * Use this function to select which RF channel to use.
 293      =1   *
 294      =1   * @param channel RF channel
 295      =1  */
 296      =1  void hal_nrf_set_rf_channel(uint8_t channel);
 297      =1  
 298      =1  /** Set radio's TX output power.
 299      =1   * Use this function set the radio's TX output power.
 300      =1   *
 301      =1   * @param power Radio's TX output power
 302      =1  */
 303      =1  void hal_nrf_set_output_power(hal_nrf_output_power_t power);
 304      =1  
 305      =1  /** Set radio's on-air datarate.
 306      =1   * Use this function to select radio's on-air
 307      =1   * datarate.
 308      =1   *
 309      =1   * @param datarate On-air datarate
 310      =1  */
 311      =1  void hal_nrf_set_datarate(hal_nrf_datarate_t datarate);
 312      =1  
 313      =1  
 314      =1  /* Status functions prototypes */
 315      =1  
 316      =1  /** Get radio's TX FIFO status.
 317      =1   * Use this function to get the radio's TX
 318      =1   * FIFO status.
 319      =1   *
 320      =1   * @return TX FIFO status
C51 COMPILER V9.03   HAL_NRF_HW                                                            06/20/2011 20:16:56 PAGE 20  

 321      =1   * @retval 0x00 TX FIFO NOT empty, but NOT full
 322      =1   * @retval 0x01 FIFO empty
 323      =1   * @retval 0x02 FIFO full
 324      =1   *
 325      =1  */
 326      =1  uint8_t hal_nrf_get_tx_fifo_status(void);
 327      =1  
 328      =1  /** Check for TX FIFO empty.
 329      =1   * Use this function to check if TX FIFO
 330      =1   * is empty.
 331      =1   *
 332      =1   * @return TX FIFO empty bit
 333      =1   * @retval FALSE TX FIFO NOT empty
 334      =1   * @retval TRUE TX FIFO empty
 335      =1   *
 336      =1  */
 337      =1  bool hal_nrf_tx_fifo_empty(void);
 338      =1  
 339      =1  /** Check for TX FIFO full.
 340      =1   * Use this function to check if TX FIFO
 341      =1   * is full.
 342      =1   *
 343      =1   * @return TX FIFO full bit
 344      =1   * @retval FALSE TX FIFO NOT full
 345      =1   * @retval TRUE TX FIFO full
 346      =1   *
 347      =1  */
 348      =1  bool hal_nrf_tx_fifo_full(void);
 349      =1  
 350      =1  /** Get radio's RX FIFO status.
 351      =1   * Use this function to get the radio's TX
 352      =1   * FIFO status.
 353      =1   *
 354      =1   * @return RX FIFO status
 355      =1   * @retval 0x00 RX FIFO NOT empty, but NOT full
 356      =1   * @retval 0x01 RX FIFO empty
 357      =1   * @retval 0x02 RX FIFO full
 358      =1   *
 359      =1  */
 360      =1  uint8_t hal_nrf_get_rx_fifo_status(void);
 361      =1  
 362      =1  /** Check for RX FIFO empty.
 363      =1   * Use this function to check if RX FIFO
 364      =1   * is empty.
 365      =1   *
 366      =1   * Reads STATUS register to check this, not FIFO_STATUS  
 367      =1   *
 368      =1   * @return RX FIFO empty bit
 369      =1   * @retval FALSE RX FIFO NOT empty
 370      =1   * @retval TRUE RX FIFO empty
 371      =1   *
 372      =1  */
 373      =1  bool hal_nrf_rx_fifo_empty(void);
 374      =1  
 375      =1  /** Check for RX FIFO full.
 376      =1   * Use this function to check if RX FIFO
 377      =1   * is full.
 378      =1   *
 379      =1   * @return RX FIFO full bit
 380      =1   * @retval FALSE RX FIFO NOT full
 381      =1   * @retval TRUE RX FIFO full
 382      =1   *
C51 COMPILER V9.03   HAL_NRF_HW                                                            06/20/2011 20:16:56 PAGE 21  

 383      =1  */
 384      =1  bool hal_nrf_rx_fifo_full(void);
 385      =1  
 386      =1  /** Get radio's transmit attempts status.
 387      =1   * Use this function to get number of retransmit
 388      =1   * attempts and number of packet lost.
 389      =1   *
 390      =1   * @return Retransmit attempts counters
 391      =1  */
 392      =1  uint8_t hal_nrf_get_transmit_attempts(void);
 393      =1  
 394      =1  /** Get the carrier detect flag.
 395      =1   * Use this function to get the carrier detect flag,
 396      =1   * used to detect stationary disturbance on selected
 397      =1   * RF channel.
 398      =1   *
 399      =1   * @return Carrier Detect
 400      =1   * @retval FALSE Carrier NOT Detected
 401      =1   * @retval TRUE Carrier Detected
 402      =1  */
 403      =1  bool hal_nrf_get_carrier_detect(void);
 404      =1  
 405      =1  /* Data operation prototypes */
 406      =1  
 407      =1  /** Get RX data source.
 408      =1   * Use this function to read which RX pipe data
 409      =1   * was received on for current top level FIFO data packet.
 410      =1   *
 411      =1   * @return pipe number of current packet present
 412      =1  */
 413      =1  uint8_t hal_nrf_get_rx_data_source(void);
 414      =1  
 415      =1  /** Read RX payload.
 416      =1   * Use this function to read top level payload
 417      =1   * available in the RX FIFO.
 418      =1   *
 419      =1   * @param  *rx_pload pointer to buffer in which RX payload are stored
 420      =1   * @return pipe number (MSB byte) and packet length (LSB byte)
 421      =1  */
 422      =1  uint16_t hal_nrf_read_rx_payload(uint8_t *rx_pload);
 423      =1  
 424      =1  /** Write TX payload to radio.
 425      =1   * Use this function to write a packet of
 426      =1   * TX payload into the radio.
 427      =1   * <I>length</I> number of bytes, which are stored in <I>*tx_pload</I>.
 428      =1   *
 429      =1   * @param *tx_pload pointer to buffer in which TX payload are present
 430      =1   * @param length number of bytes to write
 431      =1  */
 432      =1  void hal_nrf_write_tx_payload(const uint8_t *tx_pload, uint8_t length);
 433      =1  
 434      =1  /** Write TX payload which do not require ACK. When transmitting 
 435      =1   * a ACK is not required nor sent from the receiver. The payload will
 436      =1   * always be assumed as "sent".
 437      =1   *
 438      =1   * Use this function to write a packet of
 439      =1   * TX payload into the radio.
 440      =1   * <I>length</I> number of bytes, which are stored in <I>*tx_pload</I>.
 441      =1   *
 442      =1   * @param *tx_pload pointer to buffer in which TX payload are present
 443      =1   * @param length number of bytes to write
 444      =1  */
C51 COMPILER V9.03   HAL_NRF_HW                                                            06/20/2011 20:16:56 PAGE 22  

 445      =1  void hal_nrf_write_tx_payload_noack(const uint8_t *tx_pload, uint8_t length);
 446      =1  
 447      =1  /** Reuse TX payload.
 448      =1   * Use this function to set that the radio is using
 449      =1   * the last transmitted payload for the next packet as well.
 450      =1   *
 451      =1  */
 452      =1  void hal_nrf_reuse_tx(void);
 453      =1  
 454      =1  /** Get status of reuse TX function.
 455      =1   * Use this function to check if reuse TX payload is
 456      =1   * activated
 457      =1   *
 458      =1   * @return Reuse TX payload mode
 459      =1   * @retval FALSE Not activated
 460      =1   * @retval TRUE Activated
 461      =1  */
 462      =1  bool hal_nrf_get_reuse_tx_status(void);
 463      =1  
 464      =1  /** Flush RX FIFO.
 465      =1   * Use this function to flush the radio's
 466      =1   * RX FIFO.
 467      =1   *
 468      =1  */
 469      =1  void hal_nrf_flush_rx(void);
 470      =1  
 471      =1  /** Flush TX FIFO.
 472      =1   * Use this function to flush the radio's
 473      =1   * TX FIFO.
 474      =1   *
 475      =1  */
 476      =1  void hal_nrf_flush_tx(void);
 477      =1  
 478      =1  /** No Operation command.
 479      =1   * Use this function to receive the radio's
 480      =1   * status register.
 481      =1   *
 482      =1   * @return Status register
 483      =1  */
 484      =1  uint8_t hal_nrf_nop(void);
 485      =1  //@}
 486      =1  
 487      =1  /** @name  Test */
 488      =1  //@{
 489      =1  /* Test functions prototypes */
 490      =1  
 491      =1  /** Set radio's PLL mode.
 492      =1   * Use this function to either LOCK
 493      =1   * or UNLOCK the radio's PLL.
 494      =1   *
 495      =1   * @param pll_lock PLL locked, TRUE or FALSE
 496      =1  */
 497      =1  void hal_nrf_set_pll_mode(bool pll_lock);
 498      =1  
 499      =1  /** Set radio's LNA gain mode.
 500      =1   * Use this function to either use HI
 501      =1   * current or LOW current mode for the radio.
 502      =1   *
 503      =1   * @param lna_gain LNA gain mode
 504      =1  */
 505      =1  void hal_nrf_set_lna_gain(bool lna_gain);
 506      =1  
C51 COMPILER V9.03   HAL_NRF_HW                                                            06/20/2011 20:16:56 PAGE 23  

 507      =1  /** Enables continuous carrier transmit.
 508      =1   * Use this function to enable or disable
 509      =1   * continuous carrier transmission.
 510      =1   * @param enable Enable continuous carrier
 511      =1   */
 512      =1  void hal_nrf_enable_continious_wave (bool enable);
 513      =1  
 514      =1  /* hal_nrf_l01 basic functions, used by all the other functions */
 515      =1  
 516      =1  //@}
 517      =1  
 518      =1  /** @name SPI interface */
 519      =1  //@{
 520      =1  
 521      =1  /** Basis function, nrf_rw
 522      =1   * This function is used by the basis functions
 523      =1   * to exchange data with the data.
 524      =1   *
 525      =1   * @param value Databyte to write
 526      =1   *
 527      =1   * @return Databyte from radio.
 528      =1  */
 529      =1  uint8_t hal_nrf_rw(uint8_t value);
 530      =1  //@}
 531      =1  #endif // HAL_NRF_H__
 532      =1  /** @} */
 533      =1  
  23          #include "nrf24lu1p.h"
   1      =1  #ifndef NRF24LU1P_H
           =1 #define NRF24LU1P_H
           =1 
           =1 #ifdef __ICC8051__
           =1 #include <ionRF24LU1p.h>
           =1 #include <bit24lu1.h>
           =1 #endif /*__ICC8051__*/
           =1 
           =1 #ifdef __C51__
           =1 #include <Nordic\reg24lu1.h>
           =1 #endif /*__C51__*/
           =1 
           =1 #include "isrdef24lu1p.h"
           =1 #include "memdefs.h"
           =1 
           =1 #endif
  24          
  25          uint8_t hal_nrf_rw(uint8_t value)
  26          {
  27   1        RFDAT = value;
  28   1        RFSPIF = 0;     // ! IMPORTANT ! Clear RF SPI ready flag
  29   1                        // after data written to RFDAT..
  30   1        while(!RFSPIF) {}; // wait for byte transfer finished
  31   1        return RFDAT;   // return SPI read value
  32   1      }
  33          
  34          
C51 COMPILER V9.03   HAL_NRF_HW                                                            06/20/2011 20:16:56 PAGE 24  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION _hal_nrf_rw (BEGIN)
                                           ; SOURCE LINE # 25
;---- Variable 'value' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 26
                                           ; SOURCE LINE # 27
0000 8FE5              MOV     RFDAT,R7
                                           ; SOURCE LINE # 28
0002 C2C0              CLR     RFSPIF
0004         ?C0001:
                                           ; SOURCE LINE # 30
0004 30C0FD            JNB     RFSPIF,?C0001
0007         ?C0002:
                                           ; SOURCE LINE # 31
0007 AFE5              MOV     R7,RFDAT
                                           ; SOURCE LINE # 32
0009         ?C0003:
0009 22                RET     
             ; FUNCTION _hal_nrf_rw (END)

C51 COMPILER V9.03   HAL_NRF_HW                                                            06/20/2011 20:16:56 PAGE 25  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


hal_nrf_address_t. . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
HAL_NRF_CRC_16BIT. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
uint16_t . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
P0 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0080H  1
HAL_NRF_0DBM . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
hal_nrf_address_width_t. . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
int32_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  LONG     -----  4
HAL_NRF_6DBM . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
int16_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  INT      -----  2
IEN0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A8H  1
IEN1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B8H  1
HAL_NRF_PWR_DOWN . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
HAL_NRF_CRC_OFF. . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
HAL_NRF_RX_DR. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
HAL_NRF_ACK_PLOAD. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
HAL_NRF_TX_DS. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_hal_nrf_rw. . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  value. . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
HAL_NRF_TX . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
HAL_NRF_AW_3BYTES. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
HAL_NRF_AW_4BYTES. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
TCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0088H  1
HAL_NRF_AW_5BYTES. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
HAL_NRF_12DBM. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
HAL_NRF_18DBM. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
HAL_NRF_250KBPS. . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
RFSPIF . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C0H  1
USBCON . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A0H  1
HAL_NRF_CRC_8BIT . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
uint8_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
hal_nrf_crc_mode_t . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
HAL_NRF_ALL. . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
hal_nrf_irq_source_t . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
int8_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  CHAR     -----  1
hal_nrf_output_power_t . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
HAL_NRF_PIPE0. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
HAL_NRF_PIPE1. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
HAL_NRF_PIPE2. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
hal_nrf_datarate_t . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
HAL_NRF_PIPE3. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
HAL_NRF_PIPE4. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
HAL_NRF_PIPE5. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
HAL_NRF_1MBPS. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
HAL_NRF_2MBPS. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
S0CON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0098H  1
T2CON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C8H  1
FSR. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F8H  1
hal_nrf_pload_command_t. . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
HAL_NRF_MAX_RT . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_Bool. . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
AESCS. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E8H  1
RFDAT. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E5H  1
hal_nrf_operation_mode_t . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
hal_nrf_pwr_mode_t . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
HAL_NRF_PRX. . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
RFCON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0090H  1
PSW. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D0H  1
C51 COMPILER V9.03   HAL_NRF_HW                                                            06/20/2011 20:16:56 PAGE 26  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


HAL_NRF_RX_PLOAD . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
HAL_NRF_PTX. . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
WDCON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D8H  1
IRCON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C0H  1
HAL_NRF_TX_PLOAD . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
uint32_t . . . . . . . . . . . . . . .  TYPEDEF  -----  U_LONG   -----  4
HAL_NRF_PWR_UP . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =     10    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
