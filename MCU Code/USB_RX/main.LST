C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 1   


C51 COMPILER V9.03, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c LARGE BROWSE INCDIR(.;..\compiler\c51;..\hal\nrf24lu1p;..\hal\nrf24l
                    -01p;..\hal;..\compiler\common) DEFINE(MCU_NRF24LU1P) DEBUG OBJECTEXTEND CODE LISTINCLUDE SYMBOLS PREPRINT

line level    source

   1          #include <Nordic\reg24lu1.h>
   1      =1  /*--------------------------------------------------------------------------
   2      =1   * reg24lu1.h
   3      =1   *
   4      =1   * Keil C51 header file for the Nordic Semiconductor nRF24LU1 2.4GHz RF
   5      =1   * transceiver with embedded 8051 compatible microcontroller and USB.
   6      =1   *
   7      =1   *
   8      =1   *------------------------------------------------------------------------*/
   9      =1  #ifndef __REG24LU1_H__
  10      =1  #define __REG24LU1_H__
  11      =1  
  12      =1  //-----------------------------------------------------------------------------
  13      =1  // Byte Registers
  14      =1  //-----------------------------------------------------------------------------
  15      =1  
  16      =1  sfr   P0           = 0x80;
  17      =1  sfr   SP           = 0x81;
  18      =1  sfr   DPL          = 0x82;
  19      =1  sfr   DPH          = 0x83;
  20      =1  sfr   DPL1         = 0x84;
  21      =1  sfr   DPH1         = 0x85;
  22      =1  sfr   PCON         = 0x87;
  23      =1  sfr   TCON         = 0x88;
  24      =1  sfr   TMOD         = 0x89;
  25      =1  sfr   TL0          = 0x8A;
  26      =1  sfr   TL1          = 0x8B;
  27      =1  sfr   TH0          = 0x8C;
  28      =1  sfr   TH1          = 0x8D;
  29      =1  sfr   CKCON        = 0x8E;
  30      =1  sfr   RFCON        = 0x90;
  31      =1  sfr   DPS          = 0x92;
  32      =1  sfr   P0DIR        = 0x94;
  33      =1  sfr   P0ALT        = 0x95;
  34      =1  sfr   S0CON        = 0x98;
  35      =1  sfr   S0BUF        = 0x99;
  36      =1  sfr   IEN2         = 0x9A;
  37      =1  sfr   USBCON       = 0xA0;
  38      =1  sfr   CLKCTL       = 0xA3;
  39      =1  sfr   PWRDWN       = 0xA4;
  40      =1  sfr   WUCONF       = 0xA5;
  41      =1  sfr   INTEXP       = 0xA6;
  42      =1  sfr   IEN0         = 0xA8;
  43      =1  sfr   IP0          = 0xA9;
  44      =1  sfr   S0RELL       = 0xAA;
  45      =1  sfr   REGXH        = 0xAB;
  46      =1  sfr   REGXL        = 0xAC;
  47      =1  sfr   REGXC        = 0xAD;
  48      =1  sfr   RSTRES       = 0xB1;
  49      =1  sfr   SMDAT        = 0xB2;
  50      =1  sfr   SMCTL        = 0xB3;
  51      =1  sfr   TICKDV       = 0xB5;
  52      =1  sfr   IEN1         = 0xB8;
  53      =1  sfr   IP1          = 0xB9;
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 2   

  54      =1  sfr   S0RELH       = 0xBA;
  55      =1  sfr   SSCONF       = 0xBC;
  56      =1  sfr   SSDATA       = 0xBD;
  57      =1  sfr   SSSTAT       = 0xBE;
  58      =1  sfr   IRCON        = 0xC0;
  59      =1  sfr   CCEN         = 0xC1;
  60      =1  sfr   CCL1         = 0xC2;
  61      =1  sfr   CCH1         = 0xC3;
  62      =1  sfr   CCL2         = 0xC4;
  63      =1  sfr   CCH2         = 0xC5;
  64      =1  sfr   CCL3         = 0xC6;
  65      =1  sfr   CCH3         = 0xC7;
  66      =1  sfr   T2CON        = 0xC8;
  67      =1  sfr   P0EXP        = 0xC9;
  68      =1  sfr   CRCL         = 0xCA;
  69      =1  sfr   CRCH         = 0xCB;
  70      =1  sfr   TL2          = 0xCC;
  71      =1  sfr   TH2          = 0xCD;
  72      =1  sfr   PSW          = 0xD0;
  73      =1  sfr   WDCON        = 0xD8;
  74      =1  sfr   USBSLP       = 0xD9;
  75      =1  sfr   ACC          = 0xE0;
  76      =1  sfr   RFDAT        = 0xE5;
  77      =1  sfr   RFCTL        = 0xE6;
  78      =1  sfr   AESCS        = 0xE8;
  79      =1  sfr   MD0          = 0xE9;
  80      =1  sfr   MD1          = 0xEA;
  81      =1  sfr   MD2          = 0xEB;
  82      =1  sfr   MD3          = 0xEC;
  83      =1  sfr   MD4          = 0xED;
  84      =1  sfr   MD5          = 0xEE;
  85      =1  sfr   ARCON        = 0xEF;
  86      =1  sfr   B            = 0xF0;
  87      =1  sfr   AESKIN       = 0xF1;
  88      =1  sfr   AESIV        = 0xF2;
  89      =1  sfr   AESD         = 0xF3;
  90      =1  sfr   AESIA1       = 0xF5;
  91      =1  sfr   AESIA2       = 0xF6;
  92      =1  sfr   FSR          = 0xF8;
  93      =1  sfr   FPCR         = 0xF9;
  94      =1  sfr   FCR          = 0xFA;
  95      =1  
  96      =1  //-----------------------------------------------------------------------------
  97      =1  // Word Registers
  98      =1  //-----------------------------------------------------------------------------
  99      =1  
 100      =1  sfr16 CC1          = 0xC2;
 101      =1  sfr16 CC2          = 0xC4;
 102      =1  sfr16 CC3          = 0xC6;
 103      =1  sfr16 CRC          = 0xCA;
 104      =1  sfr16 T2           = 0xCC;
 105      =1  
 106      =1  //-----------------------------------------------------------------------------
 107      =1  /* Lint uses a trick (see co-kc51.lnt) where sbit gets treated like (expanded to) a bool.
 108      =1     This causes errors due to the strong type checking of _Bool (and thereby bool) that
 109      =1     is turned on in our implementation of stdbool.h.
 110      =1     Therefore, we suppress Lint warning 18 ("Redeclaration") for the sbit-s declared in this file.
 111      =1  */
 112      =1  
 113      =1  /*lint -e18 */
 114      =1  //-----------------------------------------------------------------------------
 115      =1  
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 3   

 116      =1  //-----------------------------------------------------------------------------
 117      =1  // Bit Definitions
 118      =1  //-----------------------------------------------------------------------------
 119      =1  
 120      =1  /*  FSR  */
 121      =1  sbit  MCDIS        = FSR^7;
 122      =1  sbit  STP          = FSR^6;
 123      =1  sbit  WEN          = FSR^5;
 124      =1  sbit  RDYN         = FSR^4;
 125      =1  sbit  INFEN        = FSR^3;
 126      =1  sbit  RDIS         = FSR^2;
 127      =1  sbit  RDEND        = FSR^1;
 128      =1  sbit  WPEN         = FSR^0;
 129      =1  
 130      =1  /*  PSW   */
 131      =1  sbit  CY           = PSW^7;
 132      =1  sbit  AC           = PSW^6;
 133      =1  sbit  F0           = PSW^5;
 134      =1  sbit  RS1          = PSW^4;
 135      =1  sbit  RS0          = PSW^3;
 136      =1  sbit  OV           = PSW^2;
 137      =1  sbit  F1           = PSW^1;
 138      =1  sbit  P            = PSW^0;
 139      =1  
 140      =1  /*  TCON  */
 141      =1  sbit  TF1          = TCON^7;
 142      =1  sbit  TR1          = TCON^6;
 143      =1  sbit  TF0          = TCON^5;
 144      =1  sbit  TR0          = TCON^4;
 145      =1  sbit  IE1          = TCON^3;
 146      =1  sbit  IT1          = TCON^2;
 147      =1  sbit  IE0          = TCON^1;
 148      =1  sbit  IT0          = TCON^0;
 149      =1  
 150      =1  /*  S0CON  */
 151      =1  sbit  SM0          = S0CON^7;
 152      =1  sbit  SM1          = S0CON^6;
 153      =1  sbit  SM20         = S0CON^5;
 154      =1  sbit  REN0         = S0CON^4;
 155      =1  sbit  TB80         = S0CON^3;
 156      =1  sbit  RB80         = S0CON^2;
 157      =1  sbit  TI0          = S0CON^1;
 158      =1  sbit  RI0          = S0CON^0;
 159      =1  
 160      =1  /*  T2CON  */
 161      =1  sbit  T2PS         = T2CON^7;
 162      =1  sbit  I3FR         = T2CON^6;
 163      =1  sbit  I2FR         = T2CON^5;
 164      =1  sbit  T2R1         = T2CON^4;
 165      =1  sbit  T2R0         = T2CON^3;
 166      =1  sbit  T2CM         = T2CON^2;
 167      =1  sbit  T2I1         = T2CON^1;
 168      =1  sbit  T2I0         = T2CON^0;
 169      =1  
 170      =1  /*  IEN0  */
 171      =1  sbit  EA           = IEN0^7;
 172      =1  
 173      =1  sbit  ET2          = IEN0^5;
 174      =1  sbit  ES0          = IEN0^4;
 175      =1  sbit  ET1          = IEN0^3;
 176      =1  sbit  EX1          = IEN0^2;
 177      =1  sbit  ET0          = IEN0^1;
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 4   

 178      =1  sbit  EX0          = IEN0^0;
 179      =1  
 180      =1  /* IEN1  */
 181      =1  sbit  EXEN2        = IEN1^7;
 182      =1  
 183      =1  sbit  WUIRQ        = IEN1^5;
 184      =1  sbit  USB          = IEN1^4;
 185      =1  sbit  USBWU        = IEN1^3;
 186      =1  sbit  SPI          = IEN1^2;
 187      =1  sbit  RF           = IEN1^1;
 188      =1  sbit  RFSPI        = IEN1^0;
 189      =1  
 190      =1  /* IRCON */
 191      =1  sbit  EXF2         = IRCON^7;
 192      =1  sbit  TF2          = IRCON^6;
 193      =1  sbit  WUF          = IRCON^5;
 194      =1  sbit  USBF         = IRCON^4;
 195      =1  sbit  USBWUF       = IRCON^3;
 196      =1  sbit  SPIF         = IRCON^2;
 197      =1  sbit  RFF          = IRCON^1;
 198      =1  sbit  RFSPIF       = IRCON^0;
 199      =1  
 200      =1  /* USBCON */
 201      =1  sbit  SWRST        = USBCON^7;
 202      =1  sbit  WU           = USBCON^6;
 203      =1  sbit  SUSPEND      = USBCON^5;
 204      =1  sbit  IV4          = USBCON^4;
 205      =1  sbit  IV3          = USBCON^3;
 206      =1  sbit  IV2          = USBCON^2;
 207      =1  sbit  IV1          = USBCON^1;
 208      =1  sbit  IV0          = USBCON^0;
 209      =1  
 210      =1  /* PORT0 */
 211      =1  sbit  P00          = P0^0;
 212      =1  sbit  P01          = P0^1;
 213      =1  sbit  P02          = P0^2;
 214      =1  sbit  P03          = P0^3;
 215      =1  sbit  MCSN         = P0^3;
 216      =1  sbit  SCSN         = P0^3;
 217      =1  sbit  P04          = P0^4;
 218      =1  sbit  P05          = P0^5;
 219      =1  
 220      =1  /* RFCON */
 221      =1  sbit  RFCE         = RFCON^0;
 222      =1  sbit  RFCSN        = RFCON^1;
 223      =1  sbit  RFCKEN       = RFCON^2;
 224      =1  
 225      =1  /* WDCON */
 226      =1  sbit  BD           = WDCON^7;
 227      =1  
 228      =1  /* AESCS */
 229      =1  sbit  GO           = AESCS^0;
 230      =1  sbit  DECR         = AESCS^1;
 231      =1  
 232      =1  /*lint +e18 */  /* Re-enable Lint warning 18 */
 233      =1  
 234      =1  
 235      =1  /* REGX commands */
 236      =1  #define RWD         0x00
 237      =1  #define WWD         0x08
 238      =1  #define RGTIMER     0x01
 239      =1  #define WGTIMER     0x09
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 5   

 240      =1  #define RRTCLAT     0x02
 241      =1  #define WRTCLAT     0x0A
 242      =1  #define RRTC        0x03
 243      =1  #define WRTCDIS     0x0B
 244      =1  #define RWSTA0      0x04
 245      =1  #define WWCON0      0x0C
 246      =1  #define RWSTA1      0x05
 247      =1  #define WWCON1      0x0D
 248      =1  
 249      =1  //-----------------------------------------------------------------------------
 250      =1  // Interrupt Vector Definitions
 251      =1  //-----------------------------------------------------------------------------
 252      =1  
 253      =1  #define INTERRUPT_EXT_INT0     0   // External Interrupt0 (P0.3)
 254      =1  #define INTERRUPT_T0           1   // Timer0 Overflow
 255      =1  #define INTERRUPT_AES_RDY      2   // AES ready interrupt
 256      =1  #define INTERRUPT_T1           3   // Timer1 Overflow
 257      =1  #define INTERRUPT_UART0        4   // UART0, Receive & Transmitt interrupt
 258      =1  #define INTERRUPT_T2           5   // Timer2 Overflow
 259      =1  #define INTERRUPT_RF_RDY       8   // RF SPI ready interrupt
 260      =1  #define INTERRUPT_RFIRQ        9   // RF interrupt
 261      =1  #define INTERRUPT_SPI          10  // SPI interrupt
 262      =1  #define INTERRUPT_USB_WU       11  // USB wakeup interrupt
 263      =1  #define INTERRUPT_USB_INT      12  // USB interrupt
 264      =1  #define INTERRUPT_WU           13  // Internal wakeup interrupt
 265      =1  
 266      =1  //-----------------------------------------------------------------------------
 267      =1  // Header File Preprocessor Directive
 268      =1  //-----------------------------------------------------------------------------
 269      =1  
 270      =1  #endif
   2          #include <intrins.h>
   1      =1  /*--------------------------------------------------------------------------
   2      =1  INTRINS.H
   3      =1  
   4      =1  Intrinsic functions for C51.
   5      =1  Copyright (c) 1988-2010 Keil Elektronik GmbH and ARM Germany GmbH
   6      =1  All rights reserved.
   7      =1  --------------------------------------------------------------------------*/
   8      =1  
   9      =1  #ifndef __INTRINS_H__
  10      =1  #define __INTRINS_H__
  11      =1  
  12      =1  extern void          _nop_     (void);
  13      =1  extern bit           _testbit_ (bit);
  14      =1  extern unsigned char _cror_    (unsigned char, unsigned char);
  15      =1  extern unsigned int  _iror_    (unsigned int,  unsigned char);
  16      =1  extern unsigned long _lror_    (unsigned long, unsigned char);
  17      =1  extern unsigned char _crol_    (unsigned char, unsigned char);
  18      =1  extern unsigned int  _irol_    (unsigned int,  unsigned char);
  19      =1  extern unsigned long _lrol_    (unsigned long, unsigned char);
  20      =1  extern unsigned char _chkfloat_(float);
  21      =1  #if !defined (__CX2__)
  22      =1  extern void          _push_    (unsigned char _sfr);
  23      =1  extern void          _pop_     (unsigned char _sfr);
  24      =1  #endif
  25      =1  
  26      =1  #endif
  27      =1  
   3          #include <stdint.h>
   1      =1  /* Copyright (c) 2007 Nordic Semiconductor. All Rights Reserved.
   2      =1   *
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 6   

   3      =1   * The information contained herein is property of Nordic Semiconductor ASA.
   4      =1   * Terms and conditions of usage are described in detail in NORDIC
   5      =1   * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =1   *
   7      =1   * Licensees are granted free, non-transferable use of the information. NO
   8      =1   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =1   * the file.
  10      =1   *
  11      =1   * $LastChangedRevision: 186 $
  12      =1   */
  13      =1  
  14      =1  /** @file
  15      =1   * Type definitions for firmware projects developed at Nordic Semiconductor.
  16      =1   *
  17      =1   * Standard storage classes in C, such as @c char, @c int, and @c long, are not always
  18      =1   * interpreted in the same way by the compiler. The types here are defined by their
  19      =1   * bit length and signed/unsigned property, as their names indicate. The correlation
  20      =1   * between the name and properties of the storage class should be true, regardless of
  21      =1   * the compiler being used.
  22      =1   */
  23      =1  
  24      =1  #ifndef __STDINT_H__
  25      =1  #define __STDINT_H__
  26      =1  
  27      =1  #ifdef __C51__
  28      =1  
  29      =1  typedef unsigned char uint8_t;        ///< 8 bit unsigned int
  30      =1  
  31      =1  typedef signed char int8_t;          ///< 8 bit signed int
  32      =1  
  33      =1  typedef unsigned int uint16_t;        ///< 16 bit unsigned int
  34      =1  
  35      =1  typedef signed int int16_t;          ///< 16 bit signed int
  36      =1  
  37      =1  typedef unsigned long uint32_t;       ///< 32 bit unsigned int
  38      =1  
  39      =1  typedef signed long int32_t;         ///< 32 bit signed int
  40      =1  
  41      =1  #endif // __C51__
  42      =1  
  43      =1  #ifndef NULL
  44      =1  #define NULL (void*)0
  45      =1  #endif
  46      =1  
  47      =1  #endif // __STDINT_H__
   4          #include <stdio.h>
   1      =1  /*--------------------------------------------------------------------------
   2      =1  STDIO.H
   3      =1  
   4      =1  Prototypes for standard I/O functions.
   5      =1  Copyright (c) 1988-2002 Keil Elektronik GmbH and Keil Software, Inc.
   6      =1  All rights reserved.
   7      =1  --------------------------------------------------------------------------*/
   8      =1  
   9      =1  #ifndef __STDIO_H__
  10      =1  #define __STDIO_H__
  11      =1  
  12      =1  #ifndef EOF
  13      =1   #define EOF -1
  14      =1  #endif
  15      =1  
  16      =1  #ifndef NULL
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 7   

           =1  #define NULL ((void *) 0)
           =1 #endif
  19      =1  
  20      =1  #ifndef _SIZE_T
  21      =1   #define _SIZE_T
  22      =1   typedef unsigned int size_t;
  23      =1  #endif
  24      =1  
  25      =1  #pragma SAVE
  26      =1  #pragma REGPARMS
  27      =1  extern char _getkey (void);
  28      =1  extern char getchar (void);
  29      =1  extern char ungetchar (char);
  30      =1  extern char putchar (char);
  31      =1  extern int printf   (const char *, ...);
  32      =1  extern int sprintf  (char *, const char *, ...);
  33      =1  extern int vprintf  (const char *, char *);
  34      =1  extern int vsprintf (char *, const char *, char *);
  35      =1  extern char *gets (char *, int n);
  36      =1  extern int scanf (const char *, ...);
  37      =1  extern int sscanf (char *, const char *, ...);
  38      =1  extern int puts (const char *);
  39      =1  
  40      =1  #pragma RESTORE
  41      =1  
  42      =1  #endif
  43      =1  
   5          
   6          #include "usb.h"
   1      =1  /* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
   2      =1   *
   3      =1   * The information contained herein is confidential property of Nordic 
   4      =1   * Semiconductor ASA.Terms and conditions of usage are described in detail 
   5      =1   * in NORDIC SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =1   *
   7      =1   * Licensees are granted free, non-transferable use of the information. NO
   8      =1   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =1   * the file.
  10      =1   *              
  11      =1   * $LastChangedRevision: 133 $
  12      =1   */ 
  13      =1  
  14      =1  /** @file
  15      =1   * @brief This file contain definitions related to the USB-controller and internal structures
  16      =1   */
  17      =1  
  18      =1  #ifndef USB_H__
  19      =1  #define USB_H__
  20      =1  
  21      =1  #include <stdint.h>
   1      =2  /* Copyright (c) 2007 Nordic Semiconductor. All Rights Reserved.
   2      =2   *
   3      =2   * The information contained herein is property of Nordic Semiconductor ASA.
   4      =2   * Terms and conditions of usage are described in detail in NORDIC
   5      =2   * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =2   *
   7      =2   * Licensees are granted free, non-transferable use of the information. NO
   8      =2   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =2   * the file.
  10      =2   *
  11      =2   * $LastChangedRevision: 186 $
  12      =2   */
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 8   

  13      =2  
  14      =2  /** @file
  15      =2   * Type definitions for firmware projects developed at Nordic Semiconductor.
  16      =2   *
  17      =2   * Standard storage classes in C, such as @c char, @c int, and @c long, are not always
  18      =2   * interpreted in the same way by the compiler. The types here are defined by their
  19      =2   * bit length and signed/unsigned property, as their names indicate. The correlation
  20      =2   * between the name and properties of the storage class should be true, regardless of
  21      =2   * the compiler being used.
  22      =2   */
  23      =2  
  24      =2  #ifndef __STDINT_H__
           =2 #define __STDINT_H__
           =2 
           =2 #ifdef __C51__
           =2 
           =2 typedef unsigned char uint8_t;        ///< 8 bit unsigned int
           =2 
           =2 typedef signed char int8_t;          ///< 8 bit signed int
           =2 
           =2 typedef unsigned int uint16_t;        ///< 16 bit unsigned int
           =2 
           =2 typedef signed int int16_t;          ///< 16 bit signed int
           =2 
           =2 typedef unsigned long uint32_t;       ///< 32 bit unsigned int
           =2 
           =2 typedef signed long int32_t;         ///< 32 bit signed int
           =2 
           =2 #endif // __C51__
           =2 
           =2 #ifndef NULL
           =2 #define NULL (void*)0
           =2 #endif
           =2 
           =2 #endif // __STDINT_H__
  22      =1  
  23      =1  #include "hal_usb.h"
   1      =2  /* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
   2      =2   *
   3      =2   * The information contained herein is confidential property of Nordic 
   4      =2   * Semiconductor ASA.Terms and conditions of usage are described in detail 
   5      =2   * in NORDIC SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =2   *
   7      =2   * Licensees are granted free, non-transferable use of the information. NO
   8      =2   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =2   * the file.
  10      =2   *              
  11      =2   * $LastChangedRevision: 181 $
  12      =2   */
  13      =2  
  14      =2  /** @file
  15      =2   * @brief Interface for the USB device controller.
  16      =2   *
  17      =2   * The header file must define the following type-defined structs:
  18      =2   *  - hal_usb_conf_desc_templ_t
  19      =2   *  - hal_usb_string_desc_templ_t
  20      =2   *  - hal_usb_dev_desc_templ_t
  21      =2   *  .
  22      =2   * And the following global variables:
  23      =2   *  - g_usb_string_desc
  24      =2   *  - g_usb_conf_desc
  25      =2   *  - g_usb_dev_desc
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 9   

  26      =2   *
  27      =2   * @defgroup hal_nrf24lu1p_hal_usb Universal Serial Bus (hal_usb)
  28      =2   * @{
  29      =2   * @ingroup hal_nrf24lu1p
  30      =2   *
  31      =2   * <h1>Control Transfer Functionality</h1>
  32      =2   *
  33      =2   * <h2>Descriptor Requests</h2>
  34      =2   * The module handles the following <b>descriptor requests</b>:
  35      =2   * - Device
  36      =2   * - Configuration
  37      =2   * - String
  38      =2   *
  39      =2   * It does <b>not</b> support (replies with STALL to USB host controller):
  40      =2   * - Interface
  41      =2   * - DeviceQual
  42      =2   * - OtherSpeedConf
  43      =2   * - InterfacePower
  44      =2   * 
  45      =2   * All other descriptor requests (HID, ...) are made available to the application code through the hal_usb
             -_cb_device_req_t callback.
  46      =2   *
  47      =2   * The module does <b>not</b> support SetDescriptor requests
  48      =2   *
  49      =2   * <h2>Feature Requests</h2>
  50      =2   *
  51      =2   * The module handles the following feature requests:
  52      =2   * -  DeviceRemoteWakeup
  53      =2   * -  EndpointHalt
  54      =2   * 
  55      =2   * It does <b>not</b> support (replies with STALL to USB host controller) any other feature requests yet
  56      =2   *
  57      =2   * <h2>Configuration Requests</h2>
  58      =2   *
  59      =2   * The module do only support setting configuration 0 (sets the adressed state) and 1. Other configuration
             -s replies with STALL. Several configurations for a device is not implemented.
  60      =2   * 
  61      =2   * <h2>Alternative Interface Requests</h2>
  62      =2   *
  63      =2   * Setting and getting alternative interfaces are not supported (replies with STALL to USB host controller
             -)
  64      =2   * 
  65      =2   * <h2>Sync Frame Requests</h2>
  66      =2   * Not supported
  67      =2   * 
  68      =2   * <h2>Class Specific Requests</h2>
  69      =2   * All class specific requests are made available to the application code through the hal_usb_cb_device_re
             -q_t callback. 
  70      =2   *
  71      =2   * <h1>Endpoint Functionality</h1>
  72      =2   * All available IN and OUT endpoints are avialable to the application through the hal_usb_send_packet, ha
             -l_usb_receive_packet functions and the callbacks registered for the endpoint. The callback functions are called when the
             - host replies with an ACK for having received a packet or when the host has sent an OUT packet. 
  73      =2   * 
  74      =2   * Isochronos endpoints are not supported in this version of USB HAL.
  75      =2   */
  76      =2  
  77      =2  #ifndef HAL_USB_H__
  78      =2  #define HAL_USB_H__
  79      =2  
  80      =2  #include <stdint.h>
   1      =3  /* Copyright (c) 2007 Nordic Semiconductor. All Rights Reserved.
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 10  

   2      =3   *
   3      =3   * The information contained herein is property of Nordic Semiconductor ASA.
   4      =3   * Terms and conditions of usage are described in detail in NORDIC
   5      =3   * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =3   *
   7      =3   * Licensees are granted free, non-transferable use of the information. NO
   8      =3   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =3   * the file.
  10      =3   *
  11      =3   * $LastChangedRevision: 186 $
  12      =3   */
  13      =3  
  14      =3  /** @file
  15      =3   * Type definitions for firmware projects developed at Nordic Semiconductor.
  16      =3   *
  17      =3   * Standard storage classes in C, such as @c char, @c int, and @c long, are not always
  18      =3   * interpreted in the same way by the compiler. The types here are defined by their
  19      =3   * bit length and signed/unsigned property, as their names indicate. The correlation
  20      =3   * between the name and properties of the storage class should be true, regardless of
  21      =3   * the compiler being used.
  22      =3   */
  23      =3  
  24      =3  #ifndef __STDINT_H__
           =3 #define __STDINT_H__
           =3 
           =3 #ifdef __C51__
           =3 
           =3 typedef unsigned char uint8_t;        ///< 8 bit unsigned int
           =3 
           =3 typedef signed char int8_t;          ///< 8 bit signed int
           =3 
           =3 typedef unsigned int uint16_t;        ///< 16 bit unsigned int
           =3 
           =3 typedef signed int int16_t;          ///< 16 bit signed int
           =3 
           =3 typedef unsigned long uint32_t;       ///< 32 bit unsigned int
           =3 
           =3 typedef signed long int32_t;         ///< 32 bit signed int
           =3 
           =3 #endif // __C51__
           =3 
           =3 #ifndef NULL
           =3 #define NULL (void*)0
           =3 #endif
           =3 
           =3 #endif // __STDINT_H__
  81      =2  #include <stdbool.h>
   1      =3  /* Copyright (c) 2007 Nordic Semiconductor. All Rights Reserved.
   2      =3   *
   3      =3   * The information contained herein is property of Nordic Semiconductor ASA.
   4      =3   * Terms and conditions of usage are described in detail in NORDIC
   5      =3   * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
   6      =3   *
   7      =3   * Licensees are granted free, non-transferable use of the information. NO
   8      =3   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =3   * the file.
  10      =3   *
  11      =3   * $LastChangedRevision: 230 $
  12      =3   */
  13      =3  
  14      =3  /** @file
  15      =3   * Type definitions for firmware projects developed at Nordic Semiconductor.
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 11  

  16      =3   *
  17      =3   * Standard storage classes in C, such as @c char, @c int, and @c long, are not always
  18      =3   * interpreted in the same way by the compiler. The types here are defined by their
  19      =3   * bit length and signed/unsigned property, as their names indicate. The correlation
  20      =3   * between the name and properties of the storage class should be true, regardless of
  21      =3   * the compiler being used.
  22      =3   */
  23      =3  
  24      =3  #ifndef __STDBOOL_H__
  25      =3  #define __STDBOOL_H__
  26      =3  
  27      =3  //lint -strong(b,_Bool)
  28      =3  typedef unsigned char _Bool; ///< Boolean type
  29      =3  
  30      =3  #define bool _Bool
  31      =3  #define true ((bool)1)
  32      =3  #define false ((bool)0)
  33      =3  #define __bool_true_false_are_defined 1
  34      =3  
  35      =3  #endif // __STDBOOL_H__
  82      =2  
  83      =2  #include "hal_usb_desc.h"
   1      =3  /* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
   2      =3   *
   3      =3   * The information contained herein is confidential property of Nordic 
   4      =3   * Semiconductor ASA.Terms and conditions of usage are described in detail 
   5      =3   * in NORDIC SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =3   *
   7      =3   * Licensees are granted free, non-transferable use of the information. NO
   8      =3   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =3   * the file.
  10      =3   *              
  11      =3   * $LastChangedRevision: 133 $
  12      =3   */
  13      =3  
  14      =3  /** @file
  15      =3  * @brief This file contain structures and constants defined in Chapter 9 of the USB 2.0 standard
  16      =3   */
  17      =3  
  18      =3  #ifndef HAL_USB_DESC_H__
  19      =3  #define HAL_USB_DESC_H__
  20      =3  
  21      =3  #include <stdint.h>
   1      =4  /* Copyright (c) 2007 Nordic Semiconductor. All Rights Reserved.
   2      =4   *
   3      =4   * The information contained herein is property of Nordic Semiconductor ASA.
   4      =4   * Terms and conditions of usage are described in detail in NORDIC
   5      =4   * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =4   *
   7      =4   * Licensees are granted free, non-transferable use of the information. NO
   8      =4   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =4   * the file.
  10      =4   *
  11      =4   * $LastChangedRevision: 186 $
  12      =4   */
  13      =4  
  14      =4  /** @file
  15      =4   * Type definitions for firmware projects developed at Nordic Semiconductor.
  16      =4   *
  17      =4   * Standard storage classes in C, such as @c char, @c int, and @c long, are not always
  18      =4   * interpreted in the same way by the compiler. The types here are defined by their
  19      =4   * bit length and signed/unsigned property, as their names indicate. The correlation
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 12  

  20      =4   * between the name and properties of the storage class should be true, regardless of
  21      =4   * the compiler being used.
  22      =4   */
  23      =4  
  24      =4  #ifndef __STDINT_H__
           =4 #define __STDINT_H__
           =4 
           =4 #ifdef __C51__
           =4 
           =4 typedef unsigned char uint8_t;        ///< 8 bit unsigned int
           =4 
           =4 typedef signed char int8_t;          ///< 8 bit signed int
           =4 
           =4 typedef unsigned int uint16_t;        ///< 16 bit unsigned int
           =4 
           =4 typedef signed int int16_t;          ///< 16 bit signed int
           =4 
           =4 typedef unsigned long uint32_t;       ///< 32 bit unsigned int
           =4 
           =4 typedef signed long int32_t;         ///< 32 bit signed int
           =4 
           =4 #endif // __C51__
           =4 
           =4 #ifndef NULL
           =4 #define NULL (void*)0
           =4 #endif
           =4 
           =4 #endif // __STDINT_H__
  22      =3  
  23      =3  // Standard request codes
  24      =3  #define USB_REQ_GET_STATUS         0x00
  25      =3  #define USB_REQ_CLEAR_FEATURE      0x01
  26      =3  #define USB_REQ_RESERVED_1         0x02
  27      =3  #define USB_REQ_SET_FEATURE        0x03
  28      =3  #define USB_REQ_RESERVED_2         0x04
  29      =3  #define USB_REQ_SET_ADDRESS        0x05
  30      =3  #define USB_REQ_GET_DESCRIPTOR     0x06
  31      =3  #define USB_REQ_SET_DESCRIPTOR     0x07
  32      =3  #define USB_REQ_GET_CONFIGURATION  0x08
  33      =3  #define USB_REQ_SET_CONFIGURATION  0x09
  34      =3  #define USB_REQ_GET_INTERFACE      0x0a
  35      =3  #define USB_REQ_SET_INTERFACE      0x0b
  36      =3  #define USB_REQ_SYNCH_FRAME        0x0c
  37      =3  
  38      =3  // Descriptor types
  39      =3  #define USB_DESC_DEVICE           0x01
  40      =3  #define USB_DESC_CONFIGURATION    0x02
  41      =3  #define USB_DESC_STRING           0x03
  42      =3  #define USB_DESC_INTERFACE        0x04
  43      =3  #define USB_DESC_ENDPOINT         0x05
  44      =3  #define USB_DESC_DEVICE_QUAL      0x06
  45      =3  #define USB_DESC_OTHER_SPEED_CONF 0x07
  46      =3  #define USB_DESC_INTERFACE_POWER  0x08
  47      =3  #define USB_DESC_OTG              0x09
  48      =3  #define USB_DESC_DEBUG            0x0A
  49      =3  #define USB_DESC_INTERFACE_ASSOC  0x0B
  50      =3  
  51      =3  #define USB_ENDPOINT_TYPE_CONTROL           0x00
  52      =3  #define USB_ENDPOINT_TYPE_ISOCHRONOUS       0x01
  53      =3  #define USB_ENDPOINT_TYPE_BULK              0x02
  54      =3  #define USB_ENDPOINT_TYPE_INTERRUPT         0x03
  55      =3  
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 13  

  56      =3  // USB device classes
  57      =3  #define USB_DEVICE_CLASS_RESERVED               0x00
  58      =3  #define USB_DEVICE_CLASS_AUDIO                  0x01
  59      =3  #define USB_DEVICE_CLASS_COMMUNICATIONS         0x02
  60      =3  #define USB_DEVICE_CLASS_HUMAN_INTERFACE        0x03
  61      =3  #define USB_DEVICE_CLASS_MONITOR                0x04
  62      =3  #define USB_DEVICE_CLASS_PHYSICAL_INTERFACE     0x05
  63      =3  #define USB_DEVICE_CLASS_POWER                  0x06
  64      =3  #define USB_DEVICE_CLASS_PRINTER                0x07
  65      =3  #define USB_DEVICE_CLASS_STORAGE                0x08
  66      =3  #define USB_DEVICE_CLASS_HUB                    0x09
  67      =3  #define USB_DEVICE_CLASS_APPLICATION_SPECIFIC   0xFE
  68      =3  #define USB_DEVICE_CLASS_VENDOR_SPECIFIC        0xFF
  69      =3  
  70      =3  
  71      =3  #define USB_CLASS_DESCRIPTOR_HID    0x21
  72      =3  #define USB_CLASS_DESCRIPTOR_REPORT 0x22
  73      =3  #define USB_CLASS_DESCRIPTOR_PHYSICAL_DESCRIPTOR 0x23
  74      =3  
  75      =3  #define USB_DEVICE_REMOTE_WAKEUP    0x01
  76      =3  #define USB_ENDPOINT_HALT           0x00
  77      =3  #define USB_TEST_MODE               0x02
  78      =3  
  79      =3  typedef struct {
  80      =3       volatile uint8_t bLength;
  81      =3       volatile uint8_t bDescriptorType;
  82      =3       volatile uint16_t bcdUSB;
  83      =3       volatile uint8_t bDeviceClass;
  84      =3       volatile uint8_t bDeviceSubClass;
  85      =3       volatile uint8_t bDeviceProtocol;
  86      =3       volatile uint8_t bMaxPacketSize0;
  87      =3       volatile uint16_t idVendor;
  88      =3       volatile uint16_t idProduct;
  89      =3       volatile uint16_t bcdDevice;
  90      =3       volatile uint8_t iManufacturer;
  91      =3       volatile uint8_t iProduct;
  92      =3       volatile uint8_t iSerialNumber;
  93      =3       volatile uint8_t bNumConfigurations;
  94      =3  } hal_usb_dev_desc_t;
  95      =3  
  96      =3  typedef struct {
  97      =3       volatile uint8_t bLength;
  98      =3       volatile uint8_t bDescriptorType;
  99      =3       volatile uint16_t wTotalLength;
 100      =3       volatile uint8_t bNumInterfaces;
 101      =3       volatile uint8_t bConfigurationValue;
 102      =3       volatile uint8_t iConfiguration;
 103      =3       volatile uint8_t bmAttributes;
 104      =3       volatile uint8_t bMaxPower;
 105      =3  } hal_usb_conf_desc_t;
 106      =3  
 107      =3  typedef struct {
 108      =3       volatile uint8_t bLength;
 109      =3       volatile uint8_t bDescriptorType;
 110      =3       volatile uint8_t bInterfaceNumber;
 111      =3       volatile uint8_t bAlternateSetting;
 112      =3       volatile uint8_t bNumEndpoints;
 113      =3       volatile uint8_t bInterfaceClass;
 114      =3       volatile uint8_t bInterfaceSubClass;
 115      =3       volatile uint8_t bInterfaceProtocol;
 116      =3       volatile uint8_t iInterface;
 117      =3  } hal_usb_if_desc_t;
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 14  

 118      =3  
 119      =3  typedef struct {
 120      =3       volatile uint8_t bLength;
 121      =3       volatile uint8_t bDescriptorType;
 122      =3       volatile uint8_t bEndpointAddress;
 123      =3       volatile uint8_t bmAttributes;
 124      =3       volatile uint16_t wMaxPacketSize;
 125      =3       volatile uint8_t bInterval;
 126      =3  } hal_usb_ep_desc_t;
 127      =3  
 128      =3  typedef struct {
 129      =3      volatile uint8_t bLength;
 130      =3      volatile uint8_t bDescriptorType;
 131      =3      volatile uint16_t bcdHID;
 132      =3      volatile uint8_t bCountryCode;
 133      =3      volatile uint8_t bNumDescriptors;
 134      =3      volatile uint8_t bDescriptorType2;
 135      =3      volatile uint16_t wDescriptorLength;
 136      =3  } hal_usb_hid_desc_t;
 137      =3  
 138      =3  typedef struct {
 139      =3       volatile uint8_t* desc;
 140      =3  } hal_usb_string_desc_t;
 141      =3  
 142      =3  typedef struct {
 143      =3       volatile uint8_t bLength;
 144      =3       volatile uint8_t bDescriptorType;
 145      =3  } hal_usb_common_desc_t;
 146      =3  
 147      =3  
 148      =3  #endif // HAL_USB_DESC_H__
  84      =2  #include "config.h" 
   1      =3  /* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
   2      =3   *
   3      =3   * The information contained herein is confidential property of Nordic 
   4      =3   * Semiconductor ASA.Terms and conditions of usage are described in detail 
   5      =3   * in NORDIC SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =3   *
   7      =3   * Licensees are granted free, non-transferable use of the information. NO
   8      =3   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =3   * the file.
  10      =3   *              
  11      =3   * $LastChangedRevision: 5718 $
  12      =3   */
  13      =3  
  14      =3  /** @file
  15      =3   * Configuration file for bootloader
  16      =3   *
  17      =3   */
  18      =3  #ifndef CONFIG_H__
  19      =3  #define CONFIG_H__
  20      =3  
  21      =3  #define FLASH_PAGE_SIZE     512U
  22      =3  #define MAX_PACKET_SIZE_EP0 32
  23      =3  #define USB_EP1_SIZE        64
  24      =3  #define FLASH_SIZE          (32U*1024U)
  25      =3  #define NUM_FLASH_PAGES     FLASH_SIZE/FLASH_PAGE_SIZE
  26      =3  
  27      =3  #endif // CONFIG_H__
  85      =2  #include "usb_desc_bulk.h"
   1      =3  /* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
   2      =3   *
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 15  

   3      =3   * The information contained herein is confidential property of Nordic 
   4      =3   * Semiconductor ASA.Terms and conditions of usage are described in detail 
   5      =3   * in NORDIC SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =3   *
   7      =3   * Licensees are granted free, non-transferable use of the information. NO
   8      =3   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =3   * the file.
  10      =3   *              
  11      =3   * $LastChangedRevision: 5718 $
  12      =3   */
  13      =3  
  14      =3  /** @file
  15      =3   * Header file for the Bootloader USB descriptor
  16      =3   *
  17      =3   */
  18      =3  #ifndef USB_DESC_BULK_H__
  19      =3  #define USB_DESC_BULK_H__
  20      =3  
  21      =3  #include "hal_usb_desc.h"
   1      =4  /* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
   2      =4   *
   3      =4   * The information contained herein is confidential property of Nordic 
   4      =4   * Semiconductor ASA.Terms and conditions of usage are described in detail 
   5      =4   * in NORDIC SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =4   *
   7      =4   * Licensees are granted free, non-transferable use of the information. NO
   8      =4   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =4   * the file.
  10      =4   *              
  11      =4   * $LastChangedRevision: 133 $
  12      =4   */
  13      =4  
  14      =4  /** @file
  15      =4  * @brief This file contain structures and constants defined in Chapter 9 of the USB 2.0 standard
  16      =4   */
  17      =4  
  18      =4  #ifndef HAL_USB_DESC_H__
           =4 #define HAL_USB_DESC_H__
           =4 
           =4 #include <stdint.h>
           =4 
           =4 // Standard request codes
           =4 #define USB_REQ_GET_STATUS         0x00
           =4 #define USB_REQ_CLEAR_FEATURE      0x01
           =4 #define USB_REQ_RESERVED_1         0x02
           =4 #define USB_REQ_SET_FEATURE        0x03
           =4 #define USB_REQ_RESERVED_2         0x04
           =4 #define USB_REQ_SET_ADDRESS        0x05
           =4 #define USB_REQ_GET_DESCRIPTOR     0x06
           =4 #define USB_REQ_SET_DESCRIPTOR     0x07
           =4 #define USB_REQ_GET_CONFIGURATION  0x08
           =4 #define USB_REQ_SET_CONFIGURATION  0x09
           =4 #define USB_REQ_GET_INTERFACE      0x0a
           =4 #define USB_REQ_SET_INTERFACE      0x0b
           =4 #define USB_REQ_SYNCH_FRAME        0x0c
           =4 
           =4 // Descriptor types
           =4 #define USB_DESC_DEVICE           0x01
           =4 #define USB_DESC_CONFIGURATION    0x02
           =4 #define USB_DESC_STRING           0x03
           =4 #define USB_DESC_INTERFACE        0x04
           =4 #define USB_DESC_ENDPOINT         0x05
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 16  

           =4 #define USB_DESC_DEVICE_QUAL      0x06
           =4 #define USB_DESC_OTHER_SPEED_CONF 0x07
           =4 #define USB_DESC_INTERFACE_POWER  0x08
           =4 #define USB_DESC_OTG              0x09
           =4 #define USB_DESC_DEBUG            0x0A
           =4 #define USB_DESC_INTERFACE_ASSOC  0x0B
           =4 
           =4 #define USB_ENDPOINT_TYPE_CONTROL           0x00
           =4 #define USB_ENDPOINT_TYPE_ISOCHRONOUS       0x01
           =4 #define USB_ENDPOINT_TYPE_BULK              0x02
           =4 #define USB_ENDPOINT_TYPE_INTERRUPT         0x03
           =4 
           =4 // USB device classes
           =4 #define USB_DEVICE_CLASS_RESERVED               0x00
           =4 #define USB_DEVICE_CLASS_AUDIO                  0x01
           =4 #define USB_DEVICE_CLASS_COMMUNICATIONS         0x02
           =4 #define USB_DEVICE_CLASS_HUMAN_INTERFACE        0x03
           =4 #define USB_DEVICE_CLASS_MONITOR                0x04
           =4 #define USB_DEVICE_CLASS_PHYSICAL_INTERFACE     0x05
           =4 #define USB_DEVICE_CLASS_POWER                  0x06
           =4 #define USB_DEVICE_CLASS_PRINTER                0x07
           =4 #define USB_DEVICE_CLASS_STORAGE                0x08
           =4 #define USB_DEVICE_CLASS_HUB                    0x09
           =4 #define USB_DEVICE_CLASS_APPLICATION_SPECIFIC   0xFE
           =4 #define USB_DEVICE_CLASS_VENDOR_SPECIFIC        0xFF
           =4 
           =4 
           =4 #define USB_CLASS_DESCRIPTOR_HID    0x21
           =4 #define USB_CLASS_DESCRIPTOR_REPORT 0x22
           =4 #define USB_CLASS_DESCRIPTOR_PHYSICAL_DESCRIPTOR 0x23
           =4 
           =4 #define USB_DEVICE_REMOTE_WAKEUP    0x01
           =4 #define USB_ENDPOINT_HALT           0x00
           =4 #define USB_TEST_MODE               0x02
           =4 
           =4 typedef struct {
           =4      volatile uint8_t bLength;
           =4      volatile uint8_t bDescriptorType;
           =4      volatile uint16_t bcdUSB;
           =4      volatile uint8_t bDeviceClass;
           =4      volatile uint8_t bDeviceSubClass;
           =4      volatile uint8_t bDeviceProtocol;
           =4      volatile uint8_t bMaxPacketSize0;
           =4      volatile uint16_t idVendor;
           =4      volatile uint16_t idProduct;
           =4      volatile uint16_t bcdDevice;
           =4      volatile uint8_t iManufacturer;
           =4      volatile uint8_t iProduct;
           =4      volatile uint8_t iSerialNumber;
           =4      volatile uint8_t bNumConfigurations;
           =4 } hal_usb_dev_desc_t;
           =4 
           =4 typedef struct {
           =4      volatile uint8_t bLength;
           =4      volatile uint8_t bDescriptorType;
           =4      volatile uint16_t wTotalLength;
           =4      volatile uint8_t bNumInterfaces;
           =4      volatile uint8_t bConfigurationValue;
           =4      volatile uint8_t iConfiguration;
           =4      volatile uint8_t bmAttributes;
           =4      volatile uint8_t bMaxPower;
           =4 } hal_usb_conf_desc_t;
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 17  

           =4 
           =4 typedef struct {
           =4      volatile uint8_t bLength;
           =4      volatile uint8_t bDescriptorType;
           =4      volatile uint8_t bInterfaceNumber;
           =4      volatile uint8_t bAlternateSetting;
           =4      volatile uint8_t bNumEndpoints;
           =4      volatile uint8_t bInterfaceClass;
           =4      volatile uint8_t bInterfaceSubClass;
           =4      volatile uint8_t bInterfaceProtocol;
           =4      volatile uint8_t iInterface;
           =4 } hal_usb_if_desc_t;
           =4 
           =4 typedef struct {
           =4      volatile uint8_t bLength;
           =4      volatile uint8_t bDescriptorType;
           =4      volatile uint8_t bEndpointAddress;
           =4      volatile uint8_t bmAttributes;
           =4      volatile uint16_t wMaxPacketSize;
           =4      volatile uint8_t bInterval;
           =4 } hal_usb_ep_desc_t;
           =4 
           =4 typedef struct {
           =4     volatile uint8_t bLength;
           =4     volatile uint8_t bDescriptorType;
           =4     volatile uint16_t bcdHID;
           =4     volatile uint8_t bCountryCode;
           =4     volatile uint8_t bNumDescriptors;
           =4     volatile uint8_t bDescriptorType2;
           =4     volatile uint16_t wDescriptorLength;
           =4 } hal_usb_hid_desc_t;
           =4 
           =4 typedef struct {
           =4      volatile uint8_t* desc;
           =4 } hal_usb_string_desc_t;
           =4 
           =4 typedef struct {
           =4      volatile uint8_t bLength;
           =4      volatile uint8_t bDescriptorType;
           =4 } hal_usb_common_desc_t;
           =4 
           =4 
           =4 #endif // HAL_USB_DESC_H__
  22      =3  
  23      =3  #define USB_DESC_TEMPLATE 
  24      =3  
  25      =3  //------------------------------------------ 
  26      =3  // Vendor ID and Product ID definitions 
  27      =3  //------------------------------------------ 
  28      =3  #define VID   0x1915 
  29      =3  #define PID   0x0909 
  30      =3  
  31      =3  #define USB_STRING_DESC_COUNT 2
  32      =3  
  33      =3  typedef struct
  34      =3  {
  35      =3      hal_usb_conf_desc_t conf;
  36      =3      hal_usb_if_desc_t if0;
  37      =3      hal_usb_ep_desc_t ep1in;
  38      =3      hal_usb_ep_desc_t ep1out;
  39      =3  } usb_conf_desc_templ_t;
  40      =3  
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 18  

  41      =3  typedef struct { 
  42      =3       volatile uint8_t* idx[USB_STRING_DESC_COUNT]; 
  43      =3  } usb_string_desc_templ_t; 
  44      =3  
  45      =3  extern code usb_string_desc_templ_t g_usb_string_desc; 
  46      =3  extern code usb_conf_desc_templ_t g_usb_conf_desc;
  47      =3  extern code hal_usb_dev_desc_t g_usb_dev_desc;
  48      =3  
  49      =3  typedef struct { 
  50      =3       hal_usb_dev_desc_t* dev; 
  51      =3       usb_conf_desc_templ_t* conf; 
  52      =3       usb_string_desc_templ_t* string; 
  53      =3       uint8_t string_zero[4]; 
  54      =3  } usb_descs_templ_t;
  55      =3  
  56      =3  extern code uint8_t g_usb_string_desc_1[];
  57      =3  extern code uint8_t g_usb_string_desc_2[];
  58      =3  extern code uint8_t string_zero[4];
  59      =3  
  60      =3  #endif  // USB_DESC_TEMPL_H__
  86      =2  
  87      =2  #ifndef USB_DESC_TEMPLATE
           =2 #error "USB_DESC_TEMPLATE not defined. Please include a file with g_usb_string_desc, g_usb_conf_desc and g
             -_usb_dev_desc defined" 
           =2 #endif
  90      =2  
  91      =2  #define USB_BM_STATE_CONFIGURED 0x01
  92      =2  #define USB_BM_STATE_ALLOW_REMOTE_WAKEUP 0x02
  93      =2  #define USB_BM_STATE_HOST_WU     0x04
  94      =2  
  95      =2  /** An enum describing the USB state
  96      =2   * 
  97      =2   *  The states described in this enum are found in Chapter 9 of the USB 2.0 specification
  98      =2   */
  99      =2  
 100      =2  typedef enum  { 
 101      =2      ATTACHED,   /**< Device is attached to the USB, but is not powered */
 102      =2      POWERED,    /**< Device is attached to the USB and powered */
 103      =2      DEFAULT,    /**< Device is attached to the USB and powered and has been reset, but has not been assign
             -ed a unique address */
 104      =2      ADDRESSED,  /**< Device is attached to the USB, powered, has been reset, and a unique device address h
             -as been assigned. Device is not configured */
 105      =2      CONFIGURED, /**< Device is attached to the USB, powered, has been reset, has a unique address, is conf
             -igured and is not suspended */
 106      =2      SUSPENDED   /**< Device is, at a minimum, attached to the USB and is powered and has not seen bus acti
             -vity for 3ms. It may also have a unique address and be configured for use. However, because the device is suspended, the
             - host may not use the device configuration */
 107      =2  } hal_usb_state_t;
 108      =2  
 109      =2  /** Structure containing the USB standard request
 110      =2   *  See Chapter 9 USB Device Framework in the USB 2.0 specification.
 111      =2   */
 112      =2  
 113      =2  typedef struct {
 114      =2      uint8_t  bmRequestType; /**< Bitmapped field identifying the characteristics of the request.
 115      =2                          - D7: Data transfer direction 
 116      =2                          - 0 = Host-to-device
 117      =2                          - 1 = Device-to-host
 118      =2  
 119      =2                          - D6..5: Type
 120      =2                          - 0 = Standard
 121      =2                          - 1 = Class
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 19  

 122      =2                          - 2 = Vendor
 123      =2                          - 3 = Reserved
 124      =2  
 125      =2                          - D4..0: Recipient
 126      =2                          - 0 = Device
 127      =2                          - 1 = Interface
 128      =2                          - 2 = Endpoint
 129      =2                          - 3 = Other
 130      =2                          - 4..31 = Reserved
 131      =2                            */
 132      =2      uint8_t  bRequest;       /**< Field specifying request. bmRequestType(Type) modifies the meaning of th
             -is field. */
 133      =2  
 134      =2      uint8_t wValueMsb;      /**< Field used to pass a parameter to the device, specific to the request. MS
             -B*/
 135      =2      uint8_t wValueLsb;      /**< Field used to pass a parameter to the device, specific to the request. LS
             -B*/
 136      =2      uint8_t wIndex;         /**< Field used to pass a parameter to the device, specific to the request. */
 137      =2      uint8_t wLength;        /**< Field used to specify length of the data transferred during the second ph
             -ase of the control transfer. Direction of data transfer given by bmRequestType(Direction). If field is zero there is no 
             -data transfer phase. */
 138      =2  //    void* misc_data;
 139      =2  } hal_usb_device_req;
 140      =2  
 141      =2  /** An enum describing which reply to send to the control request
 142      =2   */
 143      =2  
 144      =2  typedef enum {
 145      =2      STALL,         /**< Respond with STALL */
 146      =2      NAK,           /**< Respond with NAK   */
 147      =2      ACK,           /**< Respond with ACK (if this is an OUT request) */
 148      =2      NO_RESPONSE,   /**< Do not respond */
 149      =2      DATA,          /**< Data is available */
 150      =2      EMPTY_RESPONSE /**< Send an empty response */
 151      =2  } hal_usb_dev_req_resp_t;
 152      =2  
 153      =2  uint8_t ep_1_out_cb(uint8_t xdata *, uint8_t xdata *) reentrant;
 154      =2  
 155      =2  /** Callback function that is called when a class request is received.
 156      =2   *  The type of class request is determined by the interface the request is for. If interface 1 is a HID i
             -nterface the request is a HID class request.
 157      =2   *  @param std_req The complete request. 
 158      =2   *  @param data_ptr Pointer to pointer to data(descriptor struct) the function wants to send back to USB-h
             -ost
 159      =2   *  @param size Size of data the function wants to send back to USB-host
 160      =2   */
 161      =2  
 162      =2  typedef hal_usb_dev_req_resp_t (*hal_usb_cb_device_req_t)(hal_usb_device_req* device_req, uint8_t ** data_
             -ptr, uint8_t* size) reentrant;
 163      =2  
 164      =2  /** Callback function that is called when an endpoint interrupt occurs 
 165      =2   *  @param adr_ptr IN endpoint: Pointer to address containing data to send. OUT endpoint: Pointer to addre
             -ss containg data received.
 166      =2   *  @param size IN endpoint: Number of bytes to send. OUT endpoint: number of bytes received.
 167      =2   *  @retval Bit 7 Set: STALL request
 168      =2   *  @retval Bit 6 Set: NACK request
 169      =2   *  @retval Bit 5..0 : Bytes to send
 170      =2   */
 171      =2  typedef uint8_t (*hal_usb_cb_endpoint_t)(uint8_t* adr_ptr, uint8_t* size) reentrant;
 172      =2  
 173      =2  /** Callback function that is called when a resume is signalled on the bus.
 174      =2   *  A resume is signalled by the Data K state. For full-speed devices this is Differential "0". Differenti
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 20  

             -al "0": D-> Voh(main) and D+ < Vol(max).
 175      =2   */
 176      =2  
 177      =2  typedef void (*hal_usb_cb_resume_t)();
 178      =2  
 179      =2  /** Callback function that is called when a suspend condition occurs.
 180      =2   *  @param can_resume Set to 1 if the device is allowed to wake up the host controller
 181      =2   *  @see hal_usb_state_t
 182      =2   */
 183      =2  
 184      =2  typedef void (*hal_usb_cb_suspend_t)(uint8_t allow_remote_wu) reentrant;
 185      =2  
 186      =2  /** Callback function that is called when a reset condition occurs.
 187      =2   *  
 188      =2   */
 189      =2  typedef void (*hal_usb_cb_reset_t)();
 190      =2  
 191      =2  /** A struct containing variables related to the USB HAL layer 
 192      =2   *  
 193      =2   */
 194      =2  
 195      =2  typedef struct {
 196      =2      usb_descs_templ_t descs;     /**< Structure containing device, string and configuration descriptors fo
             -r a specific application */
 197      =2      uint8_t  bm_state;             /**< Bitmask containing USB state information: bitmask: 0 - is_hw_reset
             -, 1 - can signal remote wakeup, 2 - usb awake */
 198      =2      uint8_t current_config;        /**< Currently set configuration. If current_config is zero the device 
             -is not configured */
 199      =2      uint8_t current_alt_interface; /**< Currently alternative configuration. If an alternative configurati
             -on is chosen the index of the alternative configuration is stored here. */
 200      =2      hal_usb_state_t state;       /**< Enum containing USB state information as described in Chapter 9 of t
             -he USB 2.0 specification.  */
 201      =2  
 202      =2      hal_usb_cb_device_req_t device_req;
 203      =2      hal_usb_cb_reset_t      reset;
 204      =2      hal_usb_cb_resume_t     resume;
 205      =2      hal_usb_cb_suspend_t    suspend;
 206      =2  } hal_usb_t;
 207      =2  
 208      =2  /** Function for setting up the USB controller and registering the callbacks 
 209      =2   *  @param usb_disconnect Set to true to perform physical disconnect and reconnect. Make sure to enable in
             -terrupts as soon as possible after
 210      =2   *                        the call to this function.
 211      =2   *  @param device_req Pointer to function to call when a class specific request occur
 212      =2   *  @param reset Pointer to function to call when USB controller detects a reset
 213      =2   *  @param resume Pointer to function to call when USB controller detects a resume
 214      =2   *  @param suspend Pointer to function to call when USB controller detects a suspend
 215      =2   */
 216      =2  void hal_usb_init(
 217      =2      bool usb_disconnect,
 218      =2      hal_usb_cb_device_req_t device_req,
 219      =2      hal_usb_cb_reset_t      reset,
 220      =2      hal_usb_cb_resume_t     resume,
 221      =2      hal_usb_cb_suspend_t    suspend);
 222      =2  
 223      =2  /** Function to send a packet to host (IN endpoint)
 224      =2   *  @param ep_in_num IN endpointer number
 225      =2   *  @param buffer Pointer to buffer containing data to send
 226      =2   *  @param bytes_to_send Number of bytes to send.
 227      =2   */
 228      =2  void hal_usb_send_data(uint8_t ep_in_num, uint8_t* buffer, uint8_t bytes_to_send);
 229      =2  
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 21  

 230      =2  /** Function to register callbacks for given endpoints 
 231      =2   *  To register a callback one have to have a function with an argument list equal to usb_endpoint_cb_t.
 232      =2   *  @param ep_num Endpoint number. If MSB is set it indicates this is an IN endpoint.
 233      =2   *  @param ep_size The maximum size of one packet for this endpoint
 234      =2   *  @param endpoint_isr Pointer to function that is called when host issues a request on the given endpoin
             -t. Set to 0 to unregister function.
 235      =2   */
 236      =2  void hal_usb_endpoint_config(uint8_t ep_num, uint8_t ep_size, hal_usb_cb_endpoint_t endpoint_isr);
 237      =2  
 238      =2  /** Function to stall or unstall an endpoint
 239      =2   *  @param ep_num Endpoint number. If MSB is set it indicates this is an IN endpoint.
 240      =2   *  @param stall 1 - stall the endpoint. 0 - unstall the endpoint.
 241      =2   */
 242      =2  void hal_usb_endpoint_stall(uint8_t ep_num, bool stall);
 243      =2  
 244      =2  /** Function returning the current state of the USB controller
 245      =2   *  @see usb_stat_t
 246      =2   */
 247      =2  hal_usb_state_t hal_usb_get_state();
 248      =2  
 249      =2  /** Function returning the assigned address for the device */
 250      =2  uint8_t hal_usb_get_address();
 251      =2  
 252      =2  /** Function to initiate a remote wakeup of the USB host */
 253      =2  void hal_usb_wakeup();
 254      =2  
 255      =2  /** Function to initiate a <b>hardware reset</b> of the USB-controller */
 256      =2  void hal_usb_reset();
 257      =2  
 258      =2  /** Function disconnecting the USB-controller from the USB bus  */
 259      =2  void hal_usb_bus_disconnect();
 260      =2  
 261      =2  /** Function connecting the USB-controller to the USB bus */
 262      =2  void hal_usb_bus_connect();
 263      =2  
 264      =2  /** Function stopping the clock to the usb controller or by other means powers it down */
 265      =2  void hal_usb_sleep();
 266      =2  
 267      =2  extern hal_usb_t g_hal_usb;
 268      =2  
 269      =2  #endif //  HAL_USB_H__
 270      =2  /** @} */
  24      =1  
  25      =1  #define USB_ENDPOINT_IN_COUNT 5
  26      =1  #define USB_ENDPOINT_OUT_COUNT 5
  27      =1  
  28      =1  #define USB_EP0_HSNAK() do { ep0cs = 0x02; } while(0)
  29      =1  #define USB_EP0_STALL() do { ep0cs = 0x11; } while(0) // Set both DSTALL and STALL when we want to stall a
             - request during a SETUP transaction
  30      =1  #define USB_EP0_DSTALL() do { ep0cs |= 0x10; } while(0)
  31      =1  
  32      =1  #define INT_SUDAV    0x00
  33      =1  #define INT_SOF      0x04
  34      =1  #define INT_SUTOK    0x08
  35      =1  #define INT_SUSPEND  0x0C
  36      =1  #define INT_USBRESET 0x10
  37      =1  #define INT_EP0IN    0x18
  38      =1  #define INT_EP0OUT   0x1C
  39      =1  #define INT_EP1IN    0x20
  40      =1  #define INT_EP1OUT   0x24
  41      =1  #define INT_EP2IN    0x28
  42      =1  #define INT_EP2OUT   0x2C
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 22  

  43      =1  #define INT_EP3IN    0x30
  44      =1  #define INT_EP3OUT   0x34
  45      =1  #define INT_EP4IN    0x38
  46      =1  #define INT_EP4OUT   0x3C
  47      =1  #define INT_EP5IN    0x40
  48      =1  #define INT_EP5OUT   0x44
  49      =1  
  50      =1  #define BM_REQUEST_TYPE  0
  51      =1  #define B_REQUEST        1
  52      =1  #define W_VALUE          2
  53      =1  #define W_INDEX          4
  54      =1  #define W_LENGTH         6
  55      =1  
  56      =1  typedef struct
  57      =1  {
  58      =1      uint8_t *data_ptr;
  59      =1      uint8_t data_size;
  60      =1      uint8_t pkt_size;
  61      =1  } packetizer_t;
  62      =1  
  63      =1  #endif
   7          #include "hal_usb.h"
   1      =1  /* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
   2      =1   *
   3      =1   * The information contained herein is confidential property of Nordic 
   4      =1   * Semiconductor ASA.Terms and conditions of usage are described in detail 
   5      =1   * in NORDIC SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =1   *
   7      =1   * Licensees are granted free, non-transferable use of the information. NO
   8      =1   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =1   * the file.
  10      =1   *              
  11      =1   * $LastChangedRevision: 181 $
  12      =1   */
  13      =1  
  14      =1  /** @file
  15      =1   * @brief Interface for the USB device controller.
  16      =1   *
  17      =1   * The header file must define the following type-defined structs:
  18      =1   *  - hal_usb_conf_desc_templ_t
  19      =1   *  - hal_usb_string_desc_templ_t
  20      =1   *  - hal_usb_dev_desc_templ_t
  21      =1   *  .
  22      =1   * And the following global variables:
  23      =1   *  - g_usb_string_desc
  24      =1   *  - g_usb_conf_desc
  25      =1   *  - g_usb_dev_desc
  26      =1   *
  27      =1   * @defgroup hal_nrf24lu1p_hal_usb Universal Serial Bus (hal_usb)
  28      =1   * @{
  29      =1   * @ingroup hal_nrf24lu1p
  30      =1   *
  31      =1   * <h1>Control Transfer Functionality</h1>
  32      =1   *
  33      =1   * <h2>Descriptor Requests</h2>
  34      =1   * The module handles the following <b>descriptor requests</b>:
  35      =1   * - Device
  36      =1   * - Configuration
  37      =1   * - String
  38      =1   *
  39      =1   * It does <b>not</b> support (replies with STALL to USB host controller):
  40      =1   * - Interface
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 23  

  41      =1   * - DeviceQual
  42      =1   * - OtherSpeedConf
  43      =1   * - InterfacePower
  44      =1   * 
  45      =1   * All other descriptor requests (HID, ...) are made available to the application code through the hal_usb
             -_cb_device_req_t callback.
  46      =1   *
  47      =1   * The module does <b>not</b> support SetDescriptor requests
  48      =1   *
  49      =1   * <h2>Feature Requests</h2>
  50      =1   *
  51      =1   * The module handles the following feature requests:
  52      =1   * -  DeviceRemoteWakeup
  53      =1   * -  EndpointHalt
  54      =1   * 
  55      =1   * It does <b>not</b> support (replies with STALL to USB host controller) any other feature requests yet
  56      =1   *
  57      =1   * <h2>Configuration Requests</h2>
  58      =1   *
  59      =1   * The module do only support setting configuration 0 (sets the adressed state) and 1. Other configuration
             -s replies with STALL. Several configurations for a device is not implemented.
  60      =1   * 
  61      =1   * <h2>Alternative Interface Requests</h2>
  62      =1   *
  63      =1   * Setting and getting alternative interfaces are not supported (replies with STALL to USB host controller
             -)
  64      =1   * 
  65      =1   * <h2>Sync Frame Requests</h2>
  66      =1   * Not supported
  67      =1   * 
  68      =1   * <h2>Class Specific Requests</h2>
  69      =1   * All class specific requests are made available to the application code through the hal_usb_cb_device_re
             -q_t callback. 
  70      =1   *
  71      =1   * <h1>Endpoint Functionality</h1>
  72      =1   * All available IN and OUT endpoints are avialable to the application through the hal_usb_send_packet, ha
             -l_usb_receive_packet functions and the callbacks registered for the endpoint. The callback functions are called when the
             - host replies with an ACK for having received a packet or when the host has sent an OUT packet. 
  73      =1   * 
  74      =1   * Isochronos endpoints are not supported in this version of USB HAL.
  75      =1   */
  76      =1  
  77      =1  #ifndef HAL_USB_H__
           =1 #define HAL_USB_H__
           =1 
           =1 #include <stdint.h>
           =1 #include <stdbool.h>
           =1 
           =1 #include "hal_usb_desc.h"
           =1 #include "config.h" 
           =1 #include "usb_desc_bulk.h"
           =1 
           =1 #ifndef USB_DESC_TEMPLATE
           =1 #error "USB_DESC_TEMPLATE not defined. Please include a file with g_usb_string_desc, g_usb_conf_desc and g
             -_usb_dev_desc defined" 
           =1 #endif
           =1 
           =1 #define USB_BM_STATE_CONFIGURED 0x01
           =1 #define USB_BM_STATE_ALLOW_REMOTE_WAKEUP 0x02
           =1 #define USB_BM_STATE_HOST_WU     0x04
           =1 
           =1 /** An enum describing the USB state
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 24  

           =1  * 
           =1  *  The states described in this enum are found in Chapter 9 of the USB 2.0 specification
           =1  */
           =1 
           =1 typedef enum  { 
           =1     ATTACHED,   /**< Device is attached to the USB, but is not powered */
           =1     POWERED,    /**< Device is attached to the USB and powered */
           =1     DEFAULT,    /**< Device is attached to the USB and powered and has been reset, but has not been assign
             -ed a unique address */
           =1     ADDRESSED,  /**< Device is attached to the USB, powered, has been reset, and a unique device address h
             -as been assigned. Device is not configured */
           =1     CONFIGURED, /**< Device is attached to the USB, powered, has been reset, has a unique address, is conf
             -igured and is not suspended */
           =1     SUSPENDED   /**< Device is, at a minimum, attached to the USB and is powered and has not seen bus acti
             -vity for 3ms. It may also have a unique address and be configured for use. However, because the device is suspended, the
             - host may not use the device configuration */
           =1 } hal_usb_state_t;
           =1 
           =1 /** Structure containing the USB standard request
           =1  *  See Chapter 9 USB Device Framework in the USB 2.0 specification.
           =1  */
           =1 
           =1 typedef struct {
           =1     uint8_t  bmRequestType; /**< Bitmapped field identifying the characteristics of the request.
           =1                         - D7: Data transfer direction 
           =1                         - 0 = Host-to-device
           =1                         - 1 = Device-to-host
           =1 
           =1                         - D6..5: Type
           =1                         - 0 = Standard
           =1                         - 1 = Class
           =1                         - 2 = Vendor
           =1                         - 3 = Reserved
           =1 
           =1                         - D4..0: Recipient
           =1                         - 0 = Device
           =1                         - 1 = Interface
           =1                         - 2 = Endpoint
           =1                         - 3 = Other
           =1                         - 4..31 = Reserved
           =1                           */
           =1     uint8_t  bRequest;       /**< Field specifying request. bmRequestType(Type) modifies the meaning of th
             -is field. */
           =1 
           =1     uint8_t wValueMsb;      /**< Field used to pass a parameter to the device, specific to the request. MS
             -B*/
           =1     uint8_t wValueLsb;      /**< Field used to pass a parameter to the device, specific to the request. LS
             -B*/
           =1     uint8_t wIndex;         /**< Field used to pass a parameter to the device, specific to the request. */
           =1     uint8_t wLength;        /**< Field used to specify length of the data transferred during the second ph
             -ase of the control transfer. Direction of data transfer given by bmRequestType(Direction). If field is zero there is no 
             -data transfer phase. */
           =1 //    void* misc_data;
           =1 } hal_usb_device_req;
           =1 
           =1 /** An enum describing which reply to send to the control request
           =1  */
           =1 
           =1 typedef enum {
           =1     STALL,         /**< Respond with STALL */
           =1     NAK,           /**< Respond with NAK   */
           =1     ACK,           /**< Respond with ACK (if this is an OUT request) */
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 25  

           =1     NO_RESPONSE,   /**< Do not respond */
           =1     DATA,          /**< Data is available */
           =1     EMPTY_RESPONSE /**< Send an empty response */
           =1 } hal_usb_dev_req_resp_t;
           =1 
           =1 uint8_t ep_1_out_cb(uint8_t xdata *, uint8_t xdata *) reentrant;
           =1 
           =1 /** Callback function that is called when a class request is received.
           =1  *  The type of class request is determined by the interface the request is for. If interface 1 is a HID i
             -nterface the request is a HID class request.
           =1  *  @param std_req The complete request. 
           =1  *  @param data_ptr Pointer to pointer to data(descriptor struct) the function wants to send back to USB-h
             -ost
           =1  *  @param size Size of data the function wants to send back to USB-host
           =1  */
           =1 
           =1 typedef hal_usb_dev_req_resp_t (*hal_usb_cb_device_req_t)(hal_usb_device_req* device_req, uint8_t ** data_
             -ptr, uint8_t* size) reentrant;
           =1 
           =1 /** Callback function that is called when an endpoint interrupt occurs 
           =1  *  @param adr_ptr IN endpoint: Pointer to address containing data to send. OUT endpoint: Pointer to addre
             -ss containg data received.
           =1  *  @param size IN endpoint: Number of bytes to send. OUT endpoint: number of bytes received.
           =1  *  @retval Bit 7 Set: STALL request
           =1  *  @retval Bit 6 Set: NACK request
           =1  *  @retval Bit 5..0 : Bytes to send
           =1  */
           =1 typedef uint8_t (*hal_usb_cb_endpoint_t)(uint8_t* adr_ptr, uint8_t* size) reentrant;
           =1 
           =1 /** Callback function that is called when a resume is signalled on the bus.
           =1  *  A resume is signalled by the Data K state. For full-speed devices this is Differential "0". Differenti
             -al "0": D-> Voh(main) and D+ < Vol(max).
           =1  */
           =1 
           =1 typedef void (*hal_usb_cb_resume_t)();
           =1 
           =1 /** Callback function that is called when a suspend condition occurs.
           =1  *  @param can_resume Set to 1 if the device is allowed to wake up the host controller
           =1  *  @see hal_usb_state_t
           =1  */
           =1 
           =1 typedef void (*hal_usb_cb_suspend_t)(uint8_t allow_remote_wu) reentrant;
           =1 
           =1 /** Callback function that is called when a reset condition occurs.
           =1  *  
           =1  */
           =1 typedef void (*hal_usb_cb_reset_t)();
           =1 
           =1 /** A struct containing variables related to the USB HAL layer 
           =1  *  
           =1  */
           =1 
           =1 typedef struct {
           =1     usb_descs_templ_t descs;     /**< Structure containing device, string and configuration descriptors fo
             -r a specific application */
           =1     uint8_t  bm_state;             /**< Bitmask containing USB state information: bitmask: 0 - is_hw_reset
             -, 1 - can signal remote wakeup, 2 - usb awake */
           =1     uint8_t current_config;        /**< Currently set configuration. If current_config is zero the device 
             -is not configured */
           =1     uint8_t current_alt_interface; /**< Currently alternative configuration. If an alternative configurati
             -on is chosen the index of the alternative configuration is stored here. */
           =1     hal_usb_state_t state;       /**< Enum containing USB state information as described in Chapter 9 of t
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 26  

             -he USB 2.0 specification.  */
           =1 
           =1     hal_usb_cb_device_req_t device_req;
           =1     hal_usb_cb_reset_t      reset;
           =1     hal_usb_cb_resume_t     resume;
           =1     hal_usb_cb_suspend_t    suspend;
           =1 } hal_usb_t;
           =1 
           =1 /** Function for setting up the USB controller and registering the callbacks 
           =1  *  @param usb_disconnect Set to true to perform physical disconnect and reconnect. Make sure to enable in
             -terrupts as soon as possible after
           =1  *                        the call to this function.
           =1  *  @param device_req Pointer to function to call when a class specific request occur
           =1  *  @param reset Pointer to function to call when USB controller detects a reset
           =1  *  @param resume Pointer to function to call when USB controller detects a resume
           =1  *  @param suspend Pointer to function to call when USB controller detects a suspend
           =1  */
           =1 void hal_usb_init(
           =1     bool usb_disconnect,
           =1     hal_usb_cb_device_req_t device_req,
           =1     hal_usb_cb_reset_t      reset,
           =1     hal_usb_cb_resume_t     resume,
           =1     hal_usb_cb_suspend_t    suspend);
           =1 
           =1 /** Function to send a packet to host (IN endpoint)
           =1  *  @param ep_in_num IN endpointer number
           =1  *  @param buffer Pointer to buffer containing data to send
           =1  *  @param bytes_to_send Number of bytes to send.
           =1  */
           =1 void hal_usb_send_data(uint8_t ep_in_num, uint8_t* buffer, uint8_t bytes_to_send);
           =1 
           =1 /** Function to register callbacks for given endpoints 
           =1  *  To register a callback one have to have a function with an argument list equal to usb_endpoint_cb_t.
           =1  *  @param ep_num Endpoint number. If MSB is set it indicates this is an IN endpoint.
           =1  *  @param ep_size The maximum size of one packet for this endpoint
           =1  *  @param endpoint_isr Pointer to function that is called when host issues a request on the given endpoin
             -t. Set to 0 to unregister function.
           =1  */
           =1 void hal_usb_endpoint_config(uint8_t ep_num, uint8_t ep_size, hal_usb_cb_endpoint_t endpoint_isr);
           =1 
           =1 /** Function to stall or unstall an endpoint
           =1  *  @param ep_num Endpoint number. If MSB is set it indicates this is an IN endpoint.
           =1  *  @param stall 1 - stall the endpoint. 0 - unstall the endpoint.
           =1  */
           =1 void hal_usb_endpoint_stall(uint8_t ep_num, bool stall);
           =1 
           =1 /** Function returning the current state of the USB controller
           =1  *  @see usb_stat_t
           =1  */
           =1 hal_usb_state_t hal_usb_get_state();
           =1 
           =1 /** Function returning the assigned address for the device */
           =1 uint8_t hal_usb_get_address();
           =1 
           =1 /** Function to initiate a remote wakeup of the USB host */
           =1 void hal_usb_wakeup();
           =1 
           =1 /** Function to initiate a <b>hardware reset</b> of the USB-controller */
           =1 void hal_usb_reset();
           =1 
           =1 /** Function disconnecting the USB-controller from the USB bus  */
           =1 void hal_usb_bus_disconnect();
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 27  

           =1 
           =1 /** Function connecting the USB-controller to the USB bus */
           =1 void hal_usb_bus_connect();
           =1 
           =1 /** Function stopping the clock to the usb controller or by other means powers it down */
           =1 void hal_usb_sleep();
           =1 
           =1 extern hal_usb_t g_hal_usb;
           =1 
           =1 #endif //  HAL_USB_H__
 270      =1  /** @} */
   8          #include "hal_usb_desc.h"
   1      =1  /* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
   2      =1   *
   3      =1   * The information contained herein is confidential property of Nordic 
   4      =1   * Semiconductor ASA.Terms and conditions of usage are described in detail 
   5      =1   * in NORDIC SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =1   *
   7      =1   * Licensees are granted free, non-transferable use of the information. NO
   8      =1   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =1   * the file.
  10      =1   *              
  11      =1   * $LastChangedRevision: 133 $
  12      =1   */
  13      =1  
  14      =1  /** @file
  15      =1  * @brief This file contain structures and constants defined in Chapter 9 of the USB 2.0 standard
  16      =1   */
  17      =1  
  18      =1  #ifndef HAL_USB_DESC_H__
           =1 #define HAL_USB_DESC_H__
           =1 
           =1 #include <stdint.h>
           =1 
           =1 // Standard request codes
           =1 #define USB_REQ_GET_STATUS         0x00
           =1 #define USB_REQ_CLEAR_FEATURE      0x01
           =1 #define USB_REQ_RESERVED_1         0x02
           =1 #define USB_REQ_SET_FEATURE        0x03
           =1 #define USB_REQ_RESERVED_2         0x04
           =1 #define USB_REQ_SET_ADDRESS        0x05
           =1 #define USB_REQ_GET_DESCRIPTOR     0x06
           =1 #define USB_REQ_SET_DESCRIPTOR     0x07
           =1 #define USB_REQ_GET_CONFIGURATION  0x08
           =1 #define USB_REQ_SET_CONFIGURATION  0x09
           =1 #define USB_REQ_GET_INTERFACE      0x0a
           =1 #define USB_REQ_SET_INTERFACE      0x0b
           =1 #define USB_REQ_SYNCH_FRAME        0x0c
           =1 
           =1 // Descriptor types
           =1 #define USB_DESC_DEVICE           0x01
           =1 #define USB_DESC_CONFIGURATION    0x02
           =1 #define USB_DESC_STRING           0x03
           =1 #define USB_DESC_INTERFACE        0x04
           =1 #define USB_DESC_ENDPOINT         0x05
           =1 #define USB_DESC_DEVICE_QUAL      0x06
           =1 #define USB_DESC_OTHER_SPEED_CONF 0x07
           =1 #define USB_DESC_INTERFACE_POWER  0x08
           =1 #define USB_DESC_OTG              0x09
           =1 #define USB_DESC_DEBUG            0x0A
           =1 #define USB_DESC_INTERFACE_ASSOC  0x0B
           =1 
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 28  

           =1 #define USB_ENDPOINT_TYPE_CONTROL           0x00
           =1 #define USB_ENDPOINT_TYPE_ISOCHRONOUS       0x01
           =1 #define USB_ENDPOINT_TYPE_BULK              0x02
           =1 #define USB_ENDPOINT_TYPE_INTERRUPT         0x03
           =1 
           =1 // USB device classes
           =1 #define USB_DEVICE_CLASS_RESERVED               0x00
           =1 #define USB_DEVICE_CLASS_AUDIO                  0x01
           =1 #define USB_DEVICE_CLASS_COMMUNICATIONS         0x02
           =1 #define USB_DEVICE_CLASS_HUMAN_INTERFACE        0x03
           =1 #define USB_DEVICE_CLASS_MONITOR                0x04
           =1 #define USB_DEVICE_CLASS_PHYSICAL_INTERFACE     0x05
           =1 #define USB_DEVICE_CLASS_POWER                  0x06
           =1 #define USB_DEVICE_CLASS_PRINTER                0x07
           =1 #define USB_DEVICE_CLASS_STORAGE                0x08
           =1 #define USB_DEVICE_CLASS_HUB                    0x09
           =1 #define USB_DEVICE_CLASS_APPLICATION_SPECIFIC   0xFE
           =1 #define USB_DEVICE_CLASS_VENDOR_SPECIFIC        0xFF
           =1 
           =1 
           =1 #define USB_CLASS_DESCRIPTOR_HID    0x21
           =1 #define USB_CLASS_DESCRIPTOR_REPORT 0x22
           =1 #define USB_CLASS_DESCRIPTOR_PHYSICAL_DESCRIPTOR 0x23
           =1 
           =1 #define USB_DEVICE_REMOTE_WAKEUP    0x01
           =1 #define USB_ENDPOINT_HALT           0x00
           =1 #define USB_TEST_MODE               0x02
           =1 
           =1 typedef struct {
           =1      volatile uint8_t bLength;
           =1      volatile uint8_t bDescriptorType;
           =1      volatile uint16_t bcdUSB;
           =1      volatile uint8_t bDeviceClass;
           =1      volatile uint8_t bDeviceSubClass;
           =1      volatile uint8_t bDeviceProtocol;
           =1      volatile uint8_t bMaxPacketSize0;
           =1      volatile uint16_t idVendor;
           =1      volatile uint16_t idProduct;
           =1      volatile uint16_t bcdDevice;
           =1      volatile uint8_t iManufacturer;
           =1      volatile uint8_t iProduct;
           =1      volatile uint8_t iSerialNumber;
           =1      volatile uint8_t bNumConfigurations;
           =1 } hal_usb_dev_desc_t;
           =1 
           =1 typedef struct {
           =1      volatile uint8_t bLength;
           =1      volatile uint8_t bDescriptorType;
           =1      volatile uint16_t wTotalLength;
           =1      volatile uint8_t bNumInterfaces;
           =1      volatile uint8_t bConfigurationValue;
           =1      volatile uint8_t iConfiguration;
           =1      volatile uint8_t bmAttributes;
           =1      volatile uint8_t bMaxPower;
           =1 } hal_usb_conf_desc_t;
           =1 
           =1 typedef struct {
           =1      volatile uint8_t bLength;
           =1      volatile uint8_t bDescriptorType;
           =1      volatile uint8_t bInterfaceNumber;
           =1      volatile uint8_t bAlternateSetting;
           =1      volatile uint8_t bNumEndpoints;
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 29  

           =1      volatile uint8_t bInterfaceClass;
           =1      volatile uint8_t bInterfaceSubClass;
           =1      volatile uint8_t bInterfaceProtocol;
           =1      volatile uint8_t iInterface;
           =1 } hal_usb_if_desc_t;
           =1 
           =1 typedef struct {
           =1      volatile uint8_t bLength;
           =1      volatile uint8_t bDescriptorType;
           =1      volatile uint8_t bEndpointAddress;
           =1      volatile uint8_t bmAttributes;
           =1      volatile uint16_t wMaxPacketSize;
           =1      volatile uint8_t bInterval;
           =1 } hal_usb_ep_desc_t;
           =1 
           =1 typedef struct {
           =1     volatile uint8_t bLength;
           =1     volatile uint8_t bDescriptorType;
           =1     volatile uint16_t bcdHID;
           =1     volatile uint8_t bCountryCode;
           =1     volatile uint8_t bNumDescriptors;
           =1     volatile uint8_t bDescriptorType2;
           =1     volatile uint16_t wDescriptorLength;
           =1 } hal_usb_hid_desc_t;
           =1 
           =1 typedef struct {
           =1      volatile uint8_t* desc;
           =1 } hal_usb_string_desc_t;
           =1 
           =1 typedef struct {
           =1      volatile uint8_t bLength;
           =1      volatile uint8_t bDescriptorType;
           =1 } hal_usb_common_desc_t;
           =1 
           =1 
           =1 #endif // HAL_USB_DESC_H__
   9          #include "usb_cmds.h"
   1      =1  /* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
   2      =1   *
   3      =1   * The information contained herein is confidential property of Nordic 
   4      =1   * Semiconductor ASA.Terms and conditions of usage are described in detail 
   5      =1   * in NORDIC SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =1   *
   7      =1   * Licensees are granted free, non-transferable use of the information. NO
   8      =1   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =1   * the file.
  10      =1   *              
  11      =1   * $LastChangedRevision: 5718 $
  12      =1   */
  13      =1  
  14      =1  /** @file
  15      =1   * Definition of supported USB commands
  16      =1   *
  17      =1   */
  18      =1  #ifndef USB_CMDS_H__
  19      =1  #define USB_CMDS_H__
  20      =1  
  21      =1  typedef enum
  22      =1  {
  23      =1    CMD_FIRMWARE_VERSION = 1,
  24      =1    CMD_FLASH_WRITE_INIT,         // Eigth 64 bytes bulk packets <- PC follow after this command
  25      =1    CMD_FLASH_READ,
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 30  

  26      =1    CMD_FLASH_ERASE_PAGE,
  27      =1    CMD_FLASH_SET_PROTECTED,
  28      =1    CMD_FLASH_SELECT_HALF
  29      =1  } usb_command_t;
  30      =1  
  31      =1  #endif // USB_CMDS_H__
  10          #include "config.h"
   1      =1  /* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
   2      =1   *
   3      =1   * The information contained herein is confidential property of Nordic 
   4      =1   * Semiconductor ASA.Terms and conditions of usage are described in detail 
   5      =1   * in NORDIC SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =1   *
   7      =1   * Licensees are granted free, non-transferable use of the information. NO
   8      =1   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =1   * the file.
  10      =1   *              
  11      =1   * $LastChangedRevision: 5718 $
  12      =1   */
  13      =1  
  14      =1  /** @file
  15      =1   * Configuration file for bootloader
  16      =1   *
  17      =1   */
  18      =1  #ifndef CONFIG_H__
           =1 #define CONFIG_H__
           =1 
           =1 #define FLASH_PAGE_SIZE     512U
           =1 #define MAX_PACKET_SIZE_EP0 32
           =1 #define USB_EP1_SIZE        64
           =1 #define FLASH_SIZE          (32U*1024U)
           =1 #define NUM_FLASH_PAGES     FLASH_SIZE/FLASH_PAGE_SIZE
           =1 
           =1 #endif // CONFIG_H__
  11            
  12          #include "cklf.h"   
   1      =1  /* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
   2      =1   *
   3      =1   * The information contained herein is confidential property of Nordic 
   4      =1   * Semiconductor ASA.Terms and conditions of usage are described in detail 
   5      =1   * in NORDIC SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =1   *
   7      =1   * Licensees are granted free, non-transferable use of the information. NO
   8      =1   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =1   * the file.
  10      =1   *              
  11      =1   * $LastChangedRevision: 171 $
  12      =1   */
  13      =1  
  14      =1  /** @file
  15      =1   * @brief Interface functions for the low frequency clock module.
  16      =1   * @defgroup hal_nrf24lu1p_cklf Low frequency clock (cklf)
  17      =1   * @{
  18      =1   * @ingroup hal_nrf24lu1p
  19      =1   * in the nRF24LU1
  20      =1   */
  21      =1  #ifndef CKLF_H__
  22      =1  #define CKLF_H__
  23      =1  
  24      =1  #include <stdint.h>
   1      =2  /* Copyright (c) 2007 Nordic Semiconductor. All Rights Reserved.
   2      =2   *
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 31  

   3      =2   * The information contained herein is property of Nordic Semiconductor ASA.
   4      =2   * Terms and conditions of usage are described in detail in NORDIC
   5      =2   * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =2   *
   7      =2   * Licensees are granted free, non-transferable use of the information. NO
   8      =2   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =2   * the file.
  10      =2   *
  11      =2   * $LastChangedRevision: 186 $
  12      =2   */
  13      =2  
  14      =2  /** @file
  15      =2   * Type definitions for firmware projects developed at Nordic Semiconductor.
  16      =2   *
  17      =2   * Standard storage classes in C, such as @c char, @c int, and @c long, are not always
  18      =2   * interpreted in the same way by the compiler. The types here are defined by their
  19      =2   * bit length and signed/unsigned property, as their names indicate. The correlation
  20      =2   * between the name and properties of the storage class should be true, regardless of
  21      =2   * the compiler being used.
  22      =2   */
  23      =2  
  24      =2  #ifndef __STDINT_H__
           =2 #define __STDINT_H__
           =2 
           =2 #ifdef __C51__
           =2 
           =2 typedef unsigned char uint8_t;        ///< 8 bit unsigned int
           =2 
           =2 typedef signed char int8_t;          ///< 8 bit signed int
           =2 
           =2 typedef unsigned int uint16_t;        ///< 16 bit unsigned int
           =2 
           =2 typedef signed int int16_t;          ///< 16 bit signed int
           =2 
           =2 typedef unsigned long uint32_t;       ///< 32 bit unsigned int
           =2 
           =2 typedef signed long int32_t;         ///< 32 bit signed int
           =2 
           =2 #endif // __C51__
           =2 
           =2 #ifndef NULL
           =2 #define NULL (void*)0
           =2 #endif
           =2 
           =2 #endif // __STDINT_H__
  25      =1  
  26      =1  /** Function to write to the low frequency clock interface (CKLF) in nRF24LU1.
  27      =1   * @param addr the address of the register to write
  28      =1   * @param val the value to write to the register
  29      =1   */
  30      =1  void cklf_regxc_write(uint8_t addr, uint16_t val);
  31      =1  
  32      =1  /** Function to read the low frequency clock interface (CKLF) in nRF24LU1.
  33      =1   * @param addr the address of the register to read
  34      =1   * @return the value read
  35      =1   */
  36      =1  uint16_t cklf_regxc_read(uint8_t addr);
  37      =1  
  38      =1  /** Function to disable the RTC.
  39      =1   * This function should be called before reading values from the RTC counter.
  40      =1   */
  41      =1  void cklf_rtc_disable(void);
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 32  

  42      =1  
  43      =1  /** Function to initialize the RTC.
  44      =1   *  @param cnt_h The upper 8 bits of the 24 bit value to load into the RTC latch
  45      =1   *  @param cnt_l The lower 16 bits of the 24 bit value to load into the RTC latch
  46      =1   */
  47      =1  void cklf_rtc_init(uint8_t cnt_h, uint16_t cnt_l);
  48      =1  
  49      =1  /** Function to read the lower 16 bits of the RTC counter.
  50      =1   *  To ensure consistency between the return value of this function and
  51      =1   *  cklf_rtc_read_msb the RTC should be disabled before calling these functions.
  52      =1   *  @return The lower 16 bits of the RTC counter.
  53      =1   */
  54      =1  uint16_t cklf_rtc_read_lsw(void);
  55      =1  
  56      =1  /** Function to read the upper 8 bits of the RTC counter.
  57      =1   *  To ensure consistency between the return value of this function and
  58      =1   *  cklf_rtc_read_lsw the RTC should be disabled before calling these functions.
  59      =1   *  @return The upper 8 bits of the RTC counter.
  60      =1   */
  61      =1  uint8_t cklf_rtc_read_msb(void);
  62      =1  
  63      =1  /** Function to wait for the RTC counter to reach 0.
  64      =1   * This function enters an infinite loop polling the RTC interrupt flag. When
  65      =1   * the flag is set the flag is cleared and the function returns.
  66      =1   *
  67      =1   */
  68      =1  void cklf_rtc_wait(void);
  69      =1  
  70      =1  /** Function to initialize and enable the watchdog.
  71      =1   * @param cnt The value to load into the watchdog counter.
  72      =1   */
  73      =1  void cklf_wdog_init(uint16_t cnt);
  74      =1  
  75      =1  /** Function to reload the watchdog.
  76      =1   * This function reloads the watchdog counter with the parameter given in the
  77      =1   * hal_wdog_init function.
  78      =1   */
  79      =1  void cklf_wdog_feed(void);
  80      =1  
  81      =1  /** Function to program the GPIO wakeup functionality
  82      =1   *  @param wcon0 Value of WCON0 register (P00 - P03) 
  83      =1   *  @param wcon1 Value of WCON1 register (P04 - P07)
  84      =1   */
  85      =1  void cklf_gpio_wakeup(uint16_t wcon1, uint16_t wcon0);
  86      =1  
  87      =1  #endif // CKLF_H__
  88      =1  /** @} */
  13          #include "cpu.h"   
   1      =1  /* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
   2      =1   *
   3      =1   * The information contained herein is confidential property of Nordic 
   4      =1   * Semiconductor ASA.Terms and conditions of usage are described in detail 
   5      =1   * in NORDIC SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =1   *
   7      =1   * Licensees are granted free, non-transferable use of the information. NO
   8      =1   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =1   * the file.
  10      =1   *              
  11      =1   * $LastChangedRevision: 172 $
  12      =1   */
  13      =1  
  14      =1  /** @file
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 33  

  15      =1   * @brief CPU management functions.
  16      =1   * @defgroup hal_nrf24lu1p_cpu CPU management (cpu) 
  17      =1   * @{
  18      =1   * @ingroup hal_nrf24lu1p
  19      =1   */
  20      =1  #ifndef CPU_H__
  21      =1  #define CPU_H__
  22      =1  
  23      =1  #include <stdint.h>
   1      =2  /* Copyright (c) 2007 Nordic Semiconductor. All Rights Reserved.
   2      =2   *
   3      =2   * The information contained herein is property of Nordic Semiconductor ASA.
   4      =2   * Terms and conditions of usage are described in detail in NORDIC
   5      =2   * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =2   *
   7      =2   * Licensees are granted free, non-transferable use of the information. NO
   8      =2   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =2   * the file.
  10      =2   *
  11      =2   * $LastChangedRevision: 186 $
  12      =2   */
  13      =2  
  14      =2  /** @file
  15      =2   * Type definitions for firmware projects developed at Nordic Semiconductor.
  16      =2   *
  17      =2   * Standard storage classes in C, such as @c char, @c int, and @c long, are not always
  18      =2   * interpreted in the same way by the compiler. The types here are defined by their
  19      =2   * bit length and signed/unsigned property, as their names indicate. The correlation
  20      =2   * between the name and properties of the storage class should be true, regardless of
  21      =2   * the compiler being used.
  22      =2   */
  23      =2  
  24      =2  #ifndef __STDINT_H__
           =2 #define __STDINT_H__
           =2 
           =2 #ifdef __C51__
           =2 
           =2 typedef unsigned char uint8_t;        ///< 8 bit unsigned int
           =2 
           =2 typedef signed char int8_t;          ///< 8 bit signed int
           =2 
           =2 typedef unsigned int uint16_t;        ///< 16 bit unsigned int
           =2 
           =2 typedef signed int int16_t;          ///< 16 bit signed int
           =2 
           =2 typedef unsigned long uint32_t;       ///< 32 bit unsigned int
           =2 
           =2 typedef signed long int32_t;         ///< 32 bit signed int
           =2 
           =2 #endif // __C51__
           =2 
           =2 #ifndef NULL
           =2 #define NULL (void*)0
           =2 #endif
           =2 
           =2 #endif // __STDINT_H__
  24      =1  
  25      =1  /** Function to set the CPU in power down mode
  26      =1   *  @return This function does not return until the CPU wakens
  27      =1   */
  28      =1  void cpu_pwr_down(void);
  29      =1  
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 34  

  30      =1  /** Function to set the clock frequency of the chip
  31      =1   *  cf is the value of the CLKCTL register but only bits 4-6 are used in this
  32      =1   *  function.
  33      =1   *  @param cf The clock frequency 
  34      =1   */
  35      =1  void cpu_set_clock_frequency(uint8_t cf);
  36      =1  
  37      =1  #endif // CPU_H__
  38      =1  /** @} */
  14          
  15          #include "nordic_common.h"  
   1      =1  /* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
   2      =1   *
   3      =1   * The information contained herein is confidential property of Nordic 
   4      =1   * Semiconductor ASA.Terms and conditions of usage are described in detail 
   5      =1   * in NORDIC SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =1   *
   7      =1   * Licensees are granted free, non-transferable use of the information. NO
   8      =1   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =1   * the file.
  10      =1   *              
  11      =1   * $LastChangedRevision: 133 $
  12      =1   */
  13      =1  
  14      =1  /** @file
  15      =1   * @brief Common defines and macros for firmware developed by Nordic Semiconductor.
  16      =1   *
  17      =1   */
  18      =1  
  19      =1  #ifndef NORDIC_COMMON_H__
  20      =1  #define NORDIC_COMMON_H__
  21      =1  
  22      =1  /** Swaps the upper byte with the lower byte in a 16 bit variable */
  23      =1  //lint -emacro((572),SWAP) // Suppress warning 572 "Excessive shift value"
  24      =1  #define SWAP(x) ((((x)&0xFF)<<8)|(((x)>>8)&0xFF))
  25      =1  
  26      =1  /** The upper 8 bits of a 16 bit value */
  27      =1  #define MSB(a) ((a & 0xFF00) >> 8)
  28      =1  /** The lower 8 bits (of a 16 bit value) */
  29      =1  #define LSB(a) ((a & 0xFF))
  30      =1  
  31      =1  /** Leaves the minimum of the two arguments */
  32      =1  #define MIN(a, b) ((a) < (b) ? (a) : (b))
  33      =1  /** Leaves the maximum of the two arguments */
  34      =1  #define MAX(a, b) ((a) < (b) ? (b) : (a))
  35      =1  
  36      =1  #define BIT_0 0x01 /**< The value of bit 0 */
  37      =1  #define BIT_1 0x02 /**< The value of bit 1 */
  38      =1  #define BIT_2 0x04 /**< The value of bit 2 */
  39      =1  #define BIT_3 0x08 /**< The value of bit 3 */
  40      =1  #define BIT_4 0x10 /**< The value of bit 4 */
  41      =1  #define BIT_5 0x20 /**< The value of bit 5 */
  42      =1  #define BIT_6 0x40 /**< The value of bit 6 */
  43      =1  #define BIT_7 0x80 /**< The value of bit 7 */
  44      =1  #define BIT_8 0x0100 /**< The value of bit 8 */
  45      =1  #define BIT_9 0x0200 /**< The value of bit 9 */
  46      =1  #define BIT_10 0x0400 /**< The value of bit 10 */
  47      =1  #define BIT_11 0x0800 /**< The value of bit 11 */
  48      =1  #define BIT_12 0x1000 /**< The value of bit 12 */
  49      =1  #define BIT_13 0x2000 /**< The value of bit 13 */
  50      =1  #define BIT_14 0x4000 /**< The value of bit 14 */
  51      =1  #define BIT_15 0x8000 /**< The value of bit 15 */
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 35  

  52      =1  
  53      =1  
  54      =1  #endif // NORDIC_COMMON_H__
  16          
  17          #include "hal_nrf.h"
   1      =1  /* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
   2      =1   *
   3      =1   * The information contained herein is confidential property of Nordic 
   4      =1   * Semiconductor ASA.Terms and conditions of usage are described in detail 
   5      =1   * in NORDIC SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =1   *
   7      =1   * Licensees are granted free, non-transferable use of the information. NO
   8      =1   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =1   * the file.
  10      =1   *              
  11      =1   * $LastChangedRevision: 133 $
  12      =1   */
  13      =1  
  14      =1  /** @file
  15      =1   * @brief Interface functions for the on-chip radio transceiver. 
  16      =1   */
  17      =1   
  18      =1  /** @defgroup hal_nrf24l01p_hal_nrf RF tranceiver (hal_nrf)
  19      =1   * @{
  20      =1   * @ingroup hal_nrf24l01p
  21      =1   * 
  22      =1   * This is the nRF24L01+ transceiver used in several Nordic Semiconductor devices.
  23      =1   * The transceiver is set up and controlled via an internal SPI interface on the chip. 
  24      =1   * The HAL for the radio transceiver hides this SPI interface from the programmer.
  25      =1   *
  26      =1   * The nRF24LE1 uses the same 2.4GHz GFSK RF transceiver with embedded protocol engine 
  27      =1   * (Enhanced ShockBurst&tm;) that is found in the nRF24L01+ single chip RF Transceiver.
  28      =1   *
  29      =1   * The RF Transceiver module is configured and operated through the RF transceiver map. 
  30      =1   * This register map is accessed by the MCU through a dedicated on-chip Serial 
  31      =1   * Peripheral interface (SPI) and is available in all power modes of the RF Transceiver 
  32      =1   * module. The register map contains all configuration registers in the RF Transceiver 
  33      =1   * and is accessible in all operation modes of the transceiver. The radio transceiver 
  34      =1   * HAL hides this register map and the usage of the internal SPI.
  35      =1   * 
  36      =1   * This HAL module contains setup functions for configurating the radio; operation functions 
  37      =1   * for controlling the radio when active and for sending and receiving data; and test 
  38      =1   * functions for setting the radio in test modes.
  39      =1   */
  40      =1  
  41      =1  #ifndef HAL_NRF_H__
  42      =1  #define HAL_NRF_H__
  43      =1  
  44      =1  #include <stdint.h>
   1      =2  /* Copyright (c) 2007 Nordic Semiconductor. All Rights Reserved.
   2      =2   *
   3      =2   * The information contained herein is property of Nordic Semiconductor ASA.
   4      =2   * Terms and conditions of usage are described in detail in NORDIC
   5      =2   * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =2   *
   7      =2   * Licensees are granted free, non-transferable use of the information. NO
   8      =2   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =2   * the file.
  10      =2   *
  11      =2   * $LastChangedRevision: 186 $
  12      =2   */
  13      =2  
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 36  

  14      =2  /** @file
  15      =2   * Type definitions for firmware projects developed at Nordic Semiconductor.
  16      =2   *
  17      =2   * Standard storage classes in C, such as @c char, @c int, and @c long, are not always
  18      =2   * interpreted in the same way by the compiler. The types here are defined by their
  19      =2   * bit length and signed/unsigned property, as their names indicate. The correlation
  20      =2   * between the name and properties of the storage class should be true, regardless of
  21      =2   * the compiler being used.
  22      =2   */
  23      =2  
  24      =2  #ifndef __STDINT_H__
           =2 #define __STDINT_H__
           =2 
           =2 #ifdef __C51__
           =2 
           =2 typedef unsigned char uint8_t;        ///< 8 bit unsigned int
           =2 
           =2 typedef signed char int8_t;          ///< 8 bit signed int
           =2 
           =2 typedef unsigned int uint16_t;        ///< 16 bit unsigned int
           =2 
           =2 typedef signed int int16_t;          ///< 16 bit signed int
           =2 
           =2 typedef unsigned long uint32_t;       ///< 32 bit unsigned int
           =2 
           =2 typedef signed long int32_t;         ///< 32 bit signed int
           =2 
           =2 #endif // __C51__
           =2 
           =2 #ifndef NULL
           =2 #define NULL (void*)0
           =2 #endif
           =2 
           =2 #endif // __STDINT_H__
  45      =1  #include <stdbool.h>
   1      =2  /* Copyright (c) 2007 Nordic Semiconductor. All Rights Reserved.
   2      =2   *
   3      =2   * The information contained herein is property of Nordic Semiconductor ASA.
   4      =2   * Terms and conditions of usage are described in detail in NORDIC
   5      =2   * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
   6      =2   *
   7      =2   * Licensees are granted free, non-transferable use of the information. NO
   8      =2   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =2   * the file.
  10      =2   *
  11      =2   * $LastChangedRevision: 230 $
  12      =2   */
  13      =2  
  14      =2  /** @file
  15      =2   * Type definitions for firmware projects developed at Nordic Semiconductor.
  16      =2   *
  17      =2   * Standard storage classes in C, such as @c char, @c int, and @c long, are not always
  18      =2   * interpreted in the same way by the compiler. The types here are defined by their
  19      =2   * bit length and signed/unsigned property, as their names indicate. The correlation
  20      =2   * between the name and properties of the storage class should be true, regardless of
  21      =2   * the compiler being used.
  22      =2   */
  23      =2  
  24      =2  #ifndef __STDBOOL_H__
           =2 #define __STDBOOL_H__
           =2 
           =2 //lint -strong(b,_Bool)
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 37  

           =2 typedef unsigned char _Bool; ///< Boolean type
           =2 
           =2 #define bool _Bool
           =2 #define true ((bool)1)
           =2 #define false ((bool)0)
           =2 #define __bool_true_false_are_defined 1
           =2 
           =2 #endif // __STDBOOL_H__
  46      =1  
  47      =1  #include "hal_nrf_reg.h"
   1      =2  /* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
   2      =2   *
   3      =2   * The information contained herein is confidential property of Nordic 
   4      =2   * Semiconductor ASA.Terms and conditions of usage are described in detail 
   5      =2   * in NORDIC SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =2   *
   7      =2   * Licensees are granted free, non-transferable use of the information. NO
   8      =2   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =2   * the file.
  10      =2   *              
  11      =2   * $LastChangedRevision: 173 $
  12      =2   */
  13      =2  
  14      =2  /** @file
  15      =2  @brief Register definitions for nRF24L01+
  16      =2  
  17      =2  @details Header file defining register mapping with bit definitions. 
  18      =2  This file is radio-chip dependent, and are included with the hal_nrf.h
  19      =2  
  20      =2  @ingroup hal_nrf24l01p_hal_nrf
  21      =2   */
  22      =2  
  23      =2  #ifndef HAL_NRF_REG_H__
  24      =2  #define HAL_NRF_REG_H__
  25      =2  
  26      =2  /** @name - Instruction Set - */
  27      =2  //@{
  28      =2  /* nRF24L01 Instruction Definitions */
  29      =2  #define W_REGISTER         0x20  /**< Register write command */
  30      =2  #define R_RX_PAYLOAD       0x61  /**< Read RX payload command */
  31      =2  #define W_TX_PAYLOAD       0xA0  /**< Write TX payload command */
  32      =2  #define FLUSH_TX           0xE1  /**< Flush TX register command */
  33      =2  #define FLUSH_RX           0xE2  /**< Flush RX register command */
  34      =2  #define REUSE_TX_PL        0xE3  /**< Reuse TX payload command */
  35      =2  #define ACTIVATE           0x50  /**< Activate features */
  36      =2  #define R_RX_PL_WID        0x60  /**< Read RX payload command */
  37      =2  #define W_ACK_PAYLOAD      0xA8  /**< Write ACK payload command */
  38      =2  #define W_TX_PAYLOAD_NOACK 0xB0  /**< Write ACK payload command */
  39      =2  #define NOP                0xFF  /**< No Operation command, used for reading status register */
  40      =2  //@}
  41      =2  
  42      =2  /** @name  - Register Memory Map - */
  43      =2  //@{
  44      =2  /* nRF24L01 * Register Definitions * */
  45      =2  #define CONFIG        0x00  /**< nRF24L01 config register */
  46      =2  #define EN_AA         0x01  /**< nRF24L01 enable Auto-Acknowledge register */
  47      =2  #define EN_RXADDR     0x02  /**< nRF24L01 enable RX addresses register */
  48      =2  #define SETUP_AW      0x03  /**< nRF24L01 setup of address width register */
  49      =2  #define SETUP_RETR    0x04  /**< nRF24L01 setup of automatic retransmission register */
  50      =2  #define RF_CH         0x05  /**< nRF24L01 RF channel register */
  51      =2  #define RF_SETUP      0x06  /**< nRF24L01 RF setup register */
  52      =2  #define STATUS        0x07  /**< nRF24L01 status register */
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 38  

  53      =2  #define OBSERVE_TX    0x08  /**< nRF24L01 transmit observe register */
  54      =2  #define CD            0x09  /**< nRF24L01 carrier detect register */
  55      =2  #define RX_ADDR_P0    0x0A  /**< nRF24L01 receive address data pipe0 */
  56      =2  #define RX_ADDR_P1    0x0B  /**< nRF24L01 receive address data pipe1 */
  57      =2  #define RX_ADDR_P2    0x0C  /**< nRF24L01 receive address data pipe2 */
  58      =2  #define RX_ADDR_P3    0x0D  /**< nRF24L01 receive address data pipe3 */
  59      =2  #define RX_ADDR_P4    0x0E  /**< nRF24L01 receive address data pipe4 */
  60      =2  #define RX_ADDR_P5    0x0F  /**< nRF24L01 receive address data pipe5 */
  61      =2  #define TX_ADDR       0x10  /**< nRF24L01 transmit address */
  62      =2  #define RX_PW_P0      0x11  /**< nRF24L01 \# of bytes in rx payload for pipe0 */
  63      =2  #define RX_PW_P1      0x12  /**< nRF24L01 \# of bytes in rx payload for pipe1 */
  64      =2  #define RX_PW_P2      0x13  /**< nRF24L01 \# of bytes in rx payload for pipe2 */
  65      =2  #define RX_PW_P3      0x14  /**< nRF24L01 \# of bytes in rx payload for pipe3 */
  66      =2  #define RX_PW_P4      0x15  /**< nRF24L01 \# of bytes in rx payload for pipe4 */
  67      =2  #define RX_PW_P5      0x16  /**< nRF24L01 \# of bytes in rx payload for pipe5 */
  68      =2  #define FIFO_STATUS   0x17  /**< nRF24L01 FIFO status register */
  69      =2  #define DYNPD         0x1C  /**< nRF24L01 Dynamic payload setup */
  70      =2  #define FEATURE       0x1D  /**< nRF24L01 Exclusive feature setup */
  71      =2  
  72      =2  //@}
  73      =2  
  74      =2  /* nRF24L01 related definitions */
  75      =2  /* Interrupt definitions */
  76      =2  /* Operation mode definitions */
  77      =2  
  78      =2  /** An enum describing the radio's irq sources.
  79      =2   *
  80      =2   */
  81      =2  typedef enum {
  82      =2      HAL_NRF_MAX_RT = 4,     /**< Max retries interrupt */
  83      =2      HAL_NRF_TX_DS,          /**< TX data sent interrupt */
  84      =2      HAL_NRF_RX_DR           /**< RX data received interrupt */
  85      =2  } hal_nrf_irq_source_t;
  86      =2  
  87      =2  /* Operation mode definitions */
  88      =2  /** An enum describing the radio's power mode.
  89      =2   *
  90      =2   */
  91      =2  typedef enum {
  92      =2      HAL_NRF_PTX,            /**< Primary TX operation */
  93      =2      HAL_NRF_PRX             /**< Primary RX operation */
  94      =2  } hal_nrf_operation_mode_t;
  95      =2  
  96      =2  /** An enum describing the radio's power mode.
  97      =2   *
  98      =2   */
  99      =2  typedef enum {
 100      =2      HAL_NRF_PWR_DOWN,       /**< Device power-down */
 101      =2      HAL_NRF_PWR_UP          /**< Device power-up */
 102      =2  } hal_nrf_pwr_mode_t;
 103      =2  
 104      =2  /** An enum describing the radio's output power mode's.
 105      =2   *
 106      =2   */
 107      =2  typedef enum {
 108      =2      HAL_NRF_18DBM,          /**< Output power set to -18dBm */
 109      =2      HAL_NRF_12DBM,          /**< Output power set to -12dBm */
 110      =2      HAL_NRF_6DBM,           /**< Output power set to -6dBm  */
 111      =2      HAL_NRF_0DBM            /**< Output power set to 0dBm   */
 112      =2  } hal_nrf_output_power_t;
 113      =2  
 114      =2  /** An enum describing the radio's on-air datarate.
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 39  

 115      =2   *
 116      =2   */
 117      =2  typedef enum {
 118      =2      HAL_NRF_1MBPS,          /**< Datarate set to 1 Mbps  */
 119      =2      HAL_NRF_2MBPS,          /**< Datarate set to 2 Mbps  */
 120      =2      HAL_NRF_250KBPS         /**< Datarate set to 250 kbps*/
 121      =2  } hal_nrf_datarate_t;
 122      =2  
 123      =2  /** An enum describing the radio's CRC mode.
 124      =2   *
 125      =2   */
 126      =2  typedef enum {
 127      =2      HAL_NRF_CRC_OFF,    /**< CRC check disabled */
 128      =2      HAL_NRF_CRC_8BIT,   /**< CRC check set to 8-bit */
 129      =2      HAL_NRF_CRC_16BIT   /**< CRC check set to 16-bit */
 130      =2  } hal_nrf_crc_mode_t;
 131      =2  
 132      =2  /** An enum describing the read/write payload command.
 133      =2   *
 134      =2   */
 135      =2  typedef enum {
 136      =2      HAL_NRF_TX_PLOAD = 7,   /**< TX payload definition */
 137      =2      HAL_NRF_RX_PLOAD,        /**< RX payload definition */
 138      =2      HAL_NRF_ACK_PLOAD
 139      =2  } hal_nrf_pload_command_t;
 140      =2  
 141      =2  /** Structure containing the radio's address map.
 142      =2   * Pipe0 contains 5 unique address bytes,
 143      =2   * while pipe[1..5] share the 4 MSB bytes, set in pipe1.
 144      =2   * <p><b> - Remember that the LSB byte for all pipes have to be unique! -</b>
 145      =2   */
 146      =2  // nRF24L01 Address struct
 147      =2  
 148      =2  
 149      =2  //typedef struct {
 150      =2  //   uint8_t p0[5];            /**< Pipe0 address, 5 bytes */
 151      =2  //    uint8_t p1[5];            /**< Pipe1 address, 5 bytes, 4 MSB bytes shared for pipe1 to pipe5 */
 152      =2  //    uint8_t p2[1];            /**< Pipe2 address, 1 byte */
 153      =2  //    uint8_t p3[1];            /**< Pipe3 address, 1 byte */
 154      =2  //   uint8_t p4[1];            /**< Pipe3 address, 1 byte */
 155      =2  //   uint8_t p5[1];            /**< Pipe3 address, 1 byte */
 156      =2  //   uint8_t tx[5];            /**< TX address, 5 byte */
 157      =2  //} hal_nrf_l01_addr_map;
 158      =2  
 159      =2  
 160      =2  /** An enum describing the nRF24L01 pipe addresses and TX address.
 161      =2   *
 162      =2   */
 163      =2  typedef enum {
 164      =2      HAL_NRF_PIPE0 = 0,          /**< Select pipe0 */
 165      =2      HAL_NRF_PIPE1,              /**< Select pipe1 */
 166      =2      HAL_NRF_PIPE2,              /**< Select pipe2 */
 167      =2      HAL_NRF_PIPE3,              /**< Select pipe3 */
 168      =2      HAL_NRF_PIPE4,              /**< Select pipe4 */
 169      =2      HAL_NRF_PIPE5,              /**< Select pipe5 */
 170      =2      HAL_NRF_TX,                 /**< Refer to TX address*/
 171      =2      HAL_NRF_ALL = 0xFF          /**< Close or open all pipes*/
 172      =2                                  /**< @see hal_nrf_set_address @see hal_nrf_get_address
 173      =2                                   @see hal_nrf_open_pipe  @see hal_nrf_close_pipe */
 174      =2  } hal_nrf_address_t;
 175      =2  
 176      =2  /** An enum describing the radio's address width.
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 40  

 177      =2   *
 178      =2   */
 179      =2  typedef enum {
 180      =2      HAL_NRF_AW_3BYTES = 3,      /**< Set address width to 3 bytes */
 181      =2      HAL_NRF_AW_4BYTES,          /**< Set address width to 4 bytes */
 182      =2      HAL_NRF_AW_5BYTES           /**< Set address width to 5 bytes */
 183      =2  } hal_nrf_address_width_t;
 184      =2  
 185      =2  
 186      =2  /** @name CONFIG register bit definitions */
 187      =2  //@{
 188      =2  
 189      =2  #define MASK_RX_DR    6     /**< CONFIG register bit 6 */
 190      =2  #define MASK_TX_DS    5     /**< CONFIG register bit 5 */
 191      =2  #define MASK_MAX_RT   4     /**< CONFIG register bit 4 */
 192      =2  #define EN_CRC        3     /**< CONFIG register bit 3 */
 193      =2  #define CRCO          2     /**< CONFIG register bit 2 */
 194      =2  #define PWR_UP        1     /**< CONFIG register bit 1 */
 195      =2  #define PRIM_RX       0     /**< CONFIG register bit 0 */
 196      =2  //@}
 197      =2  
 198      =2  /** @name RF_SETUP register bit definitions */
 199      =2  //@{
 200      =2  #define PLL_LOCK      4     /**< RF_SETUP register bit 4 */
 201      =2  #define RF_DR         3     /**< RF_SETUP register bit 3 */
 202      =2  #define RF_PWR1       2     /**< RF_SETUP register bit 2 */
 203      =2  #define RF_PWR0       1     /**< RF_SETUP register bit 1 */
 204      =2  #define LNA_HCURR     0     /**< RF_SETUP register bit 0 */
 205      =2  //@}
 206      =2  
 207      =2  /* STATUS 0x07 */
 208      =2  /** @name STATUS register bit definitions */
 209      =2  //@{
 210      =2  #define RX_DR         6     /**< STATUS register bit 6 */
 211      =2  #define TX_DS         5     /**< STATUS register bit 5 */
 212      =2  #define MAX_RT        4     /**< STATUS register bit 4 */
 213      =2  #define TX_FULL       0     /**< STATUS register bit 0 */
 214      =2  //@}
 215      =2  
 216      =2  /* FIFO_STATUS 0x17 */
 217      =2  /** @name FIFO_STATUS register bit definitions */
 218      =2  //@{
 219      =2  #define TX_REUSE      6     /**< FIFO_STATUS register bit 6 */
 220      =2  #define TX_FIFO_FULL  5     /**< FIFO_STATUS register bit 5 */
 221      =2  #define TX_EMPTY      4     /**< FIFO_STATUS register bit 4 */
 222      =2  #define RX_FULL       1     /**< FIFO_STATUS register bit 1 */
 223      =2  #define RX_EMPTY      0     /**< FIFO_STATUS register bit 0 */
 224      =2  //@}
 225      =2  
 226      =2  #endif // HAL_NRF_REG_H__
 227      =2  /** @} */
  48      =1  #include "hal_nrf_hw.h"
   1      =2  /* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
   2      =2   *
   3      =2   * The information contained herein is confidential property of Nordic 
   4      =2   * Semiconductor ASA.Terms and conditions of usage are described in detail 
   5      =2   * in NORDIC SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =2   *
   7      =2   * Licensees are granted free, non-transferable use of the information. NO
   8      =2   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =2   * the file.
  10      =2   *              
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 41  

  11      =2   * $LastChangedRevision: 133 $
  12      =2   */
  13      =2  
  14      =2  /** @file
  15      =2  * @brief hal_nrf macros for nRF24LU1+
  16      =2   *
  17      =2   * @defgroup hal_nrf24lu1p_hal_nrf_hw hal_nrf_hw
  18      =2   * @{
  19      =2   * @ingroup hal_nrf24lu1p
  20      =2   *
  21      =2   */
  22      =2  
  23      =2  #ifndef HAL_NRF_LU1_H__
  24      =2  #define HAL_NRF_LU1_H__
  25      =2  #include "nrf24lu1p.h"
   1      =3  #ifndef NRF24LU1P_H
   2      =3  #define NRF24LU1P_H
   3      =3  
   4      =3  #ifdef __ICC8051__
           =3 #include <ionRF24LU1p.h>
           =3 #include <bit24lu1.h>
           =3 #endif /*__ICC8051__*/
   8      =3  
   9      =3  #ifdef __C51__
  10      =3  #include <Nordic\reg24lu1.h>
   1      =4  /*--------------------------------------------------------------------------
   2      =4   * reg24lu1.h
   3      =4   *
   4      =4   * Keil C51 header file for the Nordic Semiconductor nRF24LU1 2.4GHz RF
   5      =4   * transceiver with embedded 8051 compatible microcontroller and USB.
   6      =4   *
   7      =4   *
   8      =4   *------------------------------------------------------------------------*/
   9      =4  #ifndef __REG24LU1_H__
           =4 #define __REG24LU1_H__
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Byte Registers
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 sfr   P0           = 0x80;
           =4 sfr   SP           = 0x81;
           =4 sfr   DPL          = 0x82;
           =4 sfr   DPH          = 0x83;
           =4 sfr   DPL1         = 0x84;
           =4 sfr   DPH1         = 0x85;
           =4 sfr   PCON         = 0x87;
           =4 sfr   TCON         = 0x88;
           =4 sfr   TMOD         = 0x89;
           =4 sfr   TL0          = 0x8A;
           =4 sfr   TL1          = 0x8B;
           =4 sfr   TH0          = 0x8C;
           =4 sfr   TH1          = 0x8D;
           =4 sfr   CKCON        = 0x8E;
           =4 sfr   RFCON        = 0x90;
           =4 sfr   DPS          = 0x92;
           =4 sfr   P0DIR        = 0x94;
           =4 sfr   P0ALT        = 0x95;
           =4 sfr   S0CON        = 0x98;
           =4 sfr   S0BUF        = 0x99;
           =4 sfr   IEN2         = 0x9A;
           =4 sfr   USBCON       = 0xA0;
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 42  

           =4 sfr   CLKCTL       = 0xA3;
           =4 sfr   PWRDWN       = 0xA4;
           =4 sfr   WUCONF       = 0xA5;
           =4 sfr   INTEXP       = 0xA6;
           =4 sfr   IEN0         = 0xA8;
           =4 sfr   IP0          = 0xA9;
           =4 sfr   S0RELL       = 0xAA;
           =4 sfr   REGXH        = 0xAB;
           =4 sfr   REGXL        = 0xAC;
           =4 sfr   REGXC        = 0xAD;
           =4 sfr   RSTRES       = 0xB1;
           =4 sfr   SMDAT        = 0xB2;
           =4 sfr   SMCTL        = 0xB3;
           =4 sfr   TICKDV       = 0xB5;
           =4 sfr   IEN1         = 0xB8;
           =4 sfr   IP1          = 0xB9;
           =4 sfr   S0RELH       = 0xBA;
           =4 sfr   SSCONF       = 0xBC;
           =4 sfr   SSDATA       = 0xBD;
           =4 sfr   SSSTAT       = 0xBE;
           =4 sfr   IRCON        = 0xC0;
           =4 sfr   CCEN         = 0xC1;
           =4 sfr   CCL1         = 0xC2;
           =4 sfr   CCH1         = 0xC3;
           =4 sfr   CCL2         = 0xC4;
           =4 sfr   CCH2         = 0xC5;
           =4 sfr   CCL3         = 0xC6;
           =4 sfr   CCH3         = 0xC7;
           =4 sfr   T2CON        = 0xC8;
           =4 sfr   P0EXP        = 0xC9;
           =4 sfr   CRCL         = 0xCA;
           =4 sfr   CRCH         = 0xCB;
           =4 sfr   TL2          = 0xCC;
           =4 sfr   TH2          = 0xCD;
           =4 sfr   PSW          = 0xD0;
           =4 sfr   WDCON        = 0xD8;
           =4 sfr   USBSLP       = 0xD9;
           =4 sfr   ACC          = 0xE0;
           =4 sfr   RFDAT        = 0xE5;
           =4 sfr   RFCTL        = 0xE6;
           =4 sfr   AESCS        = 0xE8;
           =4 sfr   MD0          = 0xE9;
           =4 sfr   MD1          = 0xEA;
           =4 sfr   MD2          = 0xEB;
           =4 sfr   MD3          = 0xEC;
           =4 sfr   MD4          = 0xED;
           =4 sfr   MD5          = 0xEE;
           =4 sfr   ARCON        = 0xEF;
           =4 sfr   B            = 0xF0;
           =4 sfr   AESKIN       = 0xF1;
           =4 sfr   AESIV        = 0xF2;
           =4 sfr   AESD         = 0xF3;
           =4 sfr   AESIA1       = 0xF5;
           =4 sfr   AESIA2       = 0xF6;
           =4 sfr   FSR          = 0xF8;
           =4 sfr   FPCR         = 0xF9;
           =4 sfr   FCR          = 0xFA;
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Word Registers
           =4 //-----------------------------------------------------------------------------
           =4 
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 43  

           =4 sfr16 CC1          = 0xC2;
           =4 sfr16 CC2          = 0xC4;
           =4 sfr16 CC3          = 0xC6;
           =4 sfr16 CRC          = 0xCA;
           =4 sfr16 T2           = 0xCC;
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 /* Lint uses a trick (see co-kc51.lnt) where sbit gets treated like (expanded to) a bool.
           =4    This causes errors due to the strong type checking of _Bool (and thereby bool) that
           =4    is turned on in our implementation of stdbool.h.
           =4    Therefore, we suppress Lint warning 18 ("Redeclaration") for the sbit-s declared in this file.
           =4 */
           =4 
           =4 /*lint -e18 */
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Bit Definitions
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 /*  FSR  */
           =4 sbit  MCDIS        = FSR^7;
           =4 sbit  STP          = FSR^6;
           =4 sbit  WEN          = FSR^5;
           =4 sbit  RDYN         = FSR^4;
           =4 sbit  INFEN        = FSR^3;
           =4 sbit  RDIS         = FSR^2;
           =4 sbit  RDEND        = FSR^1;
           =4 sbit  WPEN         = FSR^0;
           =4 
           =4 /*  PSW   */
           =4 sbit  CY           = PSW^7;
           =4 sbit  AC           = PSW^6;
           =4 sbit  F0           = PSW^5;
           =4 sbit  RS1          = PSW^4;
           =4 sbit  RS0          = PSW^3;
           =4 sbit  OV           = PSW^2;
           =4 sbit  F1           = PSW^1;
           =4 sbit  P            = PSW^0;
           =4 
           =4 /*  TCON  */
           =4 sbit  TF1          = TCON^7;
           =4 sbit  TR1          = TCON^6;
           =4 sbit  TF0          = TCON^5;
           =4 sbit  TR0          = TCON^4;
           =4 sbit  IE1          = TCON^3;
           =4 sbit  IT1          = TCON^2;
           =4 sbit  IE0          = TCON^1;
           =4 sbit  IT0          = TCON^0;
           =4 
           =4 /*  S0CON  */
           =4 sbit  SM0          = S0CON^7;
           =4 sbit  SM1          = S0CON^6;
           =4 sbit  SM20         = S0CON^5;
           =4 sbit  REN0         = S0CON^4;
           =4 sbit  TB80         = S0CON^3;
           =4 sbit  RB80         = S0CON^2;
           =4 sbit  TI0          = S0CON^1;
           =4 sbit  RI0          = S0CON^0;
           =4 
           =4 /*  T2CON  */
           =4 sbit  T2PS         = T2CON^7;
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 44  

           =4 sbit  I3FR         = T2CON^6;
           =4 sbit  I2FR         = T2CON^5;
           =4 sbit  T2R1         = T2CON^4;
           =4 sbit  T2R0         = T2CON^3;
           =4 sbit  T2CM         = T2CON^2;
           =4 sbit  T2I1         = T2CON^1;
           =4 sbit  T2I0         = T2CON^0;
           =4 
           =4 /*  IEN0  */
           =4 sbit  EA           = IEN0^7;
           =4 
           =4 sbit  ET2          = IEN0^5;
           =4 sbit  ES0          = IEN0^4;
           =4 sbit  ET1          = IEN0^3;
           =4 sbit  EX1          = IEN0^2;
           =4 sbit  ET0          = IEN0^1;
           =4 sbit  EX0          = IEN0^0;
           =4 
           =4 /* IEN1  */
           =4 sbit  EXEN2        = IEN1^7;
           =4 
           =4 sbit  WUIRQ        = IEN1^5;
           =4 sbit  USB          = IEN1^4;
           =4 sbit  USBWU        = IEN1^3;
           =4 sbit  SPI          = IEN1^2;
           =4 sbit  RF           = IEN1^1;
           =4 sbit  RFSPI        = IEN1^0;
           =4 
           =4 /* IRCON */
           =4 sbit  EXF2         = IRCON^7;
           =4 sbit  TF2          = IRCON^6;
           =4 sbit  WUF          = IRCON^5;
           =4 sbit  USBF         = IRCON^4;
           =4 sbit  USBWUF       = IRCON^3;
           =4 sbit  SPIF         = IRCON^2;
           =4 sbit  RFF          = IRCON^1;
           =4 sbit  RFSPIF       = IRCON^0;
           =4 
           =4 /* USBCON */
           =4 sbit  SWRST        = USBCON^7;
           =4 sbit  WU           = USBCON^6;
           =4 sbit  SUSPEND      = USBCON^5;
           =4 sbit  IV4          = USBCON^4;
           =4 sbit  IV3          = USBCON^3;
           =4 sbit  IV2          = USBCON^2;
           =4 sbit  IV1          = USBCON^1;
           =4 sbit  IV0          = USBCON^0;
           =4 
           =4 /* PORT0 */
           =4 sbit  P00          = P0^0;
           =4 sbit  P01          = P0^1;
           =4 sbit  P02          = P0^2;
           =4 sbit  P03          = P0^3;
           =4 sbit  MCSN         = P0^3;
           =4 sbit  SCSN         = P0^3;
           =4 sbit  P04          = P0^4;
           =4 sbit  P05          = P0^5;
           =4 
           =4 /* RFCON */
           =4 sbit  RFCE         = RFCON^0;
           =4 sbit  RFCSN        = RFCON^1;
           =4 sbit  RFCKEN       = RFCON^2;
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 45  

           =4 
           =4 /* WDCON */
           =4 sbit  BD           = WDCON^7;
           =4 
           =4 /* AESCS */
           =4 sbit  GO           = AESCS^0;
           =4 sbit  DECR         = AESCS^1;
           =4 
           =4 /*lint +e18 */  /* Re-enable Lint warning 18 */
           =4 
           =4 
           =4 /* REGX commands */
           =4 #define RWD         0x00
           =4 #define WWD         0x08
           =4 #define RGTIMER     0x01
           =4 #define WGTIMER     0x09
           =4 #define RRTCLAT     0x02
           =4 #define WRTCLAT     0x0A
           =4 #define RRTC        0x03
           =4 #define WRTCDIS     0x0B
           =4 #define RWSTA0      0x04
           =4 #define WWCON0      0x0C
           =4 #define RWSTA1      0x05
           =4 #define WWCON1      0x0D
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Interrupt Vector Definitions
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 #define INTERRUPT_EXT_INT0     0   // External Interrupt0 (P0.3)
           =4 #define INTERRUPT_T0           1   // Timer0 Overflow
           =4 #define INTERRUPT_AES_RDY      2   // AES ready interrupt
           =4 #define INTERRUPT_T1           3   // Timer1 Overflow
           =4 #define INTERRUPT_UART0        4   // UART0, Receive & Transmitt interrupt
           =4 #define INTERRUPT_T2           5   // Timer2 Overflow
           =4 #define INTERRUPT_RF_RDY       8   // RF SPI ready interrupt
           =4 #define INTERRUPT_RFIRQ        9   // RF interrupt
           =4 #define INTERRUPT_SPI          10  // SPI interrupt
           =4 #define INTERRUPT_USB_WU       11  // USB wakeup interrupt
           =4 #define INTERRUPT_USB_INT      12  // USB interrupt
           =4 #define INTERRUPT_WU           13  // Internal wakeup interrupt
           =4 
           =4 //-----------------------------------------------------------------------------
           =4 // Header File Preprocessor Directive
           =4 //-----------------------------------------------------------------------------
           =4 
           =4 #endif
  11      =3  #endif /*__C51__*/
  12      =3  
  13      =3  #include "isrdef24lu1p.h"
   1      =4  #ifdef __ICC8051__
           =4 
           =4 #define EXT_INT0_ISR() \
           =4 _Pragma("vector=0x0003") \
           =4 __interrupt void ext_int0_isr(void)
           =4 
           =4 #define T0_ISR() \
           =4 _Pragma("vector=0x000b") \
           =4 __interrupt void t0_isr(void)
           =4 
           =4 #define AES_RDY_ISR() \
           =4 _Pragma("vector=0x0013") \
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 46  

           =4 __interrupt void aes_rdy_isr(void)
           =4 
           =4 #define T1_ISR() \
           =4 _Pragma("vector=0x001b") \
           =4 __interrupt void t1_isr(void)
           =4 
           =4 #define UART0_ISR() \
           =4 _Pragma("vector=0x0023") \
           =4 __interrupt void uart0_isr(void)
           =4 
           =4 #define T2_ISR() \
           =4 _Pragma("vector=0x002b") \
           =4 __interrupt void t2_isr(void)
           =4 
           =4 #define RF_RDY_ISR() \
           =4 _Pragma("vector=0x0043") \
           =4 __interrupt void rf_rdy_isr(void)
           =4 
           =4 #define NRF_ISR() \
           =4 _Pragma("vector=0x004b") \
           =4 __interrupt void nrf_isr(void)
           =4 
           =4 #define SPI_ISR() \
           =4 _Pragma("vector=0x0053") \
           =4 __interrupt void spi_isr(void)
           =4 
           =4 #define USB_WU_ISR() \
           =4 _Pragma("vector=0x005b") \
           =4 __interrupt void usb_wu_isr(void)
           =4 
           =4 #define USB_ISR() \
           =4 _Pragma("vector=0x0063") \
           =4 __interrupt void usb_isr(void)
           =4 
           =4 #define WU_ISR() \
           =4 _Pragma("vector=0x006b") \
           =4 __interrupt void wu_isr(void)
           =4 
           =4 #endif /*__ICC8051__*/
  52      =4  
  53      =4  #ifdef __C51__
  54      =4  
  55      =4  #define EXT_INT0_ISR()  void ext_int0_isr(void) interrupt INTERRUPT_EXT_INT0// External Interrupt0 (P0.3) 
             -(0x03)
  56      =4  #define T0_ISR()        void t0_isr(void)       interrupt INTERRUPT_T0      // Timer0 Overflow (0x0b)
  57      =4  #define AES_RDY_ISR()   void aes_rdy_isr(void)  interrupt INTERRUPT_AES_RDY // AES ready interrupt (0x13)
  58      =4  #define T1_ISR()        void t1_isr(void)       interrupt INTERRUPT_T1      // Timer1 Overflow (0x1b)
  59      =4  #define UART0_ISR()     void uart0_isr(void)    interrupt INTERRUPT_UART0   // UART0, Receive & Transmitt 
             -interrupt (0x0023)
  60      =4  #define T2_ISR()        void t2_isr(void)       interrupt INTERRUPT_T2      // Timer2 Overflow (0x2b)
  61      =4  #define RF_RDY_ISR()    void rf_rdy_isr(void)   interrupt INTERRUPT_RF_RDY  // RF SPI ready interrupt (0x4
             -3)
  62      =4  #define NRF_ISR()       void nrf_isr(void)      interrupt INTERRUPT_RFIRQ   // RF interrupt (0x4b)
  63      =4  #define SPI_ISR()       void spi_isr(void)      interrupt INTERRUPT_SPI     // SPI interrupt (0x53)
  64      =4  #define USB_WU_ISR()    void usb_wu_isr(void)   interrupt INTERRUPT_USB_WU  // USB wakeup interrupt (0x5b)
  65      =4  #define USB_ISR()       void usb_isr(void)      interrupt INTERRUPT_USB_INT // USB interrupt (0x63)
  66      =4  #define WU_ISR()        void wu_isr(void)       interrupt INTERRUPT_WU      // Internal wakeup interrupt (
             -0x6b)
  67      =4  
  68      =4  #endif /*__C51__*/
  69      =4  
  70      =4  
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 47  

  71      =4  
  72      =4  
  14      =3  #include "memdefs.h"
   1      =4  #ifndef MEMDEFS_H_
   2      =4  #define MEMDEFS_H_
   3      =4  
   4      =4  #ifdef __C51__
   5      =4  #define __no_init 
   6      =4  #endif /*__C51__*/
   7      =4  
   8      =4  #ifdef __ICC8051__
           =4 
           =4 #define idata __idata
           =4 #define xdata __xdata
           =4 #define code __code
           =4 #define data __data
           =4 #define pdata __pdata
           =4 #define _at_ @
           =4 #define _nop_() __no_operation()
           =4 #define bit __bit
           =4 __sfr __no_init volatile unsigned int CRC @ 0xCA;
           =4 __sfr __no_init volatile unsigned int T2  @ 0xCC;
           =4 
           =4 #define reentrant 
           =4 #if __DATA_MODEL__ == __DATA_MODEL_LARGE__
           =4   #warning "if not using large data model: reentrant procedures must be declared using IAR syntax"
           =4 #endif /*__DATA_MODEL__ == __DATA_MODEL_LARGE__*/
           =4 
           =4 #define CLKCTRL CLKFCTL
           =4 
           =4 #ifndef NULL
           =4 #define NULL _NULL
           =4 #endif /*NULL*/
           =4 
           =4 #endif /*__ICC8051__*/
  33      =4  
  34      =4  #endif /*MEMDEFS_H_*/
  15      =3  
  16      =3  #endif
  26      =2  
  27      =2  /** Macro that set radio's CSN line LOW.
  28      =2   *
  29      =2   */
  30      =2  #define CSN_LOW() do { RFCSN = 0; } while(false)
  31      =2  
  32      =2  /** Macro that set radio's CSN line HIGH.
  33      =2   *
  34      =2   */
  35      =2  #define CSN_HIGH() do { RFCSN = 1; } while(false)
  36      =2  
  37      =2  /** Macro that set radio's CE line LOW.
  38      =2   *
  39      =2   */
  40      =2  #define CE_LOW() do { RFCE = 0; } while(false)
  41      =2  
  42      =2  /** Macro that set radio's CE line HIGH.
  43      =2   *
  44      =2   */
  45      =2  #define CE_HIGH() do { RFCE = 1; } while(false)
  46      =2  
  47      =2  /** Macro for writing the radio SPI data register.
  48      =2   *
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 48  

  49      =2   */
  50      =2  #define HAL_NRF_HW_SPI_WRITE(d) do{RFDAT = d; RFSPIF = 0;} while(false)
  51      =2  
  52      =2  /** Macro for reading the radio SPI data register.
  53      =2   *
  54      =2   */
  55      =2  #define HAL_NRF_HW_SPI_READ() RFDAT
  56      =2    
  57      =2  /** Macro specifyng the radio SPI busy flag.
  58      =2   *
  59      =2   */
  60      =2  #define HAL_NRF_HW_SPI_BUSY (!RFSPIF)
  61      =2  
  62      =2  /**
  63      =2   * Pulses the CE to nRF24L01 for at least 10 us
  64      =2   */
  65      =2  #define CE_PULSE() do { \
  66      =2    uint8_t count; \
  67      =2    count = 20; \
  68      =2    CE_HIGH();  \
  69      =2    while(count--){} \
  70      =2    CE_LOW();  \
  71      =2    } while(false)
  72      =2  
  73      =2  #endif // HAL_NRF_LU1_H__
  74      =2  
  75      =2  /** @} */
  49      =1  
  50      =1  /** @name Setup */
  51      =1  //@{
  52      =1  /* Setup function prototypes */
  53      =1  
  54      =1  /** Enable or disable interrupt for radio.
  55      =1   * Use this function to enable or disable
  56      =1   * one of the interrupt sources for the radio.
  57      =1   * This function only changes state for selected
  58      =1   * int_type, the rest of the interrupt sources
  59      =1   * are left unchanged.
  60      =1   *
  61      =1   * @param int_source Radio interrupt Source.
  62      =1   * @param irq_state Enable or Disable.
  63      =1  */
  64      =1  void hal_nrf_set_irq_mode(hal_nrf_irq_source_t int_source, bool irq_state);
  65      =1  
  66      =1  /* For the obsolete nRF24L01 it is necessary to issue an activate command before the
  67      =1   * features enabled by the FEATURE register can be used. For nRF24L01+ these features
  68      =1   * are by default enabled.
  69      =1  */
  70      =1  void hal_nrf_activate_features(void);
  71      =1  
  72      =1  /** Enables the dynamic packet length
  73      =1   * @param enable Whether enable or disable dynamic packet length
  74      =1   */
  75      =1  void hal_nrf_enable_dynamic_payload(bool enable);
  76      =1  
  77      =1  /** Enables the ACK payload feature
  78      =1   * @param enable Whether to enable or disable ACK payload
  79      =1   */
  80      =1  void hal_nrf_enable_ack_payload(bool enable);
  81      =1  
  82      =1  /** Enables the dynamic ack feature
  83      =1   * @param enable Whether to enable or disable Dynamic ACK
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 49  

  84      =1   */
  85      =1  void hal_nrf_enable_dynamic_ack(bool enable);
  86      =1  
  87      =1  /** Function for enabling dynmic payload size.
  88      =1   * The input parameter contains is a byte where the bit values tells weather the
  89      =1   * pipe should use dynamic payload size. For example if bit 0 is set then 
  90      =1   * pipe 0 will accept dynamic payload size.
  91      =1   * @param setup Byte value telling for which pips(s) to enable dynamic payload size
  92      =1   */
  93      =1  void hal_nrf_setup_dynamic_payload(uint8_t setup);
  94      =1  
  95      =1  /** Reads the payload width of the received ack payload
  96      =1   * @return Payload width of the received ack payload
  97      =1   */
  98      =1  uint8_t hal_nrf_read_rx_payload_width(void);
  99      =1  
 100      =1  /** Write ack payload
 101      =1   * Writes the payload that will be transmitted with the ack on the given pipe.
 102      =1   * @param pipe Pipe that transmits the payload
 103      =1   * @param tx_pload Pointer to the payload data
 104      =1   * @param length Size of the data to transmit
 105      =1   */
 106      =1  void hal_nrf_write_ack_payload(uint8_t pipe, const uint8_t *tx_pload, uint8_t length);
 107      =1  
 108      =1  /** Read then clears all interrupt flags.
 109      =1   * Use this function to get the interrupt flags and clear them in the same operation.
 110      =1   * Reduced radio interface activity and speed optimized.
 111      =1   *
 112      =1   * @return  Interrupt_flags
 113      =1   * @retval 0x10 Max Retransmit interrupt
 114      =1   * @retval 0x20 TX Data sent interrupt
 115      =1   * @retval 0x40 RX Data received interrupt
 116      =1  */
 117      =1  uint8_t hal_nrf_get_clear_irq_flags(void);
 118      =1  
 119      =1  uint8_t hal_nrf_clear_irq_flags_get_status(void);
 120      =1  
 121      =1  /** Clear one selected interrupt flag.
 122      =1   * Use this function to clear one @a spesific interrupt flag.
 123      =1   * Other interrupt flags are left unchanged.
 124      =1   *
 125      =1   * @param int_source Interrupt source of which flag to clear
 126      =1  */
 127      =1  void hal_nrf_clear_irq_flag(hal_nrf_irq_source_t int_source);
 128      =1  
 129      =1  /** Set the CRC mode used by the radio.
 130      =1   * Use this function to set the CRC mode; CRC disabled, 1 or 2 bytes.
 131      =1   *
 132      =1   * @param crc_mode CRC mode to use
 133      =1  */
 134      =1  void hal_nrf_set_crc_mode(hal_nrf_crc_mode_t crc_mode);
 135      =1  
 136      =1  /** Open radio pipe(s) and enable/ disable auto acknowledge.
 137      =1   * Use this function to open one or all pipes,
 138      =1   * with or without auto acknowledge.
 139      =1   *
 140      =1   * @param pipe_num Radio pipe to open
 141      =1   * @param auto_ack Auto_Ack ON/OFF
 142      =1   * @see hal_nrf_address
 143      =1  */
 144      =1  void hal_nrf_open_pipe(hal_nrf_address_t pipe_num, bool auto_ack);
 145      =1  
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 50  

 146      =1  /** Close radio pipe(s).
 147      =1   * Use this function to close one pipe or all pipes.
 148      =1   *
 149      =1   * @param pipe_num Pipe# number to close
 150      =1  */
 151      =1  void hal_nrf_close_pipe(hal_nrf_address_t pipe_num);
 152      =1  
 153      =1  /** Set radio's RX address and TX address.
 154      =1   * Use this function to set a RX address, or to set the TX address.
 155      =1   * Beware of the difference for single and multibyte address registers.
 156      =1   *
 157      =1   * @param address Which address to set
 158      =1   * @param *addr Buffer from which the address is stored in
 159      =1  */
 160      =1  void hal_nrf_set_address(const hal_nrf_address_t address, const uint8_t *addr);
 161      =1  
 162      =1  /** Get address for selected pipe.
 163      =1   * Use this function to get address for selected pipe.
 164      =1   *
 165      =1   *
 166      =1   * @param address Which address to get, Pipe- or TX-address
 167      =1   * @param *addr buffer in which address bytes are written.
 168      =1   * <BR><BR>For pipes containing only LSB byte of address, this byte is returned
 169      =1   * in the<BR> *addr buffer.
 170      =1   *
 171      =1   * @return Numbers of bytes copied to addr
 172      =1  */
 173      =1  uint8_t hal_nrf_get_address (uint8_t address, uint8_t *addr);
 174      =1  
 175      =1  /** Set auto acknowledge parameters.
 176      =1   * Use this function to set retransmit and retransmit delay
 177      =1   * parameters.
 178      =1   *
 179      =1   * @param retr Number of retransmit, 0 equ retransmit OFF
 180      =1   * @param delay Retransmit delay in s. Must be a 
 181      =1  */
 182      =1  void hal_nrf_set_auto_retr(uint8_t retr, uint16_t delay);
 183      =1  
 184      =1  /** Set radio's address width.
 185      =1   * Use this function to define the radio's address width,
 186      =1   * referes to both RX and TX.
 187      =1   *
 188      =1   * @param address_width Address with in bytes
 189      =1  */
 190      =1  void hal_nrf_set_address_width(hal_nrf_address_width_t address_width);
 191      =1  
 192      =1  /** Gets the radio's address width.
 193      =1   *
 194      =1   * @return Address width
 195      =1   */
 196      =1  uint8_t hal_nrf_get_address_width (void);
 197      =1  
 198      =1  /** Set payload width for selected pipe.
 199      =1   * Use this function to set the number of bytes expected
 200      =1   * on a selected pipe.
 201      =1   *
 202      =1   * @param pipe_num Pipe number to set payload width for
 203      =1   * @param pload_width number of bytes expected
 204      =1  */
 205      =1  void hal_nrf_set_rx_payload_width(uint8_t pipe_num, uint8_t pload_width);
 206      =1  
 207      =1  /** Read current interrupt mode for selected interrupt source.
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 51  

 208      =1   * Use this function to get the interrupt source's mode,
 209      =1   * either enabled or disabled.
 210      =1   *
 211      =1   * @param int_source Interrupt source to get mode from
 212      =1   *
 213      =1   * @return Interrupt Mode
 214      =1   * @retval FALSE Interrupt disabled
 215      =1   * @retval TRUE Interrupt enabled
 216      =1  */
 217      =1  bool hal_nrf_get_irq_mode(uint8_t int_source);
 218      =1  
 219      =1  /** Read all interrupt flags.
 220      =1   * Use this function to get the interrupt flags. This function is similar
 221      =1   * to hal_nrf_get_clear_irq_flags with the exception that it does <I><B>NOT</B></I> clear
 222      =1   * the irq_flags.
 223      =1   *
 224      =1   * @return Interrupt_flags
 225      =1   * @retval 0x10 Max Retransmit interrupt
 226      =1   * @retval 0x20 TX Data sent interrupt
 227      =1   * @retval 0x40 RX Data received interrupt
 228      =1  */
 229      =1  uint8_t hal_nrf_get_irq_flags(void);
 230      =1  
 231      =1  /** Get pipe status.
 232      =1   * Use this function to check status for a selected pipe.
 233      =1   *
 234      =1   * @param  pipe_num Pipe number to check status for
 235      =1   *
 236      =1   * @return Pipe_Status
 237      =1   * @retval 0x00 Pipe is closed, autoack disabled
 238      =1   * @retval 0x01 Pipe is open, autoack disabled
 239      =1   * @retval 0x03 Pipe is open, autoack enabled
 240      =1  */
 241      =1  uint8_t hal_nrf_get_pipe_status(uint8_t pipe_num);
 242      =1  
 243      =1  /** Get auto retransmit parameters.
 244      =1   * Use this function to get the auto retransmit parameters,
 245      =1   * retrans count and retrans delay.
 246      =1   *
 247      =1   * @return AutoRetrans Parameters
 248      =1   *
 249      =1   * @retval UpperNibble Retransmit Delay
 250      =1   * @retval LowerNibble Retransmit Count
 251      =1  */
 252      =1  uint8_t hal_nrf_get_auto_retr_status(void);
 253      =1  
 254      =1  /** Get packet lost counter
 255      =1   * Use this function to get the packet(s) counter.
 256      =1   *
 257      =1   * @return packet lost counter
 258      =1  */
 259      =1  uint8_t hal_nrf_get_packet_lost_ctr(void);
 260      =1  
 261      =1  /** Get RX payload width for selected pipe.
 262      =1   * Use this function to get the expected payload
 263      =1   * width for selected ppe number.
 264      =1   *
 265      =1   * @param pipe_num Pipe number to get payload width for
 266      =1   *
 267      =1   * @return Payload_Width in bytes
 268      =1  */
 269      =1  uint8_t hal_nrf_get_rx_payload_width(uint8_t pipe_num);
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 52  

 270      =1  //@}
 271      =1  
 272      =1  /** @name Operation */
 273      =1  //@{
 274      =1  /* Operation function prototypes */
 275      =1  
 276      =1  /** Set radio's operation mode.
 277      =1   * Use this function to enter PTX (primary TX)
 278      =1   * or PRX (primary RX).
 279      =1   *
 280      =1   * @param op_mode Operation mode
 281      =1  */
 282      =1  void hal_nrf_set_operation_mode(hal_nrf_operation_mode_t op_mode);
 283      =1  
 284      =1  /** Set radio's power mode.
 285      =1   * Use this function to power_up or power_down radio.
 286      =1   *
 287      =1   * @param pwr_mode POWER_UP or POWER_DOWN
 288      =1  */
 289      =1  void hal_nrf_set_power_mode(hal_nrf_pwr_mode_t pwr_mode);
 290      =1  
 291      =1  /** Set radio's RF channel.
 292      =1   * Use this function to select which RF channel to use.
 293      =1   *
 294      =1   * @param channel RF channel
 295      =1  */
 296      =1  void hal_nrf_set_rf_channel(uint8_t channel);
 297      =1  
 298      =1  /** Set radio's TX output power.
 299      =1   * Use this function set the radio's TX output power.
 300      =1   *
 301      =1   * @param power Radio's TX output power
 302      =1  */
 303      =1  void hal_nrf_set_output_power(hal_nrf_output_power_t power);
 304      =1  
 305      =1  /** Set radio's on-air datarate.
 306      =1   * Use this function to select radio's on-air
 307      =1   * datarate.
 308      =1   *
 309      =1   * @param datarate On-air datarate
 310      =1  */
 311      =1  void hal_nrf_set_datarate(hal_nrf_datarate_t datarate);
 312      =1  
 313      =1  
 314      =1  /* Status functions prototypes */
 315      =1  
 316      =1  /** Get radio's TX FIFO status.
 317      =1   * Use this function to get the radio's TX
 318      =1   * FIFO status.
 319      =1   *
 320      =1   * @return TX FIFO status
 321      =1   * @retval 0x00 TX FIFO NOT empty, but NOT full
 322      =1   * @retval 0x01 FIFO empty
 323      =1   * @retval 0x02 FIFO full
 324      =1   *
 325      =1  */
 326      =1  uint8_t hal_nrf_get_tx_fifo_status(void);
 327      =1  
 328      =1  /** Check for TX FIFO empty.
 329      =1   * Use this function to check if TX FIFO
 330      =1   * is empty.
 331      =1   *
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 53  

 332      =1   * @return TX FIFO empty bit
 333      =1   * @retval FALSE TX FIFO NOT empty
 334      =1   * @retval TRUE TX FIFO empty
 335      =1   *
 336      =1  */
 337      =1  bool hal_nrf_tx_fifo_empty(void);
 338      =1  
 339      =1  /** Check for TX FIFO full.
 340      =1   * Use this function to check if TX FIFO
 341      =1   * is full.
 342      =1   *
 343      =1   * @return TX FIFO full bit
 344      =1   * @retval FALSE TX FIFO NOT full
 345      =1   * @retval TRUE TX FIFO full
 346      =1   *
 347      =1  */
 348      =1  bool hal_nrf_tx_fifo_full(void);
 349      =1  
 350      =1  /** Get radio's RX FIFO status.
 351      =1   * Use this function to get the radio's TX
 352      =1   * FIFO status.
 353      =1   *
 354      =1   * @return RX FIFO status
 355      =1   * @retval 0x00 RX FIFO NOT empty, but NOT full
 356      =1   * @retval 0x01 RX FIFO empty
 357      =1   * @retval 0x02 RX FIFO full
 358      =1   *
 359      =1  */
 360      =1  uint8_t hal_nrf_get_rx_fifo_status(void);
 361      =1  
 362      =1  /** Check for RX FIFO empty.
 363      =1   * Use this function to check if RX FIFO
 364      =1   * is empty.
 365      =1   *
 366      =1   * Reads STATUS register to check this, not FIFO_STATUS  
 367      =1   *
 368      =1   * @return RX FIFO empty bit
 369      =1   * @retval FALSE RX FIFO NOT empty
 370      =1   * @retval TRUE RX FIFO empty
 371      =1   *
 372      =1  */
 373      =1  bool hal_nrf_rx_fifo_empty(void);
 374      =1  
 375      =1  /** Check for RX FIFO full.
 376      =1   * Use this function to check if RX FIFO
 377      =1   * is full.
 378      =1   *
 379      =1   * @return RX FIFO full bit
 380      =1   * @retval FALSE RX FIFO NOT full
 381      =1   * @retval TRUE RX FIFO full
 382      =1   *
 383      =1  */
 384      =1  bool hal_nrf_rx_fifo_full(void);
 385      =1  
 386      =1  /** Get radio's transmit attempts status.
 387      =1   * Use this function to get number of retransmit
 388      =1   * attempts and number of packet lost.
 389      =1   *
 390      =1   * @return Retransmit attempts counters
 391      =1  */
 392      =1  uint8_t hal_nrf_get_transmit_attempts(void);
 393      =1  
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 54  

 394      =1  /** Get the carrier detect flag.
 395      =1   * Use this function to get the carrier detect flag,
 396      =1   * used to detect stationary disturbance on selected
 397      =1   * RF channel.
 398      =1   *
 399      =1   * @return Carrier Detect
 400      =1   * @retval FALSE Carrier NOT Detected
 401      =1   * @retval TRUE Carrier Detected
 402      =1  */
 403      =1  bool hal_nrf_get_carrier_detect(void);
 404      =1  
 405      =1  /* Data operation prototypes */
 406      =1  
 407      =1  /** Get RX data source.
 408      =1   * Use this function to read which RX pipe data
 409      =1   * was received on for current top level FIFO data packet.
 410      =1   *
 411      =1   * @return pipe number of current packet present
 412      =1  */
 413      =1  uint8_t hal_nrf_get_rx_data_source(void);
 414      =1  
 415      =1  /** Read RX payload.
 416      =1   * Use this function to read top level payload
 417      =1   * available in the RX FIFO.
 418      =1   *
 419      =1   * @param  *rx_pload pointer to buffer in which RX payload are stored
 420      =1   * @return pipe number (MSB byte) and packet length (LSB byte)
 421      =1  */
 422      =1  uint16_t hal_nrf_read_rx_payload(uint8_t *rx_pload);
 423      =1  
 424      =1  /** Write TX payload to radio.
 425      =1   * Use this function to write a packet of
 426      =1   * TX payload into the radio.
 427      =1   * <I>length</I> number of bytes, which are stored in <I>*tx_pload</I>.
 428      =1   *
 429      =1   * @param *tx_pload pointer to buffer in which TX payload are present
 430      =1   * @param length number of bytes to write
 431      =1  */
 432      =1  void hal_nrf_write_tx_payload(const uint8_t *tx_pload, uint8_t length);
 433      =1  
 434      =1  /** Write TX payload which do not require ACK. When transmitting 
 435      =1   * a ACK is not required nor sent from the receiver. The payload will
 436      =1   * always be assumed as "sent".
 437      =1   *
 438      =1   * Use this function to write a packet of
 439      =1   * TX payload into the radio.
 440      =1   * <I>length</I> number of bytes, which are stored in <I>*tx_pload</I>.
 441      =1   *
 442      =1   * @param *tx_pload pointer to buffer in which TX payload are present
 443      =1   * @param length number of bytes to write
 444      =1  */
 445      =1  void hal_nrf_write_tx_payload_noack(const uint8_t *tx_pload, uint8_t length);
 446      =1  
 447      =1  /** Reuse TX payload.
 448      =1   * Use this function to set that the radio is using
 449      =1   * the last transmitted payload for the next packet as well.
 450      =1   *
 451      =1  */
 452      =1  void hal_nrf_reuse_tx(void);
 453      =1  
 454      =1  /** Get status of reuse TX function.
 455      =1   * Use this function to check if reuse TX payload is
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 55  

 456      =1   * activated
 457      =1   *
 458      =1   * @return Reuse TX payload mode
 459      =1   * @retval FALSE Not activated
 460      =1   * @retval TRUE Activated
 461      =1  */
 462      =1  bool hal_nrf_get_reuse_tx_status(void);
 463      =1  
 464      =1  /** Flush RX FIFO.
 465      =1   * Use this function to flush the radio's
 466      =1   * RX FIFO.
 467      =1   *
 468      =1  */
 469      =1  void hal_nrf_flush_rx(void);
 470      =1  
 471      =1  /** Flush TX FIFO.
 472      =1   * Use this function to flush the radio's
 473      =1   * TX FIFO.
 474      =1   *
 475      =1  */
 476      =1  void hal_nrf_flush_tx(void);
 477      =1  
 478      =1  /** No Operation command.
 479      =1   * Use this function to receive the radio's
 480      =1   * status register.
 481      =1   *
 482      =1   * @return Status register
 483      =1  */
 484      =1  uint8_t hal_nrf_nop(void);
 485      =1  //@}
 486      =1  
 487      =1  /** @name  Test */
 488      =1  //@{
 489      =1  /* Test functions prototypes */
 490      =1  
 491      =1  /** Set radio's PLL mode.
 492      =1   * Use this function to either LOCK
 493      =1   * or UNLOCK the radio's PLL.
 494      =1   *
 495      =1   * @param pll_lock PLL locked, TRUE or FALSE
 496      =1  */
 497      =1  void hal_nrf_set_pll_mode(bool pll_lock);
 498      =1  
 499      =1  /** Set radio's LNA gain mode.
 500      =1   * Use this function to either use HI
 501      =1   * current or LOW current mode for the radio.
 502      =1   *
 503      =1   * @param lna_gain LNA gain mode
 504      =1  */
 505      =1  void hal_nrf_set_lna_gain(bool lna_gain);
 506      =1  
 507      =1  /** Enables continuous carrier transmit.
 508      =1   * Use this function to enable or disable
 509      =1   * continuous carrier transmission.
 510      =1   * @param enable Enable continuous carrier
 511      =1   */
 512      =1  void hal_nrf_enable_continious_wave (bool enable);
 513      =1  
 514      =1  /* hal_nrf_l01 basic functions, used by all the other functions */
 515      =1  
 516      =1  //@}
 517      =1  
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 56  

 518      =1  /** @name SPI interface */
 519      =1  //@{
 520      =1  
 521      =1  /** Basis function, nrf_rw
 522      =1   * This function is used by the basis functions
 523      =1   * to exchange data with the data.
 524      =1   *
 525      =1   * @param value Databyte to write
 526      =1   *
 527      =1   * @return Databyte from radio.
 528      =1  */
 529      =1  uint8_t hal_nrf_rw(uint8_t value);
 530      =1  //@}
 531      =1  #endif // HAL_NRF_H__
 532      =1  /** @} */
 533      =1  
  18          #include "hal_nrf_hw.h"
   1      =1  /* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
   2      =1   *
   3      =1   * The information contained herein is confidential property of Nordic 
   4      =1   * Semiconductor ASA.Terms and conditions of usage are described in detail 
   5      =1   * in NORDIC SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =1   *
   7      =1   * Licensees are granted free, non-transferable use of the information. NO
   8      =1   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =1   * the file.
  10      =1   *              
  11      =1   * $LastChangedRevision: 133 $
  12      =1   */
  13      =1  
  14      =1  /** @file
  15      =1  * @brief hal_nrf macros for nRF24LU1+
  16      =1   *
  17      =1   * @defgroup hal_nrf24lu1p_hal_nrf_hw hal_nrf_hw
  18      =1   * @{
  19      =1   * @ingroup hal_nrf24lu1p
  20      =1   *
  21      =1   */
  22      =1  
  23      =1  #ifndef HAL_NRF_LU1_H__
           =1 #define HAL_NRF_LU1_H__
           =1 #include "nrf24lu1p.h"
           =1 
           =1 /** Macro that set radio's CSN line LOW.
           =1  *
           =1  */
           =1 #define CSN_LOW() do { RFCSN = 0; } while(false)
           =1 
           =1 /** Macro that set radio's CSN line HIGH.
           =1  *
           =1  */
           =1 #define CSN_HIGH() do { RFCSN = 1; } while(false)
           =1 
           =1 /** Macro that set radio's CE line LOW.
           =1  *
           =1  */
           =1 #define CE_LOW() do { RFCE = 0; } while(false)
           =1 
           =1 /** Macro that set radio's CE line HIGH.
           =1  *
           =1  */
           =1 #define CE_HIGH() do { RFCE = 1; } while(false)
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 57  

           =1 
           =1 /** Macro for writing the radio SPI data register.
           =1  *
           =1  */
           =1 #define HAL_NRF_HW_SPI_WRITE(d) do{RFDAT = d; RFSPIF = 0;} while(false)
           =1 
           =1 /** Macro for reading the radio SPI data register.
           =1  *
           =1  */
           =1 #define HAL_NRF_HW_SPI_READ() RFDAT
           =1   
           =1 /** Macro specifyng the radio SPI busy flag.
           =1  *
           =1  */
           =1 #define HAL_NRF_HW_SPI_BUSY (!RFSPIF)
           =1 
           =1 /**
           =1  * Pulses the CE to nRF24L01 for at least 10 us
           =1  */
           =1 #define CE_PULSE() do { \
           =1   uint8_t count; \
           =1   count = 20; \
           =1   CE_HIGH();  \
           =1   while(count--){} \
           =1   CE_LOW();  \
           =1   } while(false)
           =1 
           =1 #endif // HAL_NRF_LU1_H__
  74      =1  
  75      =1  /** @} */
  19          
  20          #include "usb_map.h"
   1      =1  /* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
   2      =1   *
   3      =1   * The information contained herein is confidential property of Nordic 
   4      =1   * Semiconductor ASA.Terms and conditions of usage are described in detail 
   5      =1   * in NORDIC SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
   6      =1   *
   7      =1   * Licensees are granted free, non-transferable use of the information. NO
   8      =1   * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
   9      =1   * the file.
  10      =1   *              
  11      =1   * $LastChangedRevision: 133 $
  12      =1   */
  13      =1  
  14      =1  /** @file
  15      =1   * @brief USB register layout and interrupts
  16      =1   *
  17      =1   * This file contain:
  18      =1   * - the USB-controller register layout
  19      =1   * - the USB-controller interrupts towards the MCU
  20      =1   *
  21      =1   * The usb_map_t structure is set to point at xdata address 0x0000
  22      =1   */
  23      =1  #ifndef USB_MAP_H__
  24      =1  #define USB_MAP_H__
  25      =1  
  26      =1  #ifdef ALLOCATE_USB_MAP
           =1 #define EXTERN
           =1 #define _AT_ _at_
           =1 #else
  30      =1  #define EXTERN extern
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 58  

  31      =1  #define _AT_ ;/ ## /
  32      =1  #endif
  33      =1  
  34      =1  #define USB_EP_DEFAULT_BUF_SIZE 0x20 // (32)
  35      =1  
  36      =1  __no_init EXTERN xdata volatile uint8_t out5buf[USB_EP_DEFAULT_BUF_SIZE] _AT_ 0xC440;
  37      =1  __no_init EXTERN xdata volatile uint8_t in5buf[USB_EP_DEFAULT_BUF_SIZE]  _AT_ 0xC480;
  38      =1  __no_init EXTERN xdata volatile uint8_t out4buf[USB_EP_DEFAULT_BUF_SIZE] _AT_ 0xC4C0;
  39      =1  __no_init EXTERN xdata volatile uint8_t in4buf[USB_EP_DEFAULT_BUF_SIZE]  _AT_ 0xC500;
  40      =1  __no_init EXTERN xdata volatile uint8_t out3buf[USB_EP_DEFAULT_BUF_SIZE] _AT_ 0xC540;
  41      =1  __no_init EXTERN xdata volatile uint8_t in3buf[USB_EP_DEFAULT_BUF_SIZE]  _AT_ 0xC580;
  42      =1  __no_init EXTERN xdata volatile uint8_t out2buf[USB_EP_DEFAULT_BUF_SIZE] _AT_ 0xC5C0;
  43      =1  __no_init EXTERN xdata volatile uint8_t in2buf[USB_EP_DEFAULT_BUF_SIZE]  _AT_ 0xC600;
  44      =1  __no_init EXTERN xdata volatile uint8_t out1buf[USB_EP_DEFAULT_BUF_SIZE] _AT_ 0xC640;
  45      =1  __no_init EXTERN xdata volatile uint8_t in1buf[USB_EP_DEFAULT_BUF_SIZE]  _AT_ 0xC680;
  46      =1  __no_init EXTERN xdata volatile uint8_t out0buf[USB_EP_DEFAULT_BUF_SIZE] _AT_ 0xC6C0;
  47      =1  __no_init EXTERN xdata volatile uint8_t in0buf[USB_EP_DEFAULT_BUF_SIZE]  _AT_ 0xC700;
  48      =1  __no_init EXTERN xdata volatile uint8_t out8data                         _AT_ 0xC760;
  49      =1  __no_init EXTERN xdata volatile uint8_t in8data                          _AT_ 0xC768;
  50      =1  __no_init EXTERN xdata volatile uint8_t out8bch                          _AT_ 0xC770;
  51      =1  __no_init EXTERN xdata volatile uint8_t out8bcl                          _AT_ 0xC771;
  52      =1  __no_init EXTERN xdata volatile uint8_t bout1addr                        _AT_ 0xC781;
  53      =1  __no_init EXTERN xdata volatile uint8_t bout2addr                        _AT_ 0xC782;
  54      =1  __no_init EXTERN xdata volatile uint8_t bout3addr                        _AT_ 0xC783;
  55      =1  __no_init EXTERN xdata volatile uint8_t bout4addr                        _AT_ 0xC784;
  56      =1  __no_init EXTERN xdata volatile uint8_t bout5addr                        _AT_ 0xC785;
  57      =1  __no_init EXTERN xdata volatile uint8_t binstaddr                        _AT_ 0xC788;
  58      =1  __no_init EXTERN xdata volatile uint8_t bin1addr                         _AT_ 0xC789;
  59      =1  __no_init EXTERN xdata volatile uint8_t bin2addr                         _AT_ 0xC78A;
  60      =1  __no_init EXTERN xdata volatile uint8_t bin3addr                         _AT_ 0xC78B;
  61      =1  __no_init EXTERN xdata volatile uint8_t bin4addr                         _AT_ 0xC78C;
  62      =1  __no_init EXTERN xdata volatile uint8_t bin5addr                         _AT_ 0xC78D;
  63      =1  __no_init EXTERN xdata volatile uint8_t isoerr                           _AT_ 0xC7A0;
  64      =1  __no_init EXTERN xdata volatile uint8_t zbcout                           _AT_ 0xC7A2;
  65      =1  __no_init EXTERN xdata volatile uint8_t ivec                             _AT_ 0xC7A8;
  66      =1  __no_init EXTERN xdata volatile uint8_t in_irq                           _AT_ 0xC7A9;
  67      =1  __no_init EXTERN xdata volatile uint8_t out_irq                          _AT_ 0xC7AA;
  68      =1  __no_init EXTERN xdata volatile uint8_t usbirq                           _AT_ 0xC7AB;
  69      =1  __no_init EXTERN xdata volatile uint8_t in_ien                           _AT_ 0xC7AC;
  70      =1  __no_init EXTERN xdata volatile uint8_t out_ien                          _AT_ 0xC7AD;
  71      =1  __no_init EXTERN xdata volatile uint8_t usbien                           _AT_ 0xC7AE;
  72      =1  __no_init EXTERN xdata volatile uint8_t usbbav                           _AT_ 0xC7AF;
  73      =1  __no_init EXTERN xdata volatile uint8_t ep0cs                            _AT_ 0xC7B4;
  74      =1  __no_init EXTERN xdata volatile uint8_t in0bc                            _AT_ 0xC7B5;
  75      =1  __no_init EXTERN xdata volatile uint8_t in1cs                            _AT_ 0xC7B6;
  76      =1  __no_init EXTERN xdata volatile uint8_t in1bc                            _AT_ 0xC7B7;
  77      =1  __no_init EXTERN xdata volatile uint8_t in2cs                            _AT_ 0xC7B8;
  78      =1  __no_init EXTERN xdata volatile uint8_t in2bc                            _AT_ 0xC7B9;
  79      =1  __no_init EXTERN xdata volatile uint8_t in3cs                            _AT_ 0xC7BA;
  80      =1  __no_init EXTERN xdata volatile uint8_t in3bc                            _AT_ 0xC7BB;
  81      =1  __no_init EXTERN xdata volatile uint8_t in4cs                            _AT_ 0xC7BC;
  82      =1  __no_init EXTERN xdata volatile uint8_t in4bc                            _AT_ 0xC7BD;
  83      =1  __no_init EXTERN xdata volatile uint8_t in5cs                            _AT_ 0xC7BE;
  84      =1  __no_init EXTERN xdata volatile uint8_t in5bc                            _AT_ 0xC7BF;
  85      =1  __no_init EXTERN xdata volatile uint8_t out0bc                           _AT_ 0xC7C5;
  86      =1  __no_init EXTERN xdata volatile uint8_t out1cs                           _AT_ 0xC7C6;
  87      =1  __no_init EXTERN xdata volatile uint8_t out1bc                           _AT_ 0xC7C7;
  88      =1  __no_init EXTERN xdata volatile uint8_t out2cs                           _AT_ 0xC7C8;
  89      =1  __no_init EXTERN xdata volatile uint8_t out2bc                           _AT_ 0xC7C9;
  90      =1  __no_init EXTERN xdata volatile uint8_t out3cs                           _AT_ 0xC7CA;
  91      =1  __no_init EXTERN xdata volatile uint8_t out3bc                           _AT_ 0xC7CB;
  92      =1  __no_init EXTERN xdata volatile uint8_t out4cs                           _AT_ 0xC7CC;
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 59  

  93      =1  __no_init EXTERN xdata volatile uint8_t out4bc                           _AT_ 0xC7CD;
  94      =1  __no_init EXTERN xdata volatile uint8_t out5cs                           _AT_ 0xC7CE;
  95      =1  __no_init EXTERN xdata volatile uint8_t out5bc                           _AT_ 0xC7CF;
  96      =1  __no_init EXTERN xdata volatile uint8_t usbcs                            _AT_ 0xC7D6;
  97      =1  __no_init EXTERN xdata volatile uint8_t togctl                           _AT_ 0xC7D7;
  98      =1  __no_init EXTERN xdata volatile uint8_t usbfrml                          _AT_ 0xC7D8;
  99      =1  __no_init EXTERN xdata volatile uint8_t usbfrmh                          _AT_ 0xC7D9;
 100      =1  __no_init EXTERN xdata volatile uint8_t fnaddr                           _AT_ 0xC7DB;
 101      =1  __no_init EXTERN xdata volatile uint8_t usbpair                          _AT_ 0xC7DD;
 102      =1  __no_init EXTERN xdata volatile uint8_t inbulkval                        _AT_ 0xC7DE;
 103      =1  __no_init EXTERN xdata volatile uint8_t outbulkval                       _AT_ 0xC7DF;
 104      =1  __no_init EXTERN xdata volatile uint8_t inisoval                         _AT_ 0xC7E0;
 105      =1  __no_init EXTERN xdata volatile uint8_t outisoval                        _AT_ 0xC7E1;
 106      =1  __no_init EXTERN xdata volatile uint8_t isostaddr                        _AT_ 0xC7E2;
 107      =1  __no_init EXTERN xdata volatile uint8_t isosize                          _AT_ 0xC7E3;
 108      =1  __no_init EXTERN xdata volatile uint8_t setupbuf[8]                      _AT_ 0xC7E8;
 109      =1  __no_init EXTERN xdata volatile uint8_t out8addr                         _AT_ 0xC7F0;
 110      =1  __no_init EXTERN xdata volatile uint8_t in8addr                          _AT_ 0xC7F8;
 111      =1  
 112      =1  #endif
  21          
  22          #define SIZEOFPROG 11
  23          #define PKTLENGTH 32
  24          
  25           // Calculate buffer location in USB-controller
  26          #define CALCULATE_BUF_IN_PTR(ep) (uint8_t xdata *)(in0buf - (( ep & 0x7f) * 128))
  27          #define CALCULATE_BUF_OUT_PTR(ep) (uint8_t xdata *)(out0buf - (ep * 128 ))
  28          
  29          // Calculate byte count register location in USB-controller
  30          #define CALCULATE_BC_OUT_PTR(ep) (uint8_t xdata *)(&out0bc + (ep * 2 ))
  31          #define CALCULATE_BC_IN_PTR(ep) (uint8_t xdata *)(&in0bc + ((ep & 0x7f ) * 2))
  32          
  33          #define MSB(x) (x>>8)
*** WARNING C317 IN LINE 33 OF main.c: attempt to redefine macro 'MSB'
  34          #define LSB(x) (x&(0xFF))
*** WARNING C317 IN LINE 34 OF main.c: attempt to redefine macro 'LSB'
  35          
  36          static hal_usb_dev_req_resp_t device_req_cb(hal_usb_device_req* req, uint8_t** data_ptr, uint16_t* size) r
             -eentrant;   
  37          static void suspend_cb(uint8_t allow_remote_wu) reentrant;   
  38          static void resume_cb() reentrant;   
  39          static void reset_cb() reentrant;   
  40          static code uint8_t ep_1_in_cb(uint8_t *adr_ptr, uint8_t* size) reentrant;   
  41          //static code uint8_t ep_1_out_cb(uint8_t *adr_ptr, uint8_t* size) reentrant; 
  42          
  43          static void usb_process_get_descriptor(hal_usb_device_req* req, uint8_t** data_ptr, uint16_t* size, hal_us
             -b_dev_req_resp_t* resp);
  44          static void usb_wait_for_configuration(void);
  45          static void radio_init();
  46           
  47          //app_states_t app_susp_wd(void); 
  48          
  49          typedef enum 
  50          { 
  51           USB_AWAKE, 
  52           USB_REM_WU_ENABLE, 
  53           USB_REM_WU_DISABLE, 
  54          } usb_state_t; 
  55          
  56          typedef enum   
  57          { 
  58            APP_INIT = 0,     
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 60  

  59            APP_NORMAL,   
  60            APP_SUSP_WE ,   
  61            APP_SUSP_WD,     
  62          } app_states_t;   
  63          
  64          app_states_t app_init(void);
  65          static app_states_t app_normal(void);   
  66          app_states_t app_susp_we(void);  
  67          usb_state_t usb_get_state();
  68          
  69          void usb_wakeup(void);
  70           
  71          static data volatile usb_state_t usb_state;
  72          static bool ep1_sent, ep2_sent, ep2_rx; 
  73          static uint8_t *e_arr;
  74          static uint8_t e_size;
  75          // Global variables
  76          data bool radio_busy;
  77          //data uint8_t temp = 0;
  78          data uint8_t block = 0;
  79          data uint8_t byteCnt = 0;
  80          data uint8_t blockAcquired = 0;
  81          data uint8_t blockNeedsSending = 0;
  82          data uint8_t payload[2][PKTLENGTH];
  83          
  84          
  85          uint8_t data ackPayload[SIZEOFPROG];
  86          // uint8_t payload[2][30];
  87            sbit P0_0 = P0^0;
  88            sbit P0_4 = P0^4;
  89            sbit P0_5 = P0^5;
  90            sbit P0_6 = P0^6;
  91            sbit P0_7 = P0^7;
  92          
  93          void main(void) 
  94          {
  95   1              data app_states_t app_state = APP_INIT;  
  96   1              CLKCTL = 0;                                 // Reset clock control register
  97   1              P0DIR = (1<<3)|(1<<1)|(1<<0);
  98   1      //      P0DIR = 0x18;                               // Output: P0.0 - P0.2, Input: P0.3 - P0.5   
  99   1        //    P0ALT = 0;                                  // All general I/O   
 100   1        //    P0 = 0;
 101   1         /* 
 102   1               P0ALT = 0x0F;
 103   1               P0EXP = 0x02; // Slave SPI for P0
 104   1               SSCONF = 0x01; //Enable slave SPI
 105   1               */
 106   1              CE_LOW();                                   // Radio chip enable low   
 107   1              RFCTL = 0x10;                               // Internal MCU to radio SPI enable    
 108   1              RFCKEN = 1;                                 // Radio clk enable   
 109   1              RF = 1;                                     // Radio IRQ enable
 110   1                                                                                      // Enable global interrupt
 111   1        
 112   1              /** USB-init **/
 113   1              usbpair |= 0x01;
 114   1              hal_usb_init(true, device_req_cb, reset_cb, resume_cb, suspend_cb);
 115   1              hal_usb_endpoint_config(0x82, 32, ep_1_in_cb);
 116   1              hal_usb_endpoint_config(0x02, 32, ep_1_out_cb);
 117   1              
 118   1              ep1_sent = true;   
 119   1              ep2_sent = true;   
 120   1              usb_state = USB_AWAKE;   
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 61  

 121   1              
 122   1      
 123   1              EA = 1;
 124   1              usb_wait_for_configuration();               // Wait until USB enumerated
 125   1              
 126   1              byteCnt = PKTLENGTH;
 127   1              
 128   1              payload[1][PKTLENGTH-1] = 0xAA;
 129   1              payload[0][PKTLENGTH-1] = 0xAA;
 130   1      
 131   1              for(;;)
 132   1              {
 133   2                      switch(app_state)
 134   2                      {
 135   3                        case APP_INIT:
 136   3                              app_state = app_init();
 137   3                              break;   
 138   3                    case APP_NORMAL:                                                        // Normal state   
 139   3                      app_state = app_normal();   
 140   3                      break;   
 141   3                    case APP_SUSP_WE:                                                       // PC suspend state, remote
             - wakeup enabled   
 142   3                    case APP_SUSP_WD:                                                       // PC suspend state, remote
             - wakeup disabled   
 143   3                     // P0_4=1;
 144   3                              app_state = app_susp_we();
 145   3                      //      P0_4=0;   
 146   3                      break;   
 147   3                    default:   
 148   3                      break;
 149   3                      }
 150   2              }
 151   1                
 152   1              return;
 153   1      }
 154          
 155          static app_states_t app_normal(void)   
 156          {
 157   1              usb_state_t data temp_state = usb_get_state();
 158   1               uint8_t i = 0;
 159   1           uint8_t xdata *buf_ptr;
 160   1           uint8_t xdata *bc_ptr;
 161   1      
 162   1              if(temp_state == USB_REM_WU_ENABLE)   
 163   1              {   
 164   2              return APP_SUSP_WE;    
 165   2              }   
 166   1             
 167   1              if(temp_state == USB_REM_WU_DISABLE)   
 168   1              {   
 169   2              return APP_SUSP_WD;    
 170   2              }
 171   1              
 172   1              if(ep2_rx) // process data we got over USB
 173   1              {
 174   2                      ep2_rx = false;
 175   2      
 176   2                      hal_nrf_write_ack_payload(0, ackPayload, SIZEOFPROG);
 177   2              //      hal_usb_send_data(2, "\x00\x00", 2);    
 178   2              }
 179   1      
 180   1              if(blockNeedsSending) // process data from Wireless
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 62  

 181   1              {
 182   2                      blockNeedsSending = 0;
 183   2      
 184   2              /*   hal_usb_send_data(1,  payload[0], 31); */
 185   2                  P0_5=1;
 186   2          // Calculate the buffer pointer and byte count pointer
 187   2      
 188   2                  buf_ptr = CALCULATE_BUF_IN_PTR(2);
 189   2                  bc_ptr = CALCULATE_BC_IN_PTR(2);
 190   2                      
 191   2                      if( 0 == block )
 192   2                      {
 193   3                      //      buf_ptr = buf_ptr + 31; 
 194   3                      }
 195   2                  // Copy the data into the USB controller
 196   2                  for( i = 0; i < PKTLENGTH; ++i )
 197   2                  {
 198   3                      buf_ptr[i] = payload[block][i];
 199   3                  }
 200   2          
 201   2      //          buf_ptr[30] = block + (0xAA);
 202   2              *bc_ptr = PKTLENGTH;
 203   2                      // Set the number of bytes we want to send to USB-host. This also trigger sending of data to USB-host.
 204   2              
 205   2      
 206   2                      if(block)
 207   2                      {
 208   3                              block = 0;
 209   3                      } else {
 210   3                              block = 1;
 211   3                      }
 212   2                      P0_5=0;
 213   2                      /********/
 214   2              /*
 215   2                      // Write payload to radio USB FIFO
 216   2              hal_usb_send_data(1, payload[(block^0x01)], 31);
 217   2                      blockNeedsSending = 0;*/
 218   2              }
 219   1               
 220   1              return APP_NORMAL; 
 221   1      }
 222          
 223          app_states_t app_init(void)
 224          {
 225   1              if(usb_get_state() == USB_REM_WU_ENABLE)   
 226   1              {   
 227   2              return APP_SUSP_WE;    
 228   2              }   
 229   1             
 230   1              if(usb_get_state() == USB_REM_WU_DISABLE)   
 231   1              {   
 232   2              return APP_SUSP_WD;    
 233   2              }
 234   1         /*
 235   1              I3FR = 1;             // rising edge SPI ready detect
 236   1              INTEXP = 0x01; //Slave SPI Interrupt
 237   1              SPI = 1; // Enable SPI Interrupt
 238   1               */
 239   1              hal_nrf_enable_ack_payload(1);
 240   1              hal_nrf_enable_dynamic_payload(1);
 241   1              hal_nrf_setup_dynamic_payload(1 << 0); // Set up PIPE 0 to handle dynamic lengths
 242   1              hal_nrf_set_rf_channel(125); // 2525 MHz
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 63  

 243   1              hal_nrf_set_operation_mode(HAL_NRF_PRX);                // Configure radio as primary receiver (PTX) 
 244   1              //hal_nrf_set_rx_payload_width(HAL_NRF_PIPE0, 30);      // Set payload width to 30 bytes
 245   1              hal_nrf_set_power_mode(HAL_NRF_PWR_UP);                 // Power up radio
 246   1              CE_HIGH();         // Enable receiver
 247   1              
 248   1              return APP_NORMAL;      
 249   1      }
 250          
 251          app_states_t app_susp_we(void)   
 252          {   
 253   1      //  wdp_host_rx_setup(WDP_RX_SUSPEND);          // Set up WDP low power receive mode   
 254   1              
 255   1              usb_wakeup();
 256   1              return APP_NORMAL;
 257   1              CE_LOW();
 258   1              hal_nrf_set_power_mode(HAL_NRF_PWR_DOWN);                       // Power up radio
 259   1              
 260   1              RFCKEN = 0;     // disable the radio clock    
 261   1        //  usb_wakeup();   
 262   1       //   return APP_NORMAL;    
 263   1            
 264   1        // Minimize the powerconsumption by powering down the MCU    
 265   1        cklf_gpio_wakeup(0x0000, 0x0000);           // GPIO wakeup off   
 266   1        cklf_rtc_disable();   
 267   1        cklf_rtc_init(0x00, 0x1FFF);                // Setup power down timeout to app. 1 s   
 268   1        cpu_pwr_down();                             // MCU goto sleep   
 269   1                
 270   1        WUF = 0;                                    // Clear WU flag   
 271   1         
 272   1        return APP_SUSP_WE;      
 273   1      } 
 274                  
 275                  void slave_spi() interrupt INTERRUPT_SPI
 276                  {
 277   1               // P0_5 = 1;
 278   1                
 279   1                if(byteCnt==0)
 280   1                {
 281   2                      byteCnt = PKTLENGTH;
 282   2                      block^=0x01; // switch block
 283   2                      blockNeedsSending = 1;
 284   2                }
 285   1              
 286   1                byteCnt = (byteCnt - 1);
 287   1               
 288   1                payload[block][byteCnt] = SSDATA;
 289   1              //  P0_5 = 0;
 290   1              }                               
 291          // Rado interrupt 
 292          void rf_irq() interrupt INTERRUPT_RFIRQ
 293          {
 294   1        uint8_t irq_flags;
 295   1        uint8_t data *pbuf = payload[block];
 296   1        uint8_t data ctr = 0;
 297   1        
 298   1        P0_5=1;
 299   1        // Read and clear IRQ flags from radio
 300   1          CSN_LOW();
 301   1        // retval = hal_nrf_rw(W_REGISTER + reg);
 302   1      
 303   1        RFDAT = W_REGISTER + STATUS;
 304   1        RFSPIF = 0;     // ! IMPORTANT ! Clear RF SPI ready flag
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 64  

 305   1                        // after data written to RFDAT..
 306   1        while(!RFSPIF); // wait for byte transfer finished
 307   1          
 308   1        irq_flags = RFDAT;   // return SPI read value
 309   1      
 310   1      
 311   1        RFDAT = (BIT_6|BIT_5|BIT_4);
 312   1        RFSPIF = 0;     // ! IMPORTANT ! Clear RF SPI ready flag
 313   1                        // after data written to RFDAT..
 314   1        while(!RFSPIF); // wait for byte transfer finished
 315   1          
 316   1        // retval = RFDAT;   // return SPI read value
 317   1      
 318   1       //  hal_nrf_rw(value);
 319   1        CSN_HIGH();                                            
 320   1        irq_flags = irq_flags & (BIT_6|BIT_5|BIT_4);
 321   1       // irq_flags = hal_nrf_get_clear_irq_flags(); 
 322   1        
 323   1      
 324   1        // If data received
 325   1        if(irq_flags & (1<<HAL_NRF_RX_DR))
 326   1        {
 327   2          // Read payload
 328   2         // while(!hal_nrf_rx_fifo_empty())
 329   2         // {
 330   2                   // hal_nrf_read_rx_payload(payload[0]);
 331   2                       //hal_nrf_read_multibyte_reg( (uint8_t)HAL_NRF_RX_PLOAD, payload[0]);
 332   2                      if( (hal_nrf_get_rx_data_source()) < 7)
 333   2                    {
 334   3                      ctr = hal_nrf_read_rx_payload_width();
 335   3                      CSN_LOW();
 336   3                      hal_nrf_rw(R_RX_PAYLOAD);
 337   3                    }
 338   2                    else
 339   2                    {
 340   3                      ctr = 0;
 341   3                    }
 342   2                
 343   2                         
 344   2                       while(ctr--)
 345   2                      {
 346   3                              RFDAT = 0;
 347   3                              RFSPIF = 0;     // ! IMPORTANT ! Clear RF SPI ready flag
 348   3                        // after data written to RFDAT..
 349   3                              while(!RFSPIF); // wait for byte transfer finished
 350   3          
 351   3                        //return RFDAT;   // return SPI read value
 352   3                      *pbuf++ = RFDAT;
 353   3                      }
 354   2      
 355   2                      CSN_HIGH();
 356   2                      
 357   2          // Write received payload[0] to port 0
 358   2      //      P0=(payload[0]&(1<<5));
 359   2                 blockNeedsSending = 1;
 360   2              //}
 361   2              
 362   2        }
 363   1        P0_5=0;
 364   1      }
 365                                                                                                                                                    
 366          static void radio_init()
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 65  

 367          {
 368   1                // Enable radio SPI
 369   1              RFCTL = 0x10; 
 370   1              /** RF init **/
 371   1              RF = 1;                 // Enable RF interrupt
 372   1              RFCKEN = 1;     // Enable the radio clock
 373   1      
 374   1              hal_nrf_set_operation_mode(HAL_NRF_PRX);                // Configure radio as primary receiver (PRX) 
 375   1      //      hal_nrf_set_rx_payload_width(HAL_NRF_PIPE0, 30);        // Set payload width to 3 bytes
 376   1      /*      hal_nrf_set_power_mode(HAL_NRF_PWR_UP);                 // Power up radio
 377   1              CE_HIGH();         // Enable receiver 
 378   1      */
 379   1              return;
 380   1      }
 381          
 382          void usb_wakeup(void)   
 383          {   
 384   1        hal_usb_wakeup();
 385   1       // radio_init();   
 386   1        usb_state = USB_AWAKE;   
 387   1      }   
 388             
 389          usb_state_t usb_get_state()   
 390          {   
 391   1        return usb_state;   
 392   1      }
 393          
 394          void usb_wait_for_configuration(void)   
 395          {   
 396   1        volatile hal_usb_state_t usb_hal_state;   
 397   1        do   
 398   1        {   
 399   2          usb_hal_state = hal_usb_get_state();   
 400   2        }   
 401   1        while(usb_hal_state != CONFIGURED);   
 402   1      }
 403          
 404          static hal_usb_dev_req_resp_t device_req_cb(hal_usb_device_req* req, uint8_t** data_ptr, uint16_t* size) r
             -eentrant
 405          {
 406   1              hal_usb_dev_req_resp_t retval;  
 407   1              uint8_t reply[] = "Ping!";
 408   1              
 409   1              *data_ptr = reply;
 410   1              *size = 6;
 411   1              retval = DATA;
 412   1                      
 413   1              return retval;
 414   1      }
*** WARNING C280 IN LINE 404 OF main.c: 'req': unreferenced local variable
 415          
 416          static void suspend_cb(uint8_t allow_remote_wu) reentrant   
 417          {   
 418   1        USBSLP = 1; // Disable USB clock (auto clear)   
 419   1        
 420   1        if (allow_remote_wu == 1)   
 421   1        {   
 422   2          // Enable wake-up on USB and USBWU (bit3:0=1010)   
 423   2          // Enable MCU_WU (bit5:4=10 ) on RTC   
 424   2          WUCONF = (BIT_5 | BIT_3 | BIT_1);   
 425   2          usb_state = USB_REM_WU_ENABLE;   
 426   2        }   
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 66  

 427   1        else   
 428   1        {   
 429   2          // Enable wake-up on USB and USBWU (bit3:0=1010)   
 430   2          WUCONF = (BIT_3 | BIT_1);   
 431   2          usb_state = USB_REM_WU_DISABLE;   
 432   2        } 
 433   1      }
 434          
 435          static void resume_cb() reentrant   
 436          { 
 437   1      //  radio_init();  
 438   1        ep1_sent = true;   
 439   1        usb_state = USB_AWAKE;   
 440   1      }
 441          
 442          static void reset_cb() reentrant   
 443          { 
 444   1      //      radio_init();  
 445   1        ep1_sent = true;  
 446   1        usb_state = USB_AWAKE;    
 447   1      }
 448           
 449          static code uint8_t ep_1_in_cb(uint8_t *adr_ptr, uint8_t* size) reentrant   
 450          {  
 451   1        ep1_sent = true;   
 452   1        return 0x60; // NAK   
 453   1      }
*** WARNING C280 IN LINE 449 OF main.c: 'adr_ptr': unreferenced local variable
*** WARNING C280 IN LINE 449 OF main.c: 'size': unreferenced local variable
 454          
 455          uint8_t ep_1_out_cb( uint8_t xdata *adr_ptr, uint8_t xdata *size) reentrant   
 456          {
 457   1              static uint8_t xdata *buf_ptr;   
 458   1              static uint8_t i = 0; 
 459   1              
 460   1              buf_ptr = CALCULATE_BUF_OUT_PTR(2); 
 461   1              ep2_rx = true;
 462   1              //e_size = *size;
 463   1              // ep2_adr = adr_ptr
 464   1      
 465   1      
 466   1              for(i = 0; i < SIZEOFPROG; ++i)
 467   1              {
 468   2                      ackPayload[i] = buf_ptr[i];
 469   2              }  
 470   1              return 0xff; // clear OUT1 busy   
 471   1      }  
*** WARNING C280 IN LINE 455 OF main.c: 'adr_ptr': unreferenced local variable
*** WARNING C280 IN LINE 455 OF main.c: 'size': unreferenced local variable
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 67  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION main (BEGIN)
                                           ; SOURCE LINE # 93
                                           ; SOURCE LINE # 94
                                           ; SOURCE LINE # 95
0000 E4                CLR     A
0001 F500        R     MOV     app_state,A
                                           ; SOURCE LINE # 96
0003 F5A3              MOV     CLKCTL,A
                                           ; SOURCE LINE # 97
0005 75940B            MOV     P0DIR,#0BH
                                           ; SOURCE LINE # 106
0008 C290              CLR     RFCE
                                           ; SOURCE LINE # 107
000A 75E610            MOV     RFCTL,#010H
                                           ; SOURCE LINE # 108
000D D292              SETB    RFCKEN
                                           ; SOURCE LINE # 109
000F D2B9              SETB    RF
                                           ; SOURCE LINE # 113
0011 900000      E     MOV     DPTR,#usbpair
0014 E0                MOVX    A,@DPTR
0015 4401              ORL     A,#01H
0017 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 114
0018 900000      E     MOV     DPTR,#?_hal_usb_init?BYTE+04H
001B 74FF              MOV     A,#0FFH
001D F0                MOVX    @DPTR,A
001E A3                INC     DPTR
001F 7400        R     MOV     A,#HIGH _?reset_cb
0021 F0                MOVX    @DPTR,A
0022 A3                INC     DPTR
0023 7400        R     MOV     A,#LOW _?reset_cb
0025 F0                MOVX    @DPTR,A
0026 A3                INC     DPTR
0027 74FF              MOV     A,#0FFH
0029 F0                MOVX    @DPTR,A
002A A3                INC     DPTR
002B 7400        R     MOV     A,#HIGH _?resume_cb
002D F0                MOVX    @DPTR,A
002E A3                INC     DPTR
002F 7400        R     MOV     A,#LOW _?resume_cb
0031 F0                MOVX    @DPTR,A
0032 A3                INC     DPTR
0033 74FF              MOV     A,#0FFH
0035 F0                MOVX    @DPTR,A
0036 A3                INC     DPTR
0037 7400        R     MOV     A,#HIGH _?suspend_cb
0039 F0                MOVX    @DPTR,A
003A A3                INC     DPTR
003B 7400        R     MOV     A,#LOW _?suspend_cb
003D F0                MOVX    @DPTR,A
003E 7BFF              MOV     R3,#0FFH
0040 7A00        R     MOV     R2,#HIGH _?device_req_cb
0042 7900        R     MOV     R1,#LOW _?device_req_cb
0044 7F01              MOV     R7,#01H
0046 120000      E     LCALL   _hal_usb_init
                                           ; SOURCE LINE # 115
0049 7BFF              MOV     R3,#0FFH
004B 7A00        R     MOV     R2,#HIGH _?ep_1_in_cb
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 68  

004D 7900        R     MOV     R1,#LOW _?ep_1_in_cb
004F 7D20              MOV     R5,#020H
0051 7F82              MOV     R7,#082H
0053 120000      E     LCALL   _hal_usb_endpoint_config
                                           ; SOURCE LINE # 116
0056 7BFF              MOV     R3,#0FFH
0058 7A00        R     MOV     R2,#HIGH _?ep_1_out_cb
005A 7900        R     MOV     R1,#LOW _?ep_1_out_cb
005C 7D20              MOV     R5,#020H
005E 7F02              MOV     R7,#02H
0060 120000      E     LCALL   _hal_usb_endpoint_config
                                           ; SOURCE LINE # 118
0063 900000      R     MOV     DPTR,#ep1_sent
0066 7401              MOV     A,#01H
0068 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 119
0069 A3                INC     DPTR
006A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 120
006B E4                CLR     A
006C F500        R     MOV     usb_state,A
                                           ; SOURCE LINE # 123
006E D2AF              SETB    EA
                                           ; SOURCE LINE # 124
0070 120000      R     LCALL   usb_wait_for_configuration
                                           ; SOURCE LINE # 126
0073 750020      R     MOV     byteCnt,#020H
                                           ; SOURCE LINE # 128
0076 7500AA      R     MOV     payload+03FH,#0AAH
                                           ; SOURCE LINE # 129
0079 7500AA      R     MOV     payload+01FH,#0AAH
                                           ; SOURCE LINE # 131
007C         ?C0004:
                                           ; SOURCE LINE # 132
                                           ; SOURCE LINE # 133
007C E500        R     MOV     A,app_state
007E 14                DEC     A
007F 6011              JZ      ?C0008
0081 14                DEC     A
0082 6015              JZ      ?C0010
0084 14                DEC     A
0085 6012              JZ      ?C0010
0087 2403              ADD     A,#03H
0089 70F1              JNZ     ?C0004
                                           ; SOURCE LINE # 134
                                           ; SOURCE LINE # 135
008B         ?C0007:
                                           ; SOURCE LINE # 136
008B 120000      R     LCALL   app_init
008E 8F00        R     MOV     app_state,R7
                                           ; SOURCE LINE # 137
0090 80EA              SJMP    ?C0004
                                           ; SOURCE LINE # 138
0092         ?C0008:
                                           ; SOURCE LINE # 139
0092 120000      R     LCALL   app_normal
0095 8F00        R     MOV     app_state,R7
                                           ; SOURCE LINE # 140
0097 80E3              SJMP    ?C0004
                                           ; SOURCE LINE # 141
                                           ; SOURCE LINE # 142
0099         ?C0010:
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 69  

                                           ; SOURCE LINE # 144
0099 120000      R     LCALL   app_susp_we
009C 8F00        R     MOV     app_state,R7
                                           ; SOURCE LINE # 146
009E 80DC              SJMP    ?C0004
             ; FUNCTION main (END)

             ; FUNCTION app_normal (BEGIN)
                                           ; SOURCE LINE # 155
                                           ; SOURCE LINE # 156
                                           ; SOURCE LINE # 157
0000 120000      R     LCALL   usb_get_state
0003 8F00        R     MOV     temp_state,R7
                                           ; SOURCE LINE # 158
0005 E4                CLR     A
0006 900000      R     MOV     DPTR,#i
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 162
000A E500        R     MOV     A,temp_state
000C B40103            CJNE    A,#01H,?C0013
                                           ; SOURCE LINE # 163
                                           ; SOURCE LINE # 164
000F 7F02              MOV     R7,#02H
0011 22                RET     
                                           ; SOURCE LINE # 165
0012         ?C0013:
                                           ; SOURCE LINE # 167
0012 E500        R     MOV     A,temp_state
0014 B40203            CJNE    A,#02H,?C0015
                                           ; SOURCE LINE # 168
                                           ; SOURCE LINE # 169
0017 7F03              MOV     R7,#03H
0019 22                RET     
                                           ; SOURCE LINE # 170
001A         ?C0015:
                                           ; SOURCE LINE # 172
001A 900000      R     MOV     DPTR,#ep2_rx
001D E0                MOVX    A,@DPTR
001E 6012              JZ      ?C0016
                                           ; SOURCE LINE # 173
                                           ; SOURCE LINE # 174
0020 E4                CLR     A
0021 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 176
0022 FB                MOV     R3,A
0023 7A00        R     MOV     R2,#HIGH ackPayload
0025 7900        R     MOV     R1,#LOW ackPayload
0027 900000      E     MOV     DPTR,#?_hal_nrf_write_ack_payload?BYTE+04H
002A 740B              MOV     A,#0BH
002C F0                MOVX    @DPTR,A
002D E4                CLR     A
002E FF                MOV     R7,A
002F 120000      E     LCALL   _hal_nrf_write_ack_payload
                                           ; SOURCE LINE # 178
0032         ?C0016:
                                           ; SOURCE LINE # 180
0032 E500        R     MOV     A,blockNeedsSending
0034 6050              JZ      ?C0017
                                           ; SOURCE LINE # 181
                                           ; SOURCE LINE # 182
0036 E4                CLR     A
0037 F500        R     MOV     blockNeedsSending,A
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 70  

                                           ; SOURCE LINE # 185
0039 D285              SETB    P0_5
                                           ; SOURCE LINE # 188
003B 7E00        E     MOV     R6,#HIGH in0buf+0FF00H
003D 7F00        E     MOV     R7,#LOW in0buf+0FF00H
;---- Variable 'buf_ptr' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 189
003F 7C00        E     MOV     R4,#HIGH in0bc+04H
0041 7D00        E     MOV     R5,#LOW in0bc+04H
;---- Variable 'bc_ptr' assigned to Register 'R4/R5' ----
                                           ; SOURCE LINE # 191
                                           ; SOURCE LINE # 192
                                           ; SOURCE LINE # 194
0043         ?C0018:
                                           ; SOURCE LINE # 196
0043 E4                CLR     A
0044 900000      R     MOV     DPTR,#i
0047 F0                MOVX    @DPTR,A
0048         ?C0019:
                                           ; SOURCE LINE # 197
                                           ; SOURCE LINE # 198
0048 900000      R     MOV     DPTR,#i
004B E0                MOVX    A,@DPTR
004C F9                MOV     R1,A
004D E500        R     MOV     A,block
004F C4                SWAP    A
0050 33                RLC     A
0051 54E0              ANL     A,#0E0H
0053 2400        R     ADD     A,#LOW payload
0055 29                ADD     A,R1
0056 F8                MOV     R0,A
0057 E6                MOV     A,@R0
0058 FB                MOV     R3,A
0059 8F82              MOV     DPL,R7
005B 8E83              MOV     DPH,R6
005D EF                MOV     A,R7
005E 29                ADD     A,R1
005F F582              MOV     DPL,A
0061 E4                CLR     A
0062 3E                ADDC    A,R6
0063 F583              MOV     DPH,A
0065 EB                MOV     A,R3
0066 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 199
0067 900000      R     MOV     DPTR,#i
006A E0                MOVX    A,@DPTR
006B 04                INC     A
006C F0                MOVX    @DPTR,A
006D E0                MOVX    A,@DPTR
006E B420D7            CJNE    A,#020H,?C0019
0071         ?C0020:
                                           ; SOURCE LINE # 202
0071 8D82              MOV     DPL,R5
0073 8C83              MOV     DPH,R4
0075 7420              MOV     A,#020H
0077 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 206
0078 E500        R     MOV     A,block
007A 6005              JZ      ?C0022
                                           ; SOURCE LINE # 207
                                           ; SOURCE LINE # 208
007C E4                CLR     A
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 71  

007D F500        R     MOV     block,A
                                           ; SOURCE LINE # 209
007F 8003              SJMP    ?C0023
0081         ?C0022:
                                           ; SOURCE LINE # 210
0081 750001      R     MOV     block,#01H
                                           ; SOURCE LINE # 211
0084         ?C0023:
                                           ; SOURCE LINE # 212
0084 C285              CLR     P0_5
                                           ; SOURCE LINE # 218
0086         ?C0017:
                                           ; SOURCE LINE # 220
0086 7F01              MOV     R7,#01H
                                           ; SOURCE LINE # 221
0088         ?C0014:
0088 22                RET     
             ; FUNCTION app_normal (END)

             ; FUNCTION app_init (BEGIN)
                                           ; SOURCE LINE # 223
                                           ; SOURCE LINE # 224
                                           ; SOURCE LINE # 225
0000 120000      R     LCALL   usb_get_state
0003 BF0103            CJNE    R7,#01H,?C0024
                                           ; SOURCE LINE # 226
                                           ; SOURCE LINE # 227
0006 7F02              MOV     R7,#02H
0008 22                RET     
                                           ; SOURCE LINE # 228
0009         ?C0024:
                                           ; SOURCE LINE # 230
0009 120000      R     LCALL   usb_get_state
000C BF0203            CJNE    R7,#02H,?C0026
                                           ; SOURCE LINE # 231
                                           ; SOURCE LINE # 232
000F 7F03              MOV     R7,#03H
0011 22                RET     
                                           ; SOURCE LINE # 233
0012         ?C0026:
                                           ; SOURCE LINE # 239
0012 7F01              MOV     R7,#01H
0014 120000      E     LCALL   _hal_nrf_enable_ack_payload
                                           ; SOURCE LINE # 240
0017 7F01              MOV     R7,#01H
0019 120000      E     LCALL   _hal_nrf_enable_dynamic_payload
                                           ; SOURCE LINE # 241
001C 7F01              MOV     R7,#01H
001E 120000      E     LCALL   _hal_nrf_setup_dynamic_payload
                                           ; SOURCE LINE # 242
0021 7F7D              MOV     R7,#07DH
0023 120000      E     LCALL   _hal_nrf_set_rf_channel
                                           ; SOURCE LINE # 243
0026 7F01              MOV     R7,#01H
0028 120000      E     LCALL   _hal_nrf_set_operation_mode
                                           ; SOURCE LINE # 245
002B 7F01              MOV     R7,#01H
002D 120000      E     LCALL   _hal_nrf_set_power_mode
                                           ; SOURCE LINE # 246
0030 D290              SETB    RFCE
                                           ; SOURCE LINE # 248
0032 7F01              MOV     R7,#01H
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 72  

                                           ; SOURCE LINE # 249
0034         ?C0025:
0034 22                RET     
             ; FUNCTION app_init (END)

             ; FUNCTION app_susp_we (BEGIN)
                                           ; SOURCE LINE # 251
                                           ; SOURCE LINE # 252
                                           ; SOURCE LINE # 255
0000 120000      R     LCALL   usb_wakeup
                                           ; SOURCE LINE # 256
0003 7F01              MOV     R7,#01H
                                           ; SOURCE LINE # 257
                                           ; SOURCE LINE # 258
                                           ; SOURCE LINE # 260
                                           ; SOURCE LINE # 265
                                           ; SOURCE LINE # 266
                                           ; SOURCE LINE # 267
                                           ; SOURCE LINE # 268
                                           ; SOURCE LINE # 270
                                           ; SOURCE LINE # 272
                                           ; SOURCE LINE # 273
0005         ?C0030:
0005 22                RET     
             ; FUNCTION app_susp_we (END)

             ; FUNCTION slave_spi (BEGIN)
0000 C0E0              PUSH    ACC
0002 C0D0              PUSH    PSW
0004 75D000            MOV     PSW,#00H
0007 C000              PUSH    AR0
                                           ; SOURCE LINE # 275
                                           ; SOURCE LINE # 279
0009 E500        R     MOV     A,byteCnt
000B 7009              JNZ     ?C0034
                                           ; SOURCE LINE # 280
                                           ; SOURCE LINE # 281
000D 750020      R     MOV     byteCnt,#020H
                                           ; SOURCE LINE # 282
0010 630001      R     XRL     block,#01H
                                           ; SOURCE LINE # 283
0013 750001      R     MOV     blockNeedsSending,#01H
                                           ; SOURCE LINE # 284
0016         ?C0034:
                                           ; SOURCE LINE # 286
0016 1500        R     DEC     byteCnt
                                           ; SOURCE LINE # 288
0018 E500        R     MOV     A,block
001A C4                SWAP    A
001B 33                RLC     A
001C 54E0              ANL     A,#0E0H
001E 2400        R     ADD     A,#LOW payload
0020 2500        R     ADD     A,byteCnt
0022 F8                MOV     R0,A
0023 A6BD              MOV     @R0,SSDATA
                                           ; SOURCE LINE # 290
0025 D000              POP     AR0
0027 D0D0              POP     PSW
0029 D0E0              POP     ACC
002B 32                RETI    
             ; FUNCTION slave_spi (END)

C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 73  

             ; FUNCTION rf_irq (BEGIN)
0000 C0E0              PUSH    ACC
0002 C0F0              PUSH    B
0004 C083              PUSH    DPH
0006 C082              PUSH    DPL
0008 C0D0              PUSH    PSW
000A 75D000            MOV     PSW,#00H
000D C000              PUSH    AR0
000F C001              PUSH    AR1
0011 C002              PUSH    AR2
0013 C003              PUSH    AR3
0015 C004              PUSH    AR4
0017 C005              PUSH    AR5
0019 C006              PUSH    AR6
001B C007              PUSH    AR7
                                           ; SOURCE LINE # 292
                                           ; SOURCE LINE # 295
001D E500        R     MOV     A,block
001F C4                SWAP    A
0020 33                RLC     A
0021 54E0              ANL     A,#0E0H
0023 2400        R     ADD     A,#LOW payload
0025 900000      R     MOV     DPTR,#pbuf
0028 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 296
0029 750000      R     MOV     ctr,#00H
                                           ; SOURCE LINE # 298
002C D285              SETB    P0_5
                                           ; SOURCE LINE # 300
002E C291              CLR     RFCSN
                                           ; SOURCE LINE # 303
0030 75E527            MOV     RFDAT,#027H
                                           ; SOURCE LINE # 304
0033 C2C0              CLR     RFSPIF
0035         ?C0039:
                                           ; SOURCE LINE # 306
0035 30C0FD            JNB     RFSPIF,?C0039
0038         ?C0040:
                                           ; SOURCE LINE # 308
;---- Variable 'irq_flags' assigned to Register 'R7' ----
0038 AFE5              MOV     R7,RFDAT
                                           ; SOURCE LINE # 311
003A 75E570            MOV     RFDAT,#070H
                                           ; SOURCE LINE # 312
003D C2C0              CLR     RFSPIF
003F         ?C0041:
                                           ; SOURCE LINE # 314
003F 30C0FD            JNB     RFSPIF,?C0041
0042         ?C0042:
0042         ?C0045:
                                           ; SOURCE LINE # 319
0042 D291              SETB    RFCSN
                                           ; SOURCE LINE # 320
0044 EF                MOV     A,R7
0045 5470              ANL     A,#070H
0047 FF                MOV     R7,A
                                           ; SOURCE LINE # 325
0048 30E63B            JNB     ACC.6,?C0046
                                           ; SOURCE LINE # 326
                                           ; SOURCE LINE # 332
004B 120000      E     LCALL   hal_nrf_get_rx_data_source
004E EF                MOV     A,R7
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 74  

004F C3                CLR     C
0050 9407              SUBB    A,#07H
0052 500E              JNC     ?C0047
                                           ; SOURCE LINE # 333
                                           ; SOURCE LINE # 334
0054 120000      E     LCALL   hal_nrf_read_rx_payload_width
0057 8F00        R     MOV     ctr,R7
                                           ; SOURCE LINE # 335
0059 C291              CLR     RFCSN
                                           ; SOURCE LINE # 336
005B 7F61              MOV     R7,#061H
005D 120000      E     LCALL   _hal_nrf_rw
                                           ; SOURCE LINE # 337
0060 8003              SJMP    ?C0052
0062         ?C0047:
                                           ; SOURCE LINE # 339
                                           ; SOURCE LINE # 340
0062 750000      R     MOV     ctr,#00H
                                           ; SOURCE LINE # 341
0065         ?C0052:
                                           ; SOURCE LINE # 344
0065 AF00        R     MOV     R7,ctr
0067 1500        R     DEC     ctr
0069 EF                MOV     A,R7
006A 6015              JZ      ?C0058
                                           ; SOURCE LINE # 345
                                           ; SOURCE LINE # 346
006C 75E500            MOV     RFDAT,#00H
                                           ; SOURCE LINE # 347
006F C2C0              CLR     RFSPIF
0071         ?C0054:
                                           ; SOURCE LINE # 349
0071 30C0FD            JNB     RFSPIF,?C0054
0074         ?C0055:
                                           ; SOURCE LINE # 352
0074 900000      R     MOV     DPTR,#pbuf
0077 E0                MOVX    A,@DPTR
0078 FF                MOV     R7,A
0079 04                INC     A
007A F0                MOVX    @DPTR,A
007B A807              MOV     R0,AR7
007D A6E5              MOV     @R0,RFDAT
                                           ; SOURCE LINE # 353
007F 80E4              SJMP    ?C0052
0081         ?C0058:
                                           ; SOURCE LINE # 355
0081 D291              SETB    RFCSN
                                           ; SOURCE LINE # 359
0083 750001      R     MOV     blockNeedsSending,#01H
                                           ; SOURCE LINE # 362
0086         ?C0046:
                                           ; SOURCE LINE # 363
0086 C285              CLR     P0_5
                                           ; SOURCE LINE # 364
0088 D007              POP     AR7
008A D006              POP     AR6
008C D005              POP     AR5
008E D004              POP     AR4
0090 D003              POP     AR3
0092 D002              POP     AR2
0094 D001              POP     AR1
0096 D000              POP     AR0
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 75  

0098 D0D0              POP     PSW
009A D082              POP     DPL
009C D083              POP     DPH
009E D0F0              POP     B
00A0 D0E0              POP     ACC
00A2 32                RETI    
             ; FUNCTION rf_irq (END)

             ; FUNCTION radio_init (BEGIN)
                                           ; SOURCE LINE # 366
                                           ; SOURCE LINE # 367
                                           ; SOURCE LINE # 369
0000 75E610            MOV     RFCTL,#010H
                                           ; SOURCE LINE # 371
0003 D2B9              SETB    RF
                                           ; SOURCE LINE # 372
0005 D292              SETB    RFCKEN
                                           ; SOURCE LINE # 374
0007 7F01              MOV     R7,#01H
0009 120000      E     LCALL   _hal_nrf_set_operation_mode
                                           ; SOURCE LINE # 380
000C         ?C0060:
000C 22                RET     
             ; FUNCTION radio_init (END)

             ; FUNCTION usb_wakeup (BEGIN)
                                           ; SOURCE LINE # 382
                                           ; SOURCE LINE # 383
                                           ; SOURCE LINE # 384
0000 120000      E     LCALL   hal_usb_wakeup
                                           ; SOURCE LINE # 386
0003 E4                CLR     A
0004 F500        R     MOV     usb_state,A
                                           ; SOURCE LINE # 387
0006 22                RET     
             ; FUNCTION usb_wakeup (END)

             ; FUNCTION usb_get_state (BEGIN)
                                           ; SOURCE LINE # 389
                                           ; SOURCE LINE # 390
                                           ; SOURCE LINE # 391
0000 AF00        R     MOV     R7,usb_state
                                           ; SOURCE LINE # 392
0002         ?C0062:
0002 22                RET     
             ; FUNCTION usb_get_state (END)

             ; FUNCTION usb_wait_for_configuration (BEGIN)
                                           ; SOURCE LINE # 394
                                           ; SOURCE LINE # 395
0000         ?C0065:
                                           ; SOURCE LINE # 398
                                           ; SOURCE LINE # 399
0000 120000      E     LCALL   hal_usb_get_state
0003 900000      R     MOV     DPTR,#usb_hal_state
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 400
                                           ; SOURCE LINE # 401
0008 E0                MOVX    A,@DPTR
0009 B404F4            CJNE    A,#04H,?C0065
                                           ; SOURCE LINE # 402
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 76  

000C 22                RET     
             ; FUNCTION usb_wait_for_configuration (END)

             ; FUNCTION _?device_req_cb (BEGIN)
                                           ; SOURCE LINE # 404
0000 90FFFD            MOV     DPTR,#0FFFDH
0003 120000      E     LCALL   ?C?ADDXBP
0006 EB                MOV     A,R3
0007 F0                MOVX    @DPTR,A
0008 A3                INC     DPTR
0009 EA                MOV     A,R2
000A F0                MOVX    @DPTR,A
000B A3                INC     DPTR
000C E9                MOV     A,R1
000D F0                MOVX    @DPTR,A
000E 90FFF9            MOV     DPTR,#0FFF9H
0011 120000      E     LCALL   ?C?ADDXBP
                                           ; SOURCE LINE # 407
0014 850083      E     MOV     DPH,?C_XBP
0017 850082      E     MOV     DPL,?C_XBP+01H
001A A3                INC     DPTR
001B A882              MOV     R0,DPL
001D AC83              MOV     R4,DPH
001F 7D01              MOV     R5,#01H
0021 7BFF              MOV     R3,#0FFH
0023 7A00        R     MOV     R2,#HIGH _?ix1000
0025 7900        R     MOV     R1,#LOW _?ix1000
0027 7E00              MOV     R6,#00H
0029 7F06              MOV     R7,#06H
002B 120000      E     LCALL   ?C?COPY
                                           ; SOURCE LINE # 409
002E 7B01              MOV     R3,#01H
0030 850083      E     MOV     DPH,?C_XBP
0033 850082      E     MOV     DPL,?C_XBP+01H
0036 A3                INC     DPTR
0037 A982              MOV     R1,DPL
0039 AA83              MOV     R2,DPH
003B C003              PUSH    AR3
003D C002              PUSH    AR2
003F C001              PUSH    AR1
0041 90000A            MOV     DPTR,#0AH
0044 120000      E     LCALL   ?C?XBPOFF
0047 E0                MOVX    A,@DPTR
0048 FB                MOV     R3,A
0049 A3                INC     DPTR
004A E0                MOVX    A,@DPTR
004B FA                MOV     R2,A
004C A3                INC     DPTR
004D E0                MOVX    A,@DPTR
004E F9                MOV     R1,A
004F 120000      E     LCALL   ?C?PSTPTR
                                           ; SOURCE LINE # 410
0052 90000D            MOV     DPTR,#0DH
0055 120000      E     LCALL   ?C?XBPOFF
0058 E0                MOVX    A,@DPTR
0059 FB                MOV     R3,A
005A A3                INC     DPTR
005B E0                MOVX    A,@DPTR
005C FA                MOV     R2,A
005D A3                INC     DPTR
005E E0                MOVX    A,@DPTR
005F F9                MOV     R1,A
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 77  

0060 E4                CLR     A
0061 75F006            MOV     B,#06H
0064 120000      E     LCALL   ?C?ISTPTR
                                           ; SOURCE LINE # 411
0067 850083      E     MOV     DPH,?C_XBP
006A 850082      E     MOV     DPL,?C_XBP+01H
006D 7404              MOV     A,#04H
006F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 413
0070 E0                MOVX    A,@DPTR
0071 FF                MOV     R7,A
                                           ; SOURCE LINE # 414
0072         ?C0067:
0072 900010            MOV     DPTR,#010H
0075 020000      E     LJMP    ?C?ADDXBP
             ; FUNCTION _?device_req_cb (END)

             ; FUNCTION _?suspend_cb (BEGIN)
                                           ; SOURCE LINE # 416
0000 90FFFF            MOV     DPTR,#0FFFFH
0003 120000      E     LCALL   ?C?ADDXBP
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 418
0008 75D901            MOV     USBSLP,#01H
                                           ; SOURCE LINE # 420
000B 850083      E     MOV     DPH,?C_XBP
000E 850082      E     MOV     DPL,?C_XBP+01H
0011 E0                MOVX    A,@DPTR
0012 B40108            CJNE    A,#01H,?C0068
                                           ; SOURCE LINE # 421
                                           ; SOURCE LINE # 424
0015 75A52A            MOV     WUCONF,#02AH
                                           ; SOURCE LINE # 425
0018 750001      R     MOV     usb_state,#01H
                                           ; SOURCE LINE # 426
001B 8006              SJMP    ?C0070
001D         ?C0068:
                                           ; SOURCE LINE # 428
                                           ; SOURCE LINE # 430
001D 75A50A            MOV     WUCONF,#0AH
                                           ; SOURCE LINE # 431
0020 750002      R     MOV     usb_state,#02H
                                           ; SOURCE LINE # 432
                                           ; SOURCE LINE # 433
0023         ?C0070:
0023 900001            MOV     DPTR,#01H
0026 020000      E     LJMP    ?C?ADDXBP
             ; FUNCTION _?suspend_cb (END)

             ; FUNCTION _?resume_cb (BEGIN)
                                           ; SOURCE LINE # 435
                                           ; SOURCE LINE # 438
0000 900000      R     MOV     DPTR,#ep1_sent
0003 7401              MOV     A,#01H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 439
0006 E4                CLR     A
0007 F500        R     MOV     usb_state,A
                                           ; SOURCE LINE # 440
0009 22                RET     
             ; FUNCTION _?resume_cb (END)
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 78  


             ; FUNCTION _?reset_cb (BEGIN)
                                           ; SOURCE LINE # 442
                                           ; SOURCE LINE # 445
0000 900000      R     MOV     DPTR,#ep1_sent
0003 7401              MOV     A,#01H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 446
0006 E4                CLR     A
0007 F500        R     MOV     usb_state,A
                                           ; SOURCE LINE # 447
0009 22                RET     
             ; FUNCTION _?reset_cb (END)

             ; FUNCTION _?ep_1_in_cb (BEGIN)
                                           ; SOURCE LINE # 449
0000 90FFFD            MOV     DPTR,#0FFFDH
0003 120000      E     LCALL   ?C?ADDXBP
0006 EB                MOV     A,R3
0007 F0                MOVX    @DPTR,A
0008 A3                INC     DPTR
0009 EA                MOV     A,R2
000A F0                MOVX    @DPTR,A
000B A3                INC     DPTR
000C E9                MOV     A,R1
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 451
000E 900000      R     MOV     DPTR,#ep1_sent
0011 7401              MOV     A,#01H
0013 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 452
0014 7F60              MOV     R7,#060H
                                           ; SOURCE LINE # 453
0016         ?C0073:
0016 900006            MOV     DPTR,#06H
0019 020000      E     LJMP    ?C?ADDXBP
             ; FUNCTION _?ep_1_in_cb (END)

             ; FUNCTION _?ep_1_out_cb (BEGIN)
                                           ; SOURCE LINE # 455
0000 90FFFE            MOV     DPTR,#0FFFEH
0003 120000      E     LCALL   ?C?ADDXBP
0006 EC                MOV     A,R4
0007 F0                MOVX    @DPTR,A
0008 A3                INC     DPTR
0009 ED                MOV     A,R5
000A F0                MOVX    @DPTR,A
000B 90FFFE            MOV     DPTR,#0FFFEH
000E 120000      E     LCALL   ?C?ADDXBP
0011 EE                MOV     A,R6
0012 F0                MOVX    @DPTR,A
0013 A3                INC     DPTR
0014 EF                MOV     A,R7
0015 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 460
0016 900000      R     MOV     DPTR,#buf_ptr
0019 7400        E     MOV     A,#HIGH out0buf+0FF00H
001B F0                MOVX    @DPTR,A
001C A3                INC     DPTR
001D 7400        E     MOV     A,#LOW out0buf+0FF00H
001F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 461
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 79  

0020 900000      R     MOV     DPTR,#ep2_rx
0023 7401              MOV     A,#01H
0025 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 466
0026 E4                CLR     A
0027 900000      R     MOV     DPTR,#i
002A F0                MOVX    @DPTR,A
002B         ?C0074:
                                           ; SOURCE LINE # 467
                                           ; SOURCE LINE # 468
002B 900000      R     MOV     DPTR,#i
002E E0                MOVX    A,@DPTR
002F FF                MOV     R7,A
0030 900000      R     MOV     DPTR,#buf_ptr
0033 E0                MOVX    A,@DPTR
0034 FC                MOV     R4,A
0035 A3                INC     DPTR
0036 E0                MOVX    A,@DPTR
0037 2F                ADD     A,R7
0038 F582              MOV     DPL,A
003A E4                CLR     A
003B 3C                ADDC    A,R4
003C F583              MOV     DPH,A
003E E0                MOVX    A,@DPTR
003F FE                MOV     R6,A
0040 7400        R     MOV     A,#LOW ackPayload
0042 2F                ADD     A,R7
0043 F8                MOV     R0,A
0044 A606              MOV     @R0,AR6
                                           ; SOURCE LINE # 469
0046 900000      R     MOV     DPTR,#i
0049 E0                MOVX    A,@DPTR
004A 04                INC     A
004B F0                MOVX    @DPTR,A
004C E0                MOVX    A,@DPTR
004D B40BDB            CJNE    A,#0BH,?C0074
0050         ?C0075:
                                           ; SOURCE LINE # 470
0050 7FFF              MOV     R7,#0FFH
                                           ; SOURCE LINE # 471
0052         ?C0077:
0052 900004            MOV     DPTR,#04H
0055 020000      E     LJMP    ?C?ADDXBP
             ; FUNCTION _?ep_1_out_cb (END)

C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 80  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


hal_nrf_address_t. . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
HAL_NRF_CRC_16BIT. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
uint16_t . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
ackPayload . . . . . . . . . . . . . .  PUBLIC   DATA   ARRAY    0000H  11
P0 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0080H  1
HAL_NRF_0DBM . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
CMD_FLASH_SET_PROTECTED. . . . . . . .  E_CONST  -----  U_CHAR   -----  1
STALL. . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
e_size . . . . . . . . . . . . . . . .  STATIC   XDATA  U_CHAR   0003H  1
hal_nrf_address_width_t. . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
_hal_nrf_set_rf_channel. . . . . . . .  EXTERN   CODE   PROC     -----  -----
_hal_usb_endpoint_config . . . . . . .  EXTERN   CODE   PROC     -----  -----
EA . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AFH  1
rf_irq . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  irq_flags. . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
  pbuf . . . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0000H  1
  ctr. . . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0000H  1
cklf_rtc_disable . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
int32_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  LONG     -----  4
HAL_NRF_6DBM . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
DEFAULT. . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
int16_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  INT      -----  2
hal_usb_get_state. . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
APP_SUSP_WD. . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_hal_nrf_enable_ack_payload. . . . . .  EXTERN   CODE   PROC     -----  -----
e_arr. . . . . . . . . . . . . . . . .  STATIC   XDATA  PTR      0004H  3
APP_SUSP_WE. . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
IEN0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A8H  1
block. . . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   000BH  1
APP_NORMAL . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_hal_nrf_setup_dynamic_payload . . . .  EXTERN   CODE   PROC     -----  -----
packetizer_t . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  5
  data_ptr . . . . . . . . . . . . . .  MEMBER   -----  PTR      0000H  3
  data_size. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  pkt_size . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
IEN1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B8H  1
app_states_t . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
HAL_NRF_PWR_DOWN . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
size_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
HAL_NRF_CRC_OFF. . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
ADDRESSED. . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
P0_5 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0085H  1
USB_REM_WU_DISABLE . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
RF . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B9H  1
POWERED. . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
DATA . . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
usb_descs_templ_t. . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  13
  dev. . . . . . . . . . . . . . . . .  MEMBER   -----  PTR      0000H  3
  conf . . . . . . . . . . . . . . . .  MEMBER   -----  PTR      0003H  3
  string . . . . . . . . . . . . . . .  MEMBER   -----  PTR      0006H  3
  string_zero. . . . . . . . . . . . .  MEMBER   -----  ARRAY    0009H  4
HAL_NRF_RX_DR. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
HAL_NRF_ACK_PLOAD. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
cpu_pwr_down . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
CMD_FIRMWARE_VERSION . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
hal_usb_dev_req_resp_t . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
RFCE . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0090H  1
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 81  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


HAL_NRF_TX_DS. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
CMD_FLASH_READ . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
ep1_sent . . . . . . . . . . . . . . .  STATIC   XDATA  U_CHAR   0007H  1
usb_string_desc_templ_t. . . . . . . .  TYPEDEF  -----  STRUCT   -----  6
  idx. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  6
ep2_sent . . . . . . . . . . . . . . .  STATIC   XDATA  U_CHAR   0008H  1
usb_state_t. . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
hal_usb_cb_endpoint_t. . . . . . . . .  TYPEDEF  -----  PTR      -----  3
_hal_nrf_set_power_mode. . . . . . . .  EXTERN   CODE   PROC     -----  -----
_cklf_gpio_wakeup. . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
main . . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  app_state. . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0000H  1
hal_usb_common_desc_t. . . . . . . . .  TYPEDEF  -----  STRUCT   -----  2
  bLength. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  bDescriptorType. . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
radio_init . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
_hal_nrf_rw. . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
CMD_FLASH_WRITE_INIT . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
HAL_NRF_TX . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_?suspend_cb . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  allow_remote_wu. . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
app_susp_we. . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
SUSPENDED. . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
app_normal . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  temp_state . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0000H  1
  i. . . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  buf_ptr. . . . . . . . . . . . . . .  * REG *  DATA   PTR      0006H  2
  bc_ptr . . . . . . . . . . . . . . .  * REG *  DATA   PTR      0004H  2
usb_conf_desc_templ_t. . . . . . . . .  TYPEDEF  -----  STRUCT   -----  32
  conf . . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  9
  if0. . . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0009H  9
  ep1in. . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0012H  7
  ep1out . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0019H  7
HAL_NRF_AW_3BYTES. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
HAL_NRF_AW_4BYTES. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
HAL_NRF_AW_5BYTES. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
HAL_NRF_12DBM. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
hal_usb_string_desc_t. . . . . . . . .  TYPEDEF  -----  STRUCT   -----  3
  desc . . . . . . . . . . . . . . . .  MEMBER   -----  PTR      0000H  3
TCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0088H  1
USB_AWAKE. . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
hal_usb_t. . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  29
  descs. . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  13
  bm_state . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   000DH  1
  current_config . . . . . . . . . . .  MEMBER   -----  U_CHAR   000EH  1
  current_alt_interface. . . . . . . .  MEMBER   -----  U_CHAR   000FH  1
  state. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0010H  1
  device_req . . . . . . . . . . . . .  MEMBER   -----  PTR      0011H  3
  reset. . . . . . . . . . . . . . . .  MEMBER   -----  PTR      0014H  3
  resume . . . . . . . . . . . . . . .  MEMBER   -----  PTR      0017H  3
  suspend. . . . . . . . . . . . . . .  MEMBER   -----  PTR      001AH  3
radio_busy . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   000CH  1
_?resume_cb. . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
HAL_NRF_18DBM. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
RFCKEN . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0092H  1
hal_usb_state_t. . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
usb_wakeup . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 82  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


hal_nrf_get_rx_data_source . . . . . .  EXTERN   CODE   PROC     -----  -----
CLKCTL . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A3H  1
ATTACHED . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
blockAcquired. . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   000DH  1
hal_usb_conf_desc_t. . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  9
  bLength. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  bDescriptorType. . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  wTotalLength . . . . . . . . . . . .  MEMBER   -----  U_INT    0002H  2
  bNumInterfaces . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  bConfigurationValue. . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
  iConfiguration . . . . . . . . . . .  MEMBER   -----  U_CHAR   0006H  1
  bmAttributes . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0007H  1
  bMaxPower. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0008H  1
SSDATA . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BDH  1
_?ix1000 . . . . . . . . . . . . . . .  STATIC   CODE   ARRAY    0000H  6
_?device_req_cb. . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  req. . . . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0000H  3
  data_ptr . . . . . . . . . . . . . .  AUTO     XDATA  PTR      000AH  3
  size . . . . . . . . . . . . . . . .  AUTO     XDATA  PTR      000DH  3
  retval . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  reply. . . . . . . . . . . . . . . .  AUTO     XDATA  ARRAY    0001H  6
_hal_nrf_enable_dynamic_payload. . . .  EXTERN   CODE   PROC     -----  -----
_?ep_1_in_cb . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  adr_ptr. . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0000H  3
  size . . . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0003H  3
CMD_FLASH_SELECT_HALF. . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
hal_usb_cb_suspend_t . . . . . . . . .  TYPEDEF  -----  PTR      -----  3
USB_REM_WU_ENABLE. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
in0buf . . . . . . . . . . . . . . . .  EXTERN   XDATA  ARRAY    -----  32
HAL_NRF_250KBPS. . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_?ep_1_out_cb. . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  adr_ptr. . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0000H  2
  size . . . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0002H  2
  buf_ptr. . . . . . . . . . . . . . .  STATIC   XDATA  PTR      0000H  2
  i. . . . . . . . . . . . . . . . . .  STATIC   XDATA  U_CHAR   0002H  1
out0buf. . . . . . . . . . . . . . . .  EXTERN   XDATA  ARRAY    -----  32
slave_spi. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
_?reset_cb . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
RFSPIF . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C0H  1
USBCON . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A0H  1
_hal_nrf_set_operation_mode. . . . . .  EXTERN   CODE   PROC     -----  -----
blockNeedsSending. . . . . . . . . . .  PUBLIC   DATA   U_CHAR   000EH  1
in0bc. . . . . . . . . . . . . . . . .  EXTERN   XDATA  U_CHAR   -----  1
_hal_nrf_write_ack_payload . . . . . .  EXTERN   CODE   PROC     -----  -----
HAL_NRF_CRC_8BIT . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
ACK. . . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
uint8_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
usb_state. . . . . . . . . . . . . . .  STATIC   DATA   U_CHAR   000FH  1
hal_usb_hid_desc_t . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  9
  bLength. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  bDescriptorType. . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  bcdHID . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0002H  2
  bCountryCode . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  bNumDescriptors. . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
  bDescriptorType2 . . . . . . . . . .  MEMBER   -----  U_CHAR   0006H  1
  wDescriptorLength. . . . . . . . . .  MEMBER   -----  U_INT    0007H  2
ep2_rx . . . . . . . . . . . . . . . .  STATIC   XDATA  U_CHAR   0009H  1
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 83  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


hal_usb_cb_resume_t. . . . . . . . . .  TYPEDEF  -----  PTR      -----  3
hal_usb_wakeup . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
WUCONF . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A5H  1
hal_nrf_crc_mode_t . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
HAL_NRF_ALL. . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
hal_nrf_irq_source_t . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
app_init . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
int8_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  CHAR     -----  1
hal_nrf_output_power_t . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
NAK. . . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
hal_usb_dev_desc_t . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  18
  bLength. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  bDescriptorType. . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  bcdUSB . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0002H  2
  bDeviceClass . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  bDeviceSubClass. . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
  bDeviceProtocol. . . . . . . . . . .  MEMBER   -----  U_CHAR   0006H  1
  bMaxPacketSize0. . . . . . . . . . .  MEMBER   -----  U_CHAR   0007H  1
  idVendor . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0008H  2
  idProduct. . . . . . . . . . . . . .  MEMBER   -----  U_INT    000AH  2
  bcdDevice. . . . . . . . . . . . . .  MEMBER   -----  U_INT    000CH  2
  iManufacturer. . . . . . . . . . . .  MEMBER   -----  U_CHAR   000EH  1
  iProduct . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   000FH  1
  iSerialNumber. . . . . . . . . . . .  MEMBER   -----  U_CHAR   0010H  1
  bNumConfigurations . . . . . . . . .  MEMBER   -----  U_CHAR   0011H  1
USBSLP . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D9H  1
hal_usb_cb_device_req_t. . . . . . . .  TYPEDEF  -----  PTR      -----  3
byteCnt. . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0010H  1
HAL_NRF_PIPE0. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
HAL_NRF_PIPE1. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
HAL_NRF_PIPE2. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
hal_nrf_datarate_t . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
HAL_NRF_PIPE3. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
P0DIR. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0094H  1
HAL_NRF_PIPE4. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
hal_usb_device_req . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  6
  bmRequestType. . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  bRequest . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  wValueMsb. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  wValueLsb. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  wIndex . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  wLength. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
HAL_NRF_PIPE5. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
HAL_NRF_1MBPS. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
HAL_NRF_2MBPS. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_cklf_rtc_init . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
usb_command_t. . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
hal_usb_cb_reset_t . . . . . . . . . .  TYPEDEF  -----  PTR      -----  3
EMPTY_RESPONSE . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
S0CON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0098H  1
T2CON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C8H  1
hal_usb_if_desc_t. . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  9
  bLength. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  bDescriptorType. . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  bInterfaceNumber . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  bAlternateSetting. . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  bNumEndpoints. . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
C51 COMPILER V9.03   MAIN                                                                  06/20/2011 20:16:56 PAGE 84  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


  bInterfaceClass. . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
  bInterfaceSubClass . . . . . . . . .  MEMBER   -----  U_CHAR   0006H  1
  bInterfaceProtocol . . . . . . . . .  MEMBER   -----  U_CHAR   0007H  1
  iInterface . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0008H  1
CONFIGURED . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
hal_nrf_pload_command_t. . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
HAL_NRF_MAX_RT . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
FSR. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F8H  1
_Bool. . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
payload. . . . . . . . . . . . . . . .  PUBLIC   DATA   ARRAY    0011H  64
usb_wait_for_configuration . . . . . .  STATIC   CODE   PROC     0000H  -----
  usb_hal_state. . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
hal_usb_ep_desc_t. . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  7
  bLength. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  bDescriptorType. . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  bEndpointAddress . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  bmAttributes . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  wMaxPacketSize . . . . . . . . . . .  MEMBER   -----  U_INT    0004H  2
  bInterval. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0006H  1
NO_RESPONSE. . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
AESCS. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E8H  1
usb_get_state. . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
WUF. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C5H  1
RFDAT. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E5H  1
hal_nrf_operation_mode_t . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
hal_nrf_pwr_mode_t . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
CMD_FLASH_ERASE_PAGE . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
APP_INIT . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
HAL_NRF_PRX. . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_hal_usb_init. . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
RFCON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0090H  1
usbpair. . . . . . . . . . . . . . . .  EXTERN   XDATA  U_CHAR   -----  1
HAL_NRF_RX_PLOAD . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
HAL_NRF_PTX. . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
PSW. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D0H  1
hal_nrf_read_rx_payload_width. . . . .  EXTERN   CODE   PROC     -----  -----
HAL_NRF_TX_PLOAD . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
uint32_t . . . . . . . . . . . . . . .  TYPEDEF  -----  U_LONG   -----  4
RFCTL. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E6H  1
WDCON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D8H  1
IRCON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C0H  1
HAL_NRF_PWR_UP . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
RFCSN. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0091H  1


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    896    ----
   CONSTANT SIZE    =      6    ----
   XDATA SIZE       =     10       3
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     81       3
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  7 WARNING(S),  0 ERROR(S)
